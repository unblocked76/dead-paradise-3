//start game
let DP3 = {
        font1: 'Arial',
        font2: 'Century Gothic Bold',
        font3: 'F3theHardwayRMX',
        font4: 'Arial Black',
        font5: 'F321impact',
        cachebuster: '?v=' + version,
        googleID: 'UA-144761097-34',
        googleGameName: 'dead_paradise_3',
        title: 'Dead Paradise 3',
        gdId: '6e89ae8c523d4331885be9a7079a4057',
        gameKey: 'e052f709ade85729d0f9292bb485cd8a',
        secret: 'a75c13f2fd079ae562b6da1d2574bde5860c5a31',
        sendMenuEvents: true,
        isMainMenu: true
    },
    box2d = {
        b2Vec2: Box2D.Common.Math.b2Vec2,
        b2AABB: Box2D.Collision.b2AABB,
        b2SimplexCache: Box2D.Collision.b2SimplexCache,
        b2Distance: Box2D.Collision.b2Distance,
        b2DistanceInput: Box2D.Collision.b2DistanceInput,
        b2DistanceProxy: Box2D.Collision.b2DistanceProxy,
        b2DistanceOutput: Box2D.Collision.b2DistanceOutput,
        b2BodyDef: Box2D.Dynamics.b2BodyDef,
        b2Body: Box2D.Dynamics.b2Body,
        b2FixtureDef: Box2D.Dynamics.b2FixtureDef,
        b2Fixture: Box2D.Dynamics.b2Fixture,
        b2World: Box2D.Dynamics.b2World,
        b2MassData: Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape: Box2D.Collision.Shapes.b2PolygonShape,
        b2CircleShape: Box2D.Collision.Shapes.b2CircleShape,
        b2DebugDraw: Box2D.Dynamics.b2DebugDraw,
        b2LineJointDef:  Box2D.Dynamics.Joints.b2LineJointDef,
        b2MouseJointDef:  Box2D.Dynamics.Joints.b2MouseJointDef,
        b2DistanceJointDef: Box2D.Dynamics.Joints.b2DistanceJointDef,
        b2RevoluteJointDef: Box2D.Dynamics.Joints.b2RevoluteJointDef,
        b2PrismaticJointDef: Box2D.Dynamics.Joints.b2PrismaticJointDef,
        b2PulleyJointDef: Box2D.Dynamics.Joints.b2PulleyJointDef,
        b2GearJointDef: Box2D.Dynamics.Joints.b2GearJointDef,
        b2ContactListener: Box2D.Dynamics.b2ContactListener,
        b2ContactFilter: Box2D.Dynamics.b2ContactFilter,
        b2DestructionListener: Box2D.Dynamics.b2DestructionListener,

        SCALE: 30
    };
;DP3.Image = class extends Phaser.Image {
    constructor(game, x, y, image, frame) {
        super(game, x, y, image, frame);
        
        this._sizeData = {
            width: 1,
            height: 1
        };
        this.calculSizeData();
    }
    
    calculSizeData() {
        this._sizeData.width = this.width * this.scale.x;
        this._sizeData.height = this.height * this.scale.y;
    }
    
    getSizeData() {
        return this._sizeData;
    }
    
    getAnimation(name) {
        const config = this.game.cache.getJSON("config");
        
        if(config) {
            return config["animations"][name];
        }
        
        return false;
    }
    
    _createElement(data, trn = true) {
        if(!data)return;
        
        const position = data.position || [0, 0],
              anchor = data.anchor || [0.5, 0.5],
              scale = data.scale || [1, 1],
              d = (this._translation && trn) ? this._translation : [0, 0],
              sp = this._posScale ? this._posScale : 1;
        
        return this._createImage(data.image, data.frame, sp * position[0] + d[0], sp * position[1] + d[1], anchor[0], anchor[1], scale[0], scale[1], data.rotation);
    }
    
    _createImage(image, frame, x = 0, y = 0, ax = 0, ay = 0, sx = 1, sy = 1, rotation = 0) {
        const res = new Phaser.Image(this.game, x, y, image, frame);
        res.anchor.set(ax, ay);
        res.scale.set(sx, sy);
        res.rotation = rotation;
        return res;
    }
    
    getWrap() {
        return new Phaser.Image(this.game, 0, 0);
    }
    
    _absAngle(L) {
        const L1 = (Number(L) % (Math.PI * 2));
        
        if(L1 < 0) {
            return Math.PI * 2 + L1;
        }
        
        return L1;
    }
    
    _extremum(num, min = -1, max = 1) {
        return num < min ? min : (num > max ? max : num);
    }
    
    _getFrameTo(name, num) {
        let res = String(num);
        
        for(let i = 0, l = 3 - res.length; (i | 0) < l; i+=1) {
            res = "0" + res;
        }
        
        return name + "_" + res + ".png";
    }
    
    _createFrameAnim(image, name, start = false, loop = false, cb, step) {
        const data = this.getAnimation(name);
        
        if(image && name && data) {
            const count = data.frames instanceof Array ? data.frames.length : data.frames,
                  tween = this.game.add.tween(image).to({}, 1000 / (data.speed || 1), null, start);
            
            //image.loadTexture(data.image);
            
            tween.loop(true);
            
            tween.onLoop.add(this._createCounter((x) => {
                const frames = data["frames"],
                      frameName = data["frameName"] || name;
                
                let num = 0;
                
                if(frames instanceof Array) {
                    const step = frames[Math.round(x % count)];//[image, num] or image

                     if(step instanceof Array) {
                        num = step[0].toString();

                        if(image.key !== step[1]) {
                            image.loadTexture(step[1]);
                        }
                    } else {
                        if(image.key !== data.image) {
                            image.loadTexture(data.image);
                        }
                        num = step.toString();
                    }
                } else {
                    if(image.key !== data.image) {
                        image.loadTexture(data.image);
                    }
                    num = String((x % count) + 1);
                }
                
                
                image.frameName = this._getFrameTo(frameName, num);
                
                if(!loop && ((x + 1) > count)) {
                    tween.pause();
                    if(cb && cb instanceof Function) {
                        cb();
                    }
                    return true;
                }
                
            }, step));
            
            return tween;
        }
    }
    
    _createCounter(cb, x = 0) {
        return function(cb) {
            let counter = x;

            return () => {
                if(cb && cb(counter)){
                    counter = 0;
                } else {
                    counter++;
                }
            }
        }(cb);
    }
};;DP3.Sprite = class extends Phaser.Sprite {
    constructor(game, x, y, image, frame) {
        super(game, x, y, image, frame);
    }
    
    getAnimation(name) {
        const config = this.game.cache.getJSON("config");
        
        if(config) {
            return config["animations"][name];
        }
        
        return false;
    }
    
    _absAngle(L) {
        const L1 = (Number(L) % (Math.PI * 2));
        
        if(L1 < 0) {
            return Math.PI * 2 + L1;
        }
        
        return L1;
    }
    
    _extremum(num, min = -1, max = 1) {
        return num < min ? min : (num > max ? max : num);
    }
    
    _optimalRadian(ang) {
        return ((ang) % (Math.PI * 2) + Math.PI * 3) % (Math.PI * 2) - Math.PI;
    }
    
    _shorterWay(startVec, finishVec) {
        const a1 = Math.atan2(startVec.y, startVec.x),
              a2 = Math.atan2(finishVec.y, finishVec.x),
              ma1 = Math.atan2( -startVec.y, -startVec.x);
        
        let state1,
            state2;
        
        if (startVec.x >= 0) {
            if (startVec.y >= 0)
                state1 = 4;
            else
                state1 = 1;
        }else {
            if (startVec.y >= 0)
                state1 = 3;
            else
                state1 = 2;
        }
        if (finishVec.x >= 0) {
            if (finishVec.y >= 0)
                state2 = 4;
            else
                state2 = 1;
        }else {
            if (finishVec.y >= 0)
                state2 = 3;
            else
                state2 = 2;
        }
        switch(state1) {
            case 1:
                switch(state2) {
                    case 1:return a2 - a1 > 0 ? 1 : -1;
                    case 2:return -1;
                    case 3:return a2 - ma1 > 0 ? -1 : 1;
                    case 4:return 1;
                }
            case 2:
                switch(state2) {
                    case 1:return 1;
                    case 2:return a2 - a1 > 0 ? 1 : -1;
                    case 3:return -1;
                    case 4:return a2 - ma1 > 0 ? -1 : 1;
                }
            case 3:
                switch(state2) {
                    case 1:return a2 - ma1 > 0 ? -1 : 1;
                    case 2:return 1;
                    case 3:return a2 - a1 > 0 ? 1 : -1;
                    case 4:return -1;
                }
            case 4:
                switch(state2) {
                    case 1:return -1;
                    case 2:return a2 - ma1 > 0 ? -1 : 1;
                    case 3:return 1;
                    case 4:return a2 - a1 > 0 ? 1 : -1;
                }
        }
        return 0;
    }
    
    _createElement(data, trn = true) {
        if(!data)return;
        
        const position = data.position || [0, 0],
              anchor = data.anchor || [0.5, 0.5],
              scale = data.scale || [1, 1],
              d = (this._translation && trn) ? this._translation : [0, 0],
              sp = this._posScale ? this._posScale : 1;
        
        return this._createImage(data.image, data.frame, sp * position[0] + d[0], sp * position[1] + d[1], anchor[0], anchor[1], scale[0], scale[1], data.rotation);
    }
    
    _createImage(image, frame, x = 0, y = 0, ax = 0, ay = 0, sx = 1, sy = 1, rotation = 0) {
        const res = new Phaser.Image(this.game, x, y, image, frame);
        res.anchor.set(ax, ay);
        res.scale.set(sx, sy);
        res.rotation = rotation;
        return res;
    }
    
    getWrap() {
        return new Phaser.Image(this.game, 0, 0);
    }
    
    _getFrameTo(name, num) {
        let res = String(num);
        
        for(let i = 0, l = 3 - res.length; (i | 0) < l; i+=1) {
            res = "0" + res;
        }
        
        return name + "_" + res + ".png";
    }
    
    _createFrameAnim(image, name, start = false, loop = false, cb, step) {
        const data = this.getAnimation(name);
        
        if(image && name && data) {
            const count = data.frames instanceof Array ? data.frames.length : data.frames,
                  tween = this.game.add.tween(image).to({}, 1000 / (data.speed || 1), null, start);
            
            //image.loadTexture(data.image);
            
            tween.loop(true); 
            
            tween.onLoop.add(this._createCounter((x) => {
                const frames = data["frames"],
                      frameName = data["frameName"] || name;
                
                let num = 0;
                
                if(frames instanceof Array) {
                    const step = frames[Math.round(x % count)];//[image, num] or image

                     if(step instanceof Array) {
                        num = step[0].toString();

                        if(image.key !== step[1]) {
                            image.loadTexture(step[1]);
                        }
                    } else {
                        if(image.key !== data.image) {
                            image.loadTexture(data.image);
                        }
                        num = step.toString();
                    }
                } else {
                    if(image.key !== data.image) {
                        image.loadTexture(data.image);
                    }
                    num = String((x % count) + 1);
                }
                
                
                image.frameName = this._getFrameTo(frameName, num);
                
                if(!loop && ((x + 1) > count)) {
                    tween.pause();
                    if(cb && cb instanceof Function) {
                        cb();
                    }
                    return true;
                }
                
            }, step));
            
            return tween;
        }
    }
    
    _createCounter(cb, x = 0) {
        return function(cb) {
            let counter = x;

            return () => {
                if(cb && cb(counter)){
                    counter = 0;
                } else {
                    counter++;
                }
            }
        }(cb);
    }
};;DP3.Body = class extends DP3.Sprite {
    constructor(settings) {
        const prop = settings || {};
        super(prop.game);
        
        this._game = prop.game || null;
        this._world = prop.world || null;
        
        this._body = null;
        this._fixtures = [];
        
        this._createBody(prop.data);
        this._createFixtures(prop.data ? prop.data.fixtures : undefined);
        //this._phDebug(prop.data ? prop.data.fixtures : undefined);
    }
    
    _phDebug(fixtures = []) {
        const gr = new Phaser.Graphics(this.game, 0, 0),
              scale = box2d.SCALE,
              fixt = Array.isArray(fixtures) ? fixtures : [fixtures];
        
        gr.beginFill(0x2dc100, 0.8);
        gr.lineStyle(2, 0xbc2600, 1);
        
        for(let i = 0, arr = fixt, l = arr.length; (i | 0) < l; i+=1) {
            const shape = arr[i].shape || {};
            if(shape.type == 1) {
                const points = shape.points;
                if(!points)continue;

                // draw a shape
                gr.moveTo(points[0].x * scale, points[0].y * scale);
                for(let j = 1, k = points.length; (j | 0) < k; j+=1) {
                    gr.lineTo(points[j].x * scale, points[j].y * scale);
                }
            } else {
                gr.drawCircle(0, 0, shape.r * scale * 2);
                
            }
            gr.endFill();
            
        }
        
        gr.beginFill(0xff0000, 1);
        gr.lineStyle(0);
        gr.drawCircle(0, 0, 10);
        gr.endFill();
        
        this._debug = gr;
        //gr.alpha = 0.5;
        //gr.scale.set(1/this._frontWrap.scale.x);
        this.addChild(gr);/**/
    }
    
    _createBody(data = {}) {
        if(!this._body) {
            const bodyDef = new box2d.b2BodyDef();
        
            bodyDef.position.x = (data.x || 0) / box2d.SCALE;
            bodyDef.position.y = (data.y || 0) / box2d.SCALE;
            bodyDef.angle = (data.rotation || 0) / 180 * Math.PI;

            this._body = this._world.CreateBody(bodyDef);
        }
    }
    
    _createFixtures(data = []) {
        if(!this._body)return;
        if(Array.isArray(data)) {
            for(let i = 0, l = data.length; (i | 0) < l; i+=1) {
                this._fixtures.push(this._body.CreateFixture(this._createFixture(data[i])));
            }
        } else {
            this._fixtures.push(this._body.CreateFixture(this._createFixture(data)));
        }
        
    }
    
    _createFixture(data = {}) {
        const fixDef = new box2d.b2FixtureDef(),
              filter = data.filter || {};
        
        fixDef.density = data.density || 1;
        fixDef.friction = data.friction || 1;
        fixDef.restitution = data.restitution || 0.7;
        fixDef.shape = this._createShape(data.shape);
        
        fixDef.filter.categoryBits = filter.categoryBits;
        fixDef.filter.maskBits = filter.maskBits;
            
        return fixDef;
    }
    
    _createShape(data = {}) {
        if(data.type == 0) {
            
            const shapeC = new box2d.b2CircleShape(data.r);
            shapeC.SetLocalPosition(new box2d.b2Vec2(data.x,  data.y));
            return shapeC;
            
        } else {
            if(!data.points)return;
        
            const res = [],
                  shape = new box2d.b2PolygonShape();

            for(let i = 0, arr = data.points, l = arr.length; (i | 0) < l; i+=1) {
                res.push(new box2d.b2Vec2(arr[i].x, arr[i].y));
            }

            shape.SetAsVector(res, res.length);

            return shape;
        }
    }
    
    staticMode() {
        const body = this._body;
        body.SetType(box2d.b2Body.b2_staticBody);
        body.SetActive(true);
    }
    
    dynamicMode() {
        const body = this._body;
        body.SetType(box2d.b2Body.b2_dynamicBody);
        body.SetActive(true);
    }
    
    update() {
        if(this._body) {
            //console.log();
            let p = this._body.GetPosition();
        
            this.position.set(p.x * box2d.SCALE, p.y * box2d.SCALE);
            this.rotation = this._body.GetAngle();
        }
    }
    
    remove() {
        if(this.parent) {
            this.parent.removeChild(this);
        }
        
        if(this._body) {
            this._world.DestroyBody(this._body);
        }
    }
    
    get game() {
        return this._game;
    }
}
;DP3.SoundController = class {
    constructor(game) {
        this.game = game;
        this.core = this.game.sound;
        this._sounds = {};
        this._music = {};
        this.volume = {
            sound: 1,
            music: 1
        };
    }

    _checkSound(name) {
        return (this.getSound(name) && this.game.cache.checkSoundKey(name));
    }
    
    getSound(name) {
        if(!name)return;
        
        return this._sounds[name] || this._music[name];
    }
    
    stopAll() {
        if(this.core) {
            this.core.stopAll();
        }
    }
    
    pauseAll() {
        if(this.core) {
            this.core.pauseAll();
        }
    }
    
    resumeAll() {
        if(this.core) {
            this.core.resumeAll();
        }
    }
    
    _resetVolume(obj, volume = 1) {
        if(!obj)return;
        
        for(let key in obj) {
            if(obj[key])obj[key].volume = volume;
        }
    }
    
    setVolumeMusic(value) {
        this.volume.music = value;
        
        this._resetVolume(this._music, value);
    }
    
    setVolumeSound(value) {
        this.volume.sound = value;
        
        this._resetVolume(this._sounds, value);
    }
    
    addMusic(name) {
        if(!name || this._music.hasOwnProperty(name))return;
        
        this._music[name] = this.game.add.audio(name);
        this._music[name].volume = this.volume.music;
    }
    
    addSound(name) {
        if(!name || this._sounds.hasOwnProperty(name))return;
        
        this._sounds[name] = this.game.add.audio(name);
        this._sounds[name].volume = this.volume.sound;
        this._sounds[name].allowMultiple = true;
    }
    
    decodeAll(cb) {
        const res = [];
        
        for(let key in this._sounds) {
            res.push(this._sounds[key]);
        }
        
        this.core.setDecodedCallback(res, cb, this);
    }
    
    play(name, loop = false, cb, volume = 1) {
        if(name instanceof Array) {
            let i = 0;
            const arr = name,
                  l = arr.length,
                  step = () => {
                      if(!loop && i >= l)return;
                      this.play(arr[i % l], false, step);
                      i+=1;
                  };
            step();
        } else {
            const audio = this.getSound(name);
            
            if(audio) {
                audio.volume = this.volume[this._sounds.hasOwnProperty(name) ? "sound" : "music"] * volume;
                
                if(cb) {
                    audio.onStop.addOnce(cb, this);
                }

                audio.loop = loop;
                audio.play();
            } else {
                console.log("Not found audio: " + name);
            }
        }
    }
    
    crutchIOC13() {
        this.play("crutchIOC13", true, null, 0);

    }
};
;DP3.CarSprite = class extends DP3.Sprite {
    constructor(prop = {}) {
        super(prop.game);
        this.game = prop.game;
        this._core = prop.core;
        this.sound = prop.sound;
        
        this.callbacks = prop.callbacks || {};
        
        //correct data
        this._correctData = prop.correctData || {};
        
        this._type = prop.type || 2;//1 - frieds, 2 - enemies
        this._player = prop.player;
        this._convoy = prop.convoy;
        
        //shock
        this._shock = {
            ready: true,
            time: 8,
            d_time: 0,
            fall: false,
            fallTime: 4.5,
            d_f_time: 0
        };
        
        if(!this.data) this.data = {};
        this.data.x = prop.x || 0;
        this.data.y = prop.y || 0;
        this.data.way = prop.way || false;//false = <-  ;  true = ->
        
        this._className = prop.class || "Car_PC_7";
        
        if(prop.shop) {
            this._shopData = prop.shop;
        }
        
        this._init(prop.car);
        this._spriteCTRL(prop.rotation);
    }
    
    setData(prop) {
        this.data.x = prop.x || 0;
        this.data.y = prop.y || 0;
        this.data.way = prop.way || false;
        
        this.setPosData(this.data.x, this.data.y, prop.rotation);
        this._tuning();
    }
    
    getShopData() {
        return this._shopData;
    }
    
    getClassName() {
        return this._className;
    }
    
    getWay() {
        return this.data.way;
    }
    
    shockIsReady() {
        return this._shock.ready;
    }
    
    isFallInShock() {
        return this._shock.fall;
    }
    
    useShock() {
        if(this.shockIsReady()) {
            this._shock.ready = false;
            this._shock.d_time = this._shock.time;
            this._useShockAnim();
        }
    }
    
    _useShockAnim() {
        if(this._onShockerAnim) {
            this._onShockerAnim.resume();
            this._onShockerAnim.start();
        }
    }
    
    fallInShock() {
        if(!this._shock.fall) {
            this._shock.fall = true;
            this._shock.d_f_time = this._shock.fallTime;
            this._addShockEffect();
        }
    }
    
    _addShockEffect() {
        this._fillAll(0x3b35c7);
        this.sound.play("electricity_sn");
    }
    
    _fillAll(color = 0xffffff) {
        //shields
        for(let i = 0, arr = this._shields, l = arr.length; (i | 0) < l; i+=1) {
            arr[i].tint = color;
        }
        
        //launcher
        if(this._launcher)this._launcher.tint = color;
        
        //turrets
        for(let i = 0, arr = this._turrets, l = arr.length; (i | 0) < l; i+=1) {
            arr[i].fillAll(color);
        }
        
        //back
        this._back.tint = color;
        
        //motor
        if(this._motor)this._motor.tint = color;
        
        //tank
        if(this._tank)this._tank.tint = color;
        
        //wheels
        if(this._wheels) {
            for(let i = 0, arr = this._wheels, l = arr.length; (i | 0) < l; i+=1) {
                arr[i].tint = color;
            }
        }
    }
    
    _shockUpdate(dt) {
        if(!this._shock.ready) {
            this._shock.d_time-=dt;
            if(this._shock.d_time <= 0) {
                this._shock.ready = true;
                if(this._shocker)this._shocker.visible = true;
            }
        }
        
        if(this._shock.fall) {
            this._shock.d_f_time-=dt;
            if(this._shock.d_f_time <= 0) {
                this._shock.fall = false;
                this._removeShockEffect();
            } else {
                this._drawShock();
            }
        }
    }
    
    _drawShock(stat = true) {
        if(!this._shockGr) {
            this._shockGr = new Phaser.Graphics(this.game, 0, 0);
            this._frontWrap.addChild(this._shockGr);
        }
        
        const gr = this._shockGr;
        gr.clear();
        
        if(stat && Math.random() > 0.5) {
            for(let j = 0, k = Math.round(Math.random() * 1 + 1); (j | 0) < k; j+=1) {
                const p = {x: Math.random() * 100 - 50, y: Math.random() * 70 - 55},
                      reRand = function(p) {
                          p.x+=Math.random() * 60 - 30;
                          p.y+=Math.random() * 30 - 15;
                          return p;
                      };

                gr.moveTo(p.x, p.y);

                gr.lineStyle(2 + Math.round(Math.random() * 2), 0x3a76ff, 0.7 + Math.random() * 0.3);

                for(let i = 0, l = Math.random() * 10 + 20; (i | 0) < l; i+=1) {
                    reRand(p);
                    gr.lineTo(p.x, p.y);
                }
            }
        }
    }
    
    _removeShockEffect() {
        this._fillAll();
        this._drawShock(false);
    }
    
    _init(car) {
        this._animations = [];
        this._turrets = [];
        
        this._shields = [];
        
        this._live = true;
        
        this._nameCar = car || "";
        this._dataCar = this.game.cache.getJSON("cars")[car];
        
        this._config = this.game.cache.getJSON("config");
        this.__dataCars = this.game.cache.getJSON("dataCars");
        
        const data = this.__dataCars[this._className];
        
        this._price = data.price;
        //create rect
        const rect = data["rect"];
        this._rect = new Phaser.Rectangle(rect.x, rect.y, rect.width * 0.5, rect.height * 0.5);
        
        this.maxHealth = this._correctData.health || 100;
    }
    
    getScraps() {
        if(!this._correctData)return null;
        return this._correctData.scraps;
    }
    
    getPrice() {
        return this._price;
    }
    
    getRect() {
        return this._rect;
    }
    
    getMainScale() {
        return this._backWrap.scale;
    }
    
    _tuning() {
        const data = this._dataCar["properties"],
              way = this.getWay() ? 1 : -1,
              scale = data["scale"] || 1;
        
        this._backWrap.scale.set(scale * way, scale);
        this._frontWrap.scale.set(scale * way, scale);
    }
    
    _createHealthBar() {
        const wrap = new Phaser.Image(this.game),
              elem = new DP3.HealthBar({game: this.game});
        elem.scale.set(0.5);
        elem.position.set(0, -(this._player ? 80 : 55));
        wrap.addChild(elem);
        
        this._healthBar = elem;
        
        this.setMaxHealth();
        
        return wrap
    }
    
    _createShocker() {
        const data = this._dataCar["elements"]["shocker"];
        
        if(data) {
            const obj = data;
            
            this._frontWrap.addChild(this._shocker = this._createElement(obj));
            
            if(obj["animations"]) {
                const anims = obj["animations"];
                
                this._createFrameAnim(this._shocker, anims["ready"]["name"], true, anims["ready"]["loop"]);
                this._onShockerAnim = this._createFrameAnim(this._shocker, anims["active"]["name"], false, false, obj.hide ? () => {this._shocker.visible = false;} : null);
            }
        }
    }
    
    _drawPoint(x = 0, y = 0, color = 0xff0000, r = 10) {
        const gr = new Phaser.Graphics(this.game, x, y);
        
        gr.beginFill(color);
        gr.drawCircle(0, 0, r);
        gr.endFill();
        
        return gr;
    }
    
    _drawLine(x = 0, y = 0, color = 0xff0000, L = 0, l = 50) {
        const gr = new Phaser.Graphics(this.game, x, y);
        
        gr.lineStyle(3, color, 1);
        gr.moveTo(0, 0);
        gr.lineTo(Math.cos(L) * l, Math.sin(L) * l);
        
        console.log(Math.cos(L) * l, Math.sin(L) * l);
        gr.endFill();
        console.log(gr);
        
        return gr;
    }
    
    _createLauncher() {
        const data = this._dataCar["elements"]["launcher"];
        
        if(data) {
            const obj = data instanceof Array ? data[this._player ? (this.getShopData()["rocket launcher"][1] - 1) : 0] : data;
            
            this._frontWrap.addChild(this._launcher = this._createElement(obj));
            
            this._launcher.shots = obj.shots || 1;
            this._launcher.bulletsPositions = obj.bulletsPositions;
            this._launcher.bulletsAngles = obj.bulletsAngles;
            this._launcher.bulletsDelay = obj.bulletsDelay;
            
            if(obj.hide)this._launcher.visible = false;
            
            this._launcher.bullet = obj.bullet;
            
            //this._test(obj);
            
            if(obj["animationDef"]) {
                this._onLauncherFire = this._createFrameAnim(this._launcher, obj["animationDef"]["name"], true, obj["animationDef"]["loop"], obj.hide ? () => {this._launcher.visible = false;} : null);
            }
            
            if(obj["animation"]) {
                this._onLauncherFire = this._createFrameAnim(this._launcher, obj["animation"]["name"], false, obj["animation"]["loop"], obj.hide ? () => {this._launcher.visible = false;} : null);
            }
        }
    }
    
    _test(obj) {
        //test
        
        const x0 = obj.position[0] / 2,
              y0 = obj.position[1] / 2;
            
        console.log(obj);
        
        //main point
        this._frontWrap.addChild(this._drawPoint(x0, y0));

        //points
        if(obj.bulletsPositions) {
            for(let i = 0, arr = obj.bulletsPositions, l = arr.length; (i | 0) < l; i+=1) {
                this._frontWrap.addChild(this._drawPoint(x0 + arr[i][0], y0 + arr[i][1], 0x00ff62));
                
                if(obj.bulletsAngles) {
                    this._frontWrap.addChild(this._drawLine(x0 + arr[i][0], y0 + arr[i][1], 0x00ff62, obj.bulletsAngles[i]));
                }
            }
        }
    }
    
    _createMotor() {
        const data = this._dataCar["elements"]["motor"];
        
        if(data) {
            const obj = data instanceof Array ? data[this._player ? (this.getShopData()["motor"][1] - 1) : 0] : data;
            
            this._backWrap.addChild(this._motor = this._createElement(obj));
            
            if(obj["animation"]) {
                this._createFrameAnim(this._motor, obj["animation"]["name"], true, obj["animation"]["loop"]);
            }
        }
    }
    
    _createTank() {
        const data = this._dataCar["elements"]["tank"];
        
        if(data) {
            const obj = data instanceof Array ? data[this._player ? (this.getShopData()["fuel tank"][1] - 1) : 0] : data;
            
            this._backWrap.addChild(this._tank = this._createElement(obj));
        }
    }
    
    addHealth(value) {
        this.heal(value);
    }
    
    _spriteCTRL(rotation = 0) {
        const data = this._dataCar["elements"],
              translation = this._dataCar["properties"]["pos"],
              posScale = this._dataCar["properties"]["posScale"];
        
        if(translation) {
            this._translation = translation;
        }
        
        if(posScale) {
            this._posScale = posScale;
        }
        
        this._mainWrap = this.getWrap();
        this._backWrap = this.getWrap();
        this._frontWrap = this.getWrap();
        
        this.addChild(this._mainWrap);
        
        //Add back wrap
        this._mainWrap.addChild(this._backWrap);
        
        //Back
        if(data["back"]) {
            this._backWrap.addChild(this._back = this._createElement(data["back"]));
        }
        
        //Tank
        this._createTank();
        
        //Motor
        this._createMotor();
        
        //Wheels
        if(data["wheels"]) {
            this._mainWrap.addChild(this._wheelsWrap = this.getWrap());
        }
        
        //Add front wrap
        this._mainWrap.addChild(this._frontWrap);
        
        //Shield
        if(data["shield"]) {
            this._frontWrap.addChild(this._shield = this._player ? this._createHeroShield(data["shield"]) : this._createShield(data["shield"]));
        }
        
        //Decor
        if(data["decor"]) {
            for(let i = 0, arr = data["decor"], l = arr.length; (i | 0) < l; i+=1) {
                const elem = this._createElement(arr[i]);
                
                if(arr[i].front) {
                    this._frontWrap.addChild(elem);
                } else {
                    this._backWrap.addChild(elem);
                }
                
                if(arr[i]["animation"]) {
                    this._createFrameAnim(elem, arr[i]["animation"]["name"], true, arr[i]["animation"]["loop"]);
                }
                
                if(arr[i].rotate) {
                    console.log("tut");
                    this.game.add.tween(elem).to({rotation: Math.PI * 2}, 1000 / arr[i].rotate, "Linear", true).loop(true);
                }
            }
        }
        
        //Turrets
        this._createTurrets();
        
        //Launcher
        this._createLauncher();
        
        //Shocker
        this._createShocker();
        
        this._mainWrap.addChild(this._infoWrap = this._createHealthBar());
        
        this.setPosData(this.data.x, this.data.y, rotation);
        
        this._tuning();
        
        this._generMainImage();
    }
    
    _aimAI(self) {
        const L = this._absAngle(this.game.math.angleBetweenPoints(this.getPosition(), self.hero.getPosition()));
        
        if(L < (Math.PI / 2) || L > Math.PI * 3 / 2) {
            this.rotateTower("right");
        } else {
            this.rotateTower("left");
        }
    }
    
    _createTurrets() {
        const data = this._dataCar["elements"];
        if(!data["turrets"])return;
        
        const turretsData = data["turrets"][0] instanceof Array ? data["turrets"][this._player ? (this.getShopData()["guns"][1] - 1) : 0] : data["turrets"];
        
        for(let i = 0, arr = turretsData, l = arr.length; (i | 0) < l; i+=1) {
            this._createTurret(arr[i]);
        }
    }
    
    _createTurret(data) {
        if(!data)return;
        
        const turret = new DP3.Turret({game: this.game, data: data, car: this});
        
        if(this._posScale) {
            turret.position.x*=this._posScale;
            turret.position.y*=this._posScale;
        }
        
        if(this._translation) {
            turret.position.x+=this._translation[0];
            turret.position.y+=this._translation[1];
        }
        
        if(data.front) {
            this._frontWrap.addChild(turret);
        } else {
            this._frontWrap.addChildAt(turret, 0);
        }
        
        this._turrets.push(turret);

        if(this.getWay()) {
            this.rotateTower("right");
        } else {
            this.rotateTower("left");
        }
    }
    
    rotateTower(side = "right") {
        if(!this._turrets)return;
        
        const way = this.getWay() ? 1 : -1;
        
        for(let i = 0, arr = this._turrets, l = arr.length; (i | 0) < l; i+=1) {
            arr[i].setDirection((side === "left" ? -1 : 1) * way, side);
        }
    }
    
    _createShield(data) {
        if(!data)return;
        
        const wrap = this.getWrap();
        
        for(let i = 0, j = data.length; (i | 0) < j; i+=1) {
            const shield = this._createElement(data[i][0]);
            this._shields.push(shield);
            wrap.addChild(shield);
        }
        
        return wrap;
    }
    
    _createHeroShield(data) {
        if(!data)return;
        
        const wrap = this.getWrap(),
              shop = this.getShopData(),
              anchor = shop ? shop["shield"][1] : 0;
        
        for(let i = 0, j = data.length; (i | 0) < j; i+=1) {
            const shield = this._createElement(data[i][(anchor > i) ? 1 : 0]);
            this._shields.push(shield);
            wrap.addChild(shield);
        }
        
        return wrap
    }
    
    clear() {
        
    }
    
    launcherFire() {
        this._launcher.visible = true;
        
        if(this._onLauncherFire) {
            this._onLauncherFire.resume();
            this._onLauncherFire.start();
        }
        
        this.launcherSound();
    }
    
    launcherSound() {
        if(this.sound) {
            this.sound.play("Rocket_sn");
        }
    }
    
    _generMainImage() {
        const data = this._dataCar.elements,
              getImage = function(obj, func) {
                  if(!obj)return null;
                  
                  if(obj instanceof Array) {
                      if(!func)return null;
                      let res = null;
                      for(let i = 0, arr = obj, l = arr.length; (i | 0) < l; i+=1) {
                          res = func(arr[i], func);
                          if(res) {
                              return res;
                          }
                      }
                  } else if(obj.image) {
                      return obj.image;
                  }
                  
                  return null;
              };
        
        let res = null;
        
        for(let key in data) {
            res = getImage(data[key], getImage);
            if(res) {
                this._mainImage = res;
                return;
            }
        }
    }
    
    getMainImage() {
        return this._mainImage;
    }
    
    getPosition() {
        return this._frontWrap.position;
    }
    
    getRotation() {
        return this._frontWrap.rotation;
    }
    
    remove() {
        if(this.parent) {
            this.parent.removeChild(this);
            
            this._live = false;
            
            if(this.callbacks.remove) {
                this.callbacks.remove();
            }
        }
    }
    
    _updateTurrets(self, dt) {
        if(this.isFallInShock())return;
        for(let i = 0, arr = this._turrets, l = arr.length; (i | 0) < l; i+=1) {
            arr[i].update(self, dt);
        }
    }
    
    getMainTarget() {
        if(this._turrets[0])return this._turrets[0].getTarget();
    }
    
    _rectUpdate() {
        const pos = this.getPosition();
        this._rect.centerOn(pos.x, pos.y);
        //console.log(this._rect);
    }
    
    update(self, dt, start = false) {
        this._rectUpdate();
        
        if(this.visible && start) {
            this._healthBar.setPercent(this.health / this.maxHealth);
            this._shieldUpdate();
            this._shockUpdate(dt);
            this._updateTurrets(self, dt);
        }
    }
    
    setPosData(x, y, L = 0) {
        const elem1 = this._backWrap,
              elem2 = this._frontWrap,
              elem3 = this._infoWrap;
        
        elem1.position.set(x, y);
        elem2.position.set(x, y);
        elem3.position.set(x, y);
        elem2.rotation = elem1.rotation = L;
    }
    
    setMaxHealth() {
        this.setHealth(this.maxHealth);
    }
    
    _shieldUpdate() {
        const x = "_00" + this._extremum(Math.ceil((1 - this.health / this.maxHealth) * 3), 1, 3); 
        for(let i = 0, arr = this._shields, l = arr.length; (i | 0) < l; i+=1) {
            const elem = arr[i],
                  name = elem.frameName;
            
            if(name.indexOf(x) === -1) {
                elem.frameName = name.split("_00")[0] + x + ".png";
            }
        }
    }
    
    refresh() {
        this.setMaxHealth();
        this.visible = true;
        this._live = true;
    }
    
    kill(x) {
        //super.kill();
        this.visibleScaps = this.visible;
        
        this.visible = false;
        
        const x1 = this.remove(x);
        
        this._live = false;
        
        if(this.callbacks.kill) {
            this.callbacks.kill();
        }
        
        return x1;
    }
};;DP3.CarPhysics = class extends DP3.CarSprite {
    constructor(prop = {}) {
        super(prop);
        
        this._world = prop.world || null;
        
        if(!this.data) this.data = {};
        
        
        this.dataPosition = {
            t: 0,
            x: 0,
            y: 0,
            ds: 0.05,
            wait: 3000,
            finish: prop.finish || 50,
            finished: false,
            motor: false
        };
        
        this._touch = false;
        
        this._angularSpeed = 0;
        
        this._physicsCTRL();
        
        this._initAI();
    }
    
    setData(prop) {
        this.data.x = prop.x || 0;
        this.data.y = prop.y || 0;
        this.data.way = prop.way || false;
        
        this.setPosData(this.data.x, this.data.y);
        
        this._shock.ready = true;
        
        if(this._shocker)this._shocker.visible = true;
        
        this._showBody(this.data.x, this.data.y);
        
        /*this._physicsCTRL();
        this._tuning();*/
    }
    
    _init(car) {
        super._init(car);
        
        this._vec = new Phaser.Point(0, 0);
        
        this._wheels = [];
    }
    
    _initAI() {
        this._AI = this._getAiFor(this._className);
    }
    
    _getAiFor(cn) {
        switch(cn) {
            case "Car_FOE_humvy_shooter_3lp":
            case "Car_FOE_humvy_shooter":
            case "Car_Alligator":
            case "Car_FOE_Duna":
            case "Car_FOE_hodRod_3lp":
            case "Car_FOE_hodRod":
            case "Car_FOE_lightCar_3lp":
            case "Car_FOE_lightCar":
            case "Car_NPC_3lp":
            case "Car_NPC":
            case "Car_foe91_nomad":
                return new DP3.ai_car_1();
            case "Car_FOE_snowBike2_3lp":
            case "Car_FOE_snowBike2":
                return new DP3.ai_car_1({}, [3]);
            case "Car_FOE_Bike_3lp":
            case "Car_FOE_Bike":
            case "Car_FOE_podBike_3lp":
            case "Car_FOE_podBike":
                return new DP3.ai_car_2();
            case "Car_BOSS_COT":
                return new DP3.ai_car_3({}, [100, 25, 80, 50, 300]);
            case "Car_BOSS_Secator":
                return new DP3.ai_car_3({}, [80, 30, 60, 20, 300]);
            case "Car_FOE_cougar_3lp":
            case "Car_FOE_cougar":
            case "Car_FOE_monsterTruck_3lp":
            case "Car_FOE_monsterTruck":
            case "Car_Foe_MT_mt_3lp":
            case "Car_Foe_MT":
            case "Car_FOE_pickUp_3lp":
            case "Car_FOE_pickUp":
                return new DP3.ai_car_3({}, [100, 200, 80, 50, 100]);
            case "Car_FOE_muscle_3lp":
            case "Car_FOE_muscle":
                return new DP3.ai_car_3({}, [100, 200, 80, 50, 100, 50]);
            case "Car_FOE_Shocker_3lp":
            case "Car_FOE_Shocker":
                return new DP3.ai_car_3({}, [100, 200, 80, 50, 250, 50]);
            case "Car_FOE_heavyTruck_3lp":
            case "Car_FOE_heavyTruck":
            case "Car_FOE_RV_3lp":
            case "Car_FOE_RV":
            case "Car_FOE_tanker_3lp":
            case "Car_FOE_tanker":
                return new DP3.ai_car_3({}, [100, 200, 80, 50, 250]);
            case "Car_FOE_quadBike_3lp":
            case "Car_FOE_quadBike":
                return new DP3.ai_car_4();
            case "Car_BOSS_Tank":
            case "Car_BOSS_Tank_3lp":
                return new DP3.ai_car_3({}, [350, 130, 200]);
            case "Car_FOE_snowBike1_3lp":
            case "Car_FOE_snowBike1":
                return new DP3.ai_car_3({}, [250, 10, 69]);
            case "Car_FOE_jailCar_tier4_3lp":
            case "Car_FOE_jailCar_tier5_3lp":
            case "Car_FOE_jailCar_tier6_3lp":
            case "Car_FOE_jailCar_tier7_3lp":
                return new DP3.ai_jailCar();
            default:
                if(DP3["ai_" + cn]) {
                    return new DP3["ai_" + cn]();
                }
                break;
        }
        return null;
    }
    
    _physicsCTRL() {
        const data = this._dataCar["body"];
        
        this._body = this._createBody();
        
        if(this._className === "Car_FOE_Shocker_3lp" || this._className === "Car_FOE_Shocker") {
            this._body.SetUserData({
                type: 5,//Type 5 - shockCar 
                self: this
            });
        }
        
        if(this._correctData.fixtures) {
            for(let i = 0, arr = this._correctData.fixtures, l = arr.length; (i | 0) < l; i+=1) {
                const elem = arr[i],
                      fixture = this._createFixture(arr[i].shape.points, arr[i]);
                if(fixture) {
                    this._body.CreateFixture(fixture);
                }
            }
        } else {
            for(let i = 0, arr = data["figures"], l = arr.length; (i | 0) < l; i+=1) {
                this._body.CreateFixture(this._createFixture(arr[i].points));
            }
        }
        
        if(this._correctData.massData) {
            this._body.SetMassData({mass: this._correctData.massData.mass, I: this._correctData.massData.I, center: {x: 0, y: 0}});
        }
        
        this._createPhysicsWheels();
        
        //this._body.SetAngularDamping(5);
        
        //this.shift();
        
        //this.hitBoxDebug();
        //this.phDebug();
    }
    
    hit() {
        this._touch = true;
    }
    
    hitBoxDebug() {
        const gr = new Phaser.Graphics(this.game, 0, 0),
              scale = box2d.SCALE,
              rect = this._correctData.rect;
        
        gr.beginFill(0x2dc100, 0.8);
        gr.lineStyle(2, 0xbc2600, 1);

        // draw a shape
        gr.moveTo(rect.x, rect.y);
        gr.lineTo(rect.x + rect.width, rect.y);
        gr.lineTo(rect.x + rect.width, rect.y + rect.height);
        gr.lineTo(rect.x, rect.y + rect.height);
        gr.endFill();
        
        this._debug = gr;
        gr.alpha = 0.5;
        //gr.scale.set(1/this._frontWrap.scale.x);
        this._frontWrap.addChild(gr);
    }
    
    phDebug() {
        const gr = new Phaser.Graphics(this.game, 0, 0);
        for(let i = 0, arr = this._correctData.fixtures, l = arr.length; (i | 0) < l; i+=1) {
            const points = arr[i].shape.points,
                  scale = box2d.SCALE;
            if(!points)continue;
            gr.beginFill(0x2dc100, 0.8);
            gr.lineStyle(2, 0xbc2600, 1);

            // draw a shape
            gr.moveTo(points[0].x * scale, points[0].y * scale);
            for(let j = 1, k = points.length; (j | 0) < k; j+=1) {
                gr.lineTo(points[j].x * scale, points[j].y * scale);
            }
            gr.endFill();
        }
        
        this._debug = gr;
        gr.alpha = 0.5;
        gr.scale.set(1/this._frontWrap.scale.x);
        this._frontWrap.addChild(gr);
    }
    
    _createPhysicsWheels() {
        if(this._dataCar["elements"]["wheels"] && this._dataCar["body"]["wheels"]) {

            const wrap = this._wheelsWrap || this.getWrap(),
                  f = box2d.SCALE,
                  way = this.getWay() ? 1 : -1,
                  pos = this._body.GetPosition(),
                  dtEL = this._dataCar["elements"]["wheels"],
                  dataP = this._correctData["wheels"],
                  data = dtEL[0] instanceof Array ? dtEL[this._player ? (this.getShopData()["wheels"][1] - 1) : 0] : dtEL,
                  wheelsData = this._correctData.wheels,
                  p0 = this._body.GetPosition();
            
            let front = null;

            for(let i = data.length - 1, l = -1; (i | 0) > l; i-=1) {
                const cwd = wheelsData[i] || {},// correct wheel data
                      filter = cwd.filter || {},
                      //wheel = this.getWheel({, }, cwd),
                      wheel = new DP3.Wheel({
                          game: this.game, 
                          world: this._world,
                          spriteRadius: data[i].radius || 10,
                          image: data[i].image, 
                          frame: data[i].frame,
                          speed: cwd.speed,
                          twist: !data[i].untwist,
                          anim: data[i].anim,
                          data: {
                              x: cwd.x * f * way,
                              y: cwd.y * f,
                              fixtures: cwd
                          }
                      }),
                      r_def = new box2d.b2RevoluteJointDef(),
                      body = wheel._body;
                
                let dump = null;
                
                body.m_fixtureList.m_filter.categoryBits = filter.categoryBits;
                body.m_fixtureList.m_filter.maskBits = filter.maskBits;
                
                body.SetPosition(new box2d.b2Vec2(p0.x + cwd.x / box2d.SCALE * way, p0.y + cwd.y / box2d.SCALE));
                
                if(cwd.translation) {
                    let dump_a = this.getRotation() - Math.PI / 2,
                        l = Math.cos(dump_a),
                        shape = new box2d.b2CircleShape(0.1),
                        fix = new box2d.b2FixtureDef(),
                        def = new box2d.b2BodyDef(),
                        p_def = new box2d.b2PrismaticJointDef(),
                        axis = new box2d.b2Vec2(Math.cos(dump_a), -Math.sin(dump_a));
                    
					fix.shape = shape;
					fix.density = 10;
                    fix.filter.categoryBits = filter.categoryBits;
                    fix.filter.maskBits = 0;
					fix.isSensor = true;
					def.position = body.GetWorldCenter();
					def.type = box2d.b2Body.b2_dynamicBody;
					dump = this._world.CreateBody(def);
					dump.CreateFixture(fix);
					p_def.Initialize(this._body, dump, body.GetWorldCenter(), axis);
					p_def.collideConnected = false;
					p_def.enableLimit = true;
					p_def.enableMotor = true;
					p_def.lowerTranslation = 0;
					p_def.upperTranslation = cwd.translation * 0.01;
				
					this._world.CreateJoint(p_def);
                    
                    wheel._dump = dump;
				}
				
				r_def.enableMotor = true;
				r_def.Initialize(dump ? dump : this._body, body, body.GetWorldCenter());
                this._world.CreateJoint(r_def)
                
                /*const cwd = wheelsData[i] || {},// correct wheel data
                      filter = cwd.filter || {},
                      //wheel = this.getWheel({, }, cwd),
                      wheel = new DP3.Wheel({
                          game: this.game, 
                          world: this._world,
                          spriteRadius: data[i].radius || 10,
                          image: data[i].image, 
                          frame: data[i].frame,
                          speed: cwd.speed,
                          data: {
                              x: cwd.x * f * way,
                              y: cwd.y * f,
                              fixtures: cwd
                          }
                      }),
                      jointDef = new box2d.b2LineJointDef(),
                      body = wheel._body;
                
                body.m_fixtureList.m_filter.categoryBits = filter.categoryBits;
                body.m_fixtureList.m_filter.maskBits = filter.maskBits;
                
                body.SetPosition(this._body.GetPosition());

                jointDef.bodyA = this._body;
                jointDef.bodyB = body;
                jointDef.collideConnected = false;

                //line
                jointDef.localAxisA.Set(0, 1);
                jointDef.enableLimit = true;
                jointDef.lowerTranslation = 0.2;
                jointDef.upperTranslation = 0.35;
                jointDef.maxMotorForce = 10000;
                //jointDef.motorSpeed = 100;
                //

                jointDef.localAnchorA.Set((cwd.x / box2d.SCALE * way) || dataP[i].pos[0], (cwd.y / box2d.SCALE) || dataP[i].pos[1]);

                this._world.CreateJoint(jointDef);*/
                
                
                if(data[i].front) {
                    if(!front) {
                       front = this.getWrap();
                       this._mainWrap.addChild(front);
                    }
                    front.addChild(wheel);
                    
                } else {
                    wrap.addChild(wheel);
                }
                
                this._wheels.push(wheel);
            }

            return wrap;
        }
        
        return this.getWrap();
    }
    
    wheelContact() {
        this._angle = 0;
        this._acrobat = 0;
    }
    
    _createBody() {
        const bodyDef = new box2d.b2BodyDef();
        bodyDef.type = box2d.b2Body.b2_dynamicBody;
        bodyDef.position.x = this.data.x / box2d.SCALE;
        bodyDef.position.y =  this.data.y / box2d.SCALE;
        bodyDef.angle =  this.getRotation();
        
        return this._world.CreateBody(bodyDef);
    }
    
    _createFixture(points, fixture = {}) {
        if(!points)return;
        
        const fixDef = new box2d.b2FixtureDef(),
              res = [],
              filter = fixture.filter || {};
        
        for(let i = 0, arr = points, l = arr.length; (i | 0) < l; i+=1) {
            res.push(new box2d.b2Vec2(arr[i].x, arr[i].y));
        }
        
        fixDef.density = fixture.density || 20;
        fixDef.friction = fixture.friction || 1;
        fixDef.restitution = fixture.restitution || 0.1;
        
        fixDef.filter.categoryBits = filter.categoryBits;
        fixDef.filter.maskBits = filter.maskBits;
        
        fixDef.shape = new box2d.b2PolygonShape();
        fixDef.shape.SetAsVector(res, res.length);
        
        return fixDef;
    }
    
    motor(type, f = 1) {
        //return;
        const factor = ({"left": -1, "right": 1, "stop": 0})[type] || 0;
        
        if(this._shock.fall)f = 0;
        
        this._body.SetAwake(true);
        for(let i = 0, arr = this._wheels, l = arr.length; (i | 0) < l; i+=1) {
            arr[i].motor(factor * f);
        }
    }
    
    updateDumps() {
        /*var tension:Number;
			var i:int = _wheels.length;
			while (--i > -1)
			{
				if(_wheels[i].GetDump()){
					tension = _wheels[i].GetDumpTension();
					_wheels[i].GetDumpJoint().SetMotorSpeed(-tension * 2 * _wheels[i].GetDumpJoint().GetJointTranslation());
					_wheels[i].GetDumpJoint().SetMaxMotorForce(tension * 12 + Math.abs(tension * 320 * Math.pow(_wheels[i].GetDumpJoint().GetJointTranslation(), 2)));
				}
			}*/
    }
    
    shift() {
        
        if(this._body) {
            const body = this._body,
                  p = body.GetPosition(),
                  wheels = this._wheels,
                  s = box2d.SCALE,
                  x = p.x,
                  y = p.y;
            
            p.y-=100 / s;
            body.SetAwake(true);
            body.SetPositionAndAngle(p, 0);
            
            for(let i = 0, arr = wheels, l = arr.length; (i | 0) < l; i+=1) {
                const elem = arr[i],
                      dump = elem.getDump();
				if(dump) {
                    dump.SetPosition(new Phaser.Point(p.x + (x - dump.GetPosition().x), p.y + (y - dump.GetPosition().y)));
                }
                elem._body.SetPosition(new Phaser.Point(p.x + (x - elem._body.GetPosition().x), p.y + (y - elem._body.GetPosition().y)));
            }
            
            body.ApplyImpulse(new box2d.b2Vec2(100, 10), body.GetWorldCenter());
            
            this._stoping = 100;
        }
    }
    
    balance(type) {
        if(!this._body) return;
        
        //qwerty
        
        const power = 0.09,
              zero = this._body.GetAngularVelocity();
        
        this._body.SetAwake(true);
        
        if(type === "down") {
            this._body.SetAngularVelocity(zero + power);
            //this._body.ApplyTorque(zero + power);
        } else {
            this._body.SetAngularVelocity(zero - power);
            //this._body.ApplyTorque(zero - power);
        }
    }
    
    _checkContacts(data) {
        if(data) {
            const ud = data.other.GetUserData();
            
            if(ud && ud.self) {
                switch(Number(ud.type)) {
                    case 3: ud.self.damage(200);
                        break;
                    default:
                        if(this._type === 1 && ud.type === 5 && ud.self.shockIsReady()) {
                            ud.self.useShock();
                            this.fallInShock();
                        }
                        break;
                };
            }
            
            this._checkContacts(data.next);
        }
    }
    
    _control(dt) {
        if(this._convoy && (!this.motorStatus || this._shock.fall))return;
        //if(this._className == "Car_FOE_jailCar_tier7_3lp" && (!this.motorStatus || this._shock.fall))return;
        
        const AI = this._AI,
              position = this.getPosition(),
              rotation = this.getRotation(),
              hero = this._core.hero,
              heroPos = hero.getPosition(),
              body = this._body,
              direction = heroPos.x - position.x > 0 ? 1 : -1;
        
        if(this._className == "Car_foe91_nomad") {
            if (body.GetAngle() > Math.PI / 3)
            {
                body.SetAngle(Math.PI / 3);
            }
            if (body.GetAngle() < -Math.PI / 3)
            {
                body.SetAngle(-Math.PI / 3);
            }
        }
        
        if(AI) {
            AI.update({ 
                "x": position.x,
                "y": position.y,
                "rotation": rotation,
                "px": heroPos.x,
                "py": heroPos.y,
                "pSpeed": hero._body.GetLinearVelocity().x / 20,
                "mission": 0,
                "touch": false
            }, dt);
            
            let speed = (this._type === 1) ? AI.speed : AI.getSpeed(),
                rotate = AI["rotate"];
            
            speed = speed > this._correctData.speed ? this._correctData.speed : speed;
            
            this.dataPosition.speed = speed;
            
            for(let i = 0, arr = this._wheels, l = arr.length; (i | 0) < l; i+=1) {
                arr[i].motor(speed * 0.9 * (this._core._getMoveFactor() || 1));
            }
            
            if(rotate != 0) {
                body.SetAngularVelocity(rotate);
            } else {
                
                //console.log(angV, body);
                

                let desired;

                if(direction > 0) {
                    desired = new Phaser.Point(Math.cos(-Math.PI / 6), Math.sin(-Math.PI / 6));
                } else {
                    desired = new Phaser.Point(Math.cos(Math.PI / 6), Math.sin(Math.PI / 6));
                }

                desired = new Phaser.Point(1, 0);

                desired.normalize();

                const vec = new Phaser.Point(Math.cos(body.GetAngle()), Math.sin(body.GetAngle())),
                      factor = (new Phaser.Point(desired.x - vec.x, desired.y - vec.y)).distance({x: 0, y: 0}) * 1 * this._shorterWay(vec, desired);

                //body.ApplyTorque(factor - torgue * 0.05);
                body.SetAngularVelocity(factor);
                //console.log(body.m_torque, factor - torgue);
            }
            
            return;
        }
    }
    
    _check(dt = 0.016) {
        if(!this._AI)return;
        const body = this._body,
              p = body.GetPosition(),
              dP = this.dataPosition,
              v = this._AI.speed;
        
        if(v > 2 && Math.sqrt(Math.pow(dP.x - p.x, 2) + Math.pow(dP.y - p.y, 2)) < dP.ds) {
            dP.t+=dt * 1000;
        } else {
            dP.t = 0;
        }
        
        if(dP.t >= dP.wait) {
            dP.t = 0;
            this.shift();
        }
        
        dP.x = p.x;
        dP.y = p.y;
    }
    
    __setPhPosition(x = 0, y = 0) {
        if(this._body) {
            const body = this._body,
                  wheels = this._wheels,
                  s = box2d.SCALE,
                  p = new box2d.b2Vec2(x / s, y / s);
            
            body.SetAwake(true);
            body.SetPositionAndAngle(p, 0);
            
            for(let i = 0, arr = wheels, l = arr.length; (i | 0) < l; i+=1) {
                const elem = arr[i],
                      dump = elem.getDump();
				if(dump) {
                    dump.SetPosition(p);
                }
                elem._body.SetPosition(p);
            }
        }
    }
    
    _showBody(x = 0, y = 0) {
        this.__setPhPosition(x, y);
        
        this.dynamicMode();
    }
    
    _hideBody(x = 0) {
        const p = this._body.GetPosition(),
              s = box2d.SCALE,
              x1 = Math.max(p.x * s, x + 500);
        
        this.__setPhPosition(x1, (p.y * s) + 1000);
        
        this.staticMode();
        
        return x1;
    }
    
    staticMode() {
        const body = this._body;
        body.SetType(box2d.b2Body.b2_staticBody);
        body.SetActive(true);
        
        for(let i = 0, arr = this._wheels, l = arr.length; (i | 0) < l; i+=1) {
            arr[i].staticMode();
        }
    }
    
    dynamicMode() {
        const body = this._body;
        body.SetType(box2d.b2Body.b2_dynamicBody);
        body.SetActive(true);
        
        for(let i = 0, arr = this._wheels, l = arr.length; (i | 0) < l; i+=1) {
            arr[i].dynamicMode();
        }
    }
    
    update(self, dt, start = false) {
        super.update(self, dt, start);
        
        if(this._body) {
            const p = this._body.GetPosition(),
                  body = this._body;
            
            this._vec.x = Math.cos(body.GetAngle());
			this._vec.y = Math.sin(body.GetAngle());
            
            this.setPosData(p.x * box2d.SCALE, p.y * box2d.SCALE, body.GetAngle());
            for(let i = 0, arr = this._wheels, l = arr.length; (i | 0) < l; i+=1) {
                arr[i].update();
            }
            this._checkContacts(this._body.GetContactList());
            
            if(start) {
                if(this._shock.fall) {
                    this.motor("stop");
                } else {
                    this._control(dt);
                }
            }
            
            this._touch = false;
        }
    }
    
    ////!!!!!!!!!!!!!!!!!!!!!!!!
    /*
    private function updateDumps():void
		{
			var tension:Number;
			var i:int = _wheels.length;
			while (--i > -1)
			{
				if(_wheels[i].GetDump()){
					tension = _wheels[i].GetDumpTension();
					_wheels[i].GetDumpJoint().SetMotorSpeed(-tension * 2 * _wheels[i].GetDumpJoint().GetJointTranslation());
					_wheels[i].GetDumpJoint().SetMaxMotorForce(tension * 12 + Math.abs(tension * 320 * Math.pow(_wheels[i].GetDumpJoint().GetJointTranslation(), 2)));
				}
			}
		}*/
    
    remove(x, y) {
        super.remove();
        
        if(!this._body) return;
        
        return this._hideBody(x, y);
    }
    
    destr() {
        super.remove();
        
        if(!this._body) return;
        
        this._world.DestroyBody(this._body);
        
        for(let i = 0, arr = this._wheels, l = arr.length; (i | 0) < l; i+=1) {
            arr[i].remove();
        }
        this._wheels.splice(0);
    }
};;DP3.AI = class {
    constructor (vrbls) {
        this._init();
        for(let n in vrbls) {
            this[n] = vrbls[n];
        }
    }
    
    _init() {
        this.speed = 0;
        this.maxSpeed = 0;
        this.rotate = 0;
    }
    
    update(vrbls, dt) {
        for (let n in vrbls) {
            this[n] = vrbls[n];
        }
    }
    
    getSpeed() {
        const dx = Math.abs((this.px + 50) - this.x),
              l = 400,
              l0 = 50;
        
        if(dx > l) {
            return this.speed
        } else if(dx < l0) {
            return 0;
        } else {
            return this.speed / (l - l0) * (dx - l0);
        }
    }
};;DP3.ai_car_1 = class extends DP3.AI {
    //arr = [drag]
    constructor (vrbls, arr = []) {
        super(vrbls);
        this._prop = arr;
        this.time = 0;
        this.step = 0;
    }
    
    update(vrbls, dt) {
        super.update(vrbls);
        (this.mission == 0 ? this.mis0 : this.mis1).call(this, dt);
    }
    
    mis0(dt) {
        this.time+=dt*30;
        if(this.time % 200 >= 0) {
            this.step = this.step == 1 ? 0 : 1;
        }
        
        switch(this.step) {
            case 0: 
                this.speed = this.maxSpeed + ((this.px - 350) - this.x) / 15;
                break;
            case 1: 
                this.speed = this.maxSpeed + ((this.px + 150) - this.x) / 30;
                break;
        }
        
        if(this.speed < 0) {
            this.speed = -(this._prop[0] || 5);
        }
    }

    mis1() {
        this.speed = this.maxSpeed + ((this.px + 50) - this.x) / 60;
    }
};;DP3.ai_car_2 = class extends DP3.AI {
    constructor (vrbls) {
        super(vrbls);
        this.rotate = 0;
        this.dist = 100 + Math.random() * 200;
    }
    
    update(vrbls) {
        super.update(vrbls);
        
        if(this.rotation < -40 || this.rotation > 90) {
            this.rotate = 5;
        } else if(this.rotation > 40) {
            this.rotate = -2;
        }

        switch(this.mission) {
            case 0:
                this.speed = this.pSpeed + ((this.px - 250) - this.x) / 10;
                this.speed = this.speed < 0 ? -2 : this.speed;
                break;
            case 1:
                this.speed = this.maxSpeed + ((this.px - 100 + this.dist) - this.x) / 60;
                break;
            default:
                break;
        }
    }
};;DP3.ai_car_3 = class extends DP3.AI {
    //arr = [time, 0v, 1v, 2v,....]
    constructor(vrbls, arr = []) {
        super(vrbls);
        this._prop = arr;
        this.time = this._prop[0] || 100;
        this.step = 1;
    }
    
    update(vrbls, dt) {
        super.update(vrbls);
        (this.mission == 0 ? this.mis0 : this.mis1).call(this, dt);
    }
    
    mis0(dt) {
        this.time-=dt * 30;
        switch(this.step) {
            case 1:
                this.k = this.x > this.px ? 1 : -1;
                this.speed = this.maxSpeed * this.k + ((this.px + (this._prop[1] || 25)/*0v*/ * this.k) - this.x) / 30;
                if(this.time < 0) {
                    this.step = 2;
                }
                break;
            case 2:
                this.speed = this.pSpeed + (this.px - this.x) / (this._prop[5] || 30)/*4v*/;
                
                if(Math.abs(this.px - this.x) < 150) {
                    this.touch = true;
                }
                
                if(this.touch && this.time < 0) {
                    this.touch = false;
                    this.time = (this._prop[2] || 80)/*1v*/;
                }
                if(this.time >= (this._prop[3] || 50)/*2v*/) {
                    this.step = 1;
                }
                break;
        }
    }

    mis1() {
        this.speed = this.maxSpeed + ((this.px + (this._prop[4] || 300)/*3v*/) - this.x) / 60;
    }
};;DP3.ai_car_4 = class extends DP3.AI {
    constructor (vrbls) {
        super(vrbls);
        this.dist = 100 + Math.random() * 200;
        this.time = 0;
        this.step = 0;
    }
    
    update(vrbls, dt) {
        super.update(vrbls);
        (this.mission == 0 ? this.mis0 : this.mis1).call(this, dt);
    }
    
    mis0(dt) {
        this.time+=dt*30;
        if(this.time % 200 >= 0) {
            this.step = this.step == 1 ? 0 : 1;
        }
        
        switch(this.step){
            case 0: 
                this.speed = this.maxSpeed + ((this.px - 350) - this.x) / 15;
                this.speed = this.speed < 0 ? -2 : this.speed;
                break;
            case 1: 
                this.speed = this.maxSpeed + ((this.px + 150) - this.x) / 30;
                break;
        }
        
        if(this.speed < 0) {
            this.speed = -3;
        }
    }

    mis1() {
        this.speed = this.maxSpeed + ((this.px - 100 + this.dist) - this.x) / 60;
    }
};;DP3.ai_car_5 = class extends DP3.AI {
    //arr = [0v, 1v, 2v,....]
    constructor (vrbls, arr = []) {
        super(vrbls);
        this._prop = arr;
        this.dist = 100 + Math.random() * 200;
    }
    
    update(vrbls) {
        super.update(vrbls);
        (this.mission == 0 ? this.mis0 : this.mis1).call(this);
        
        switch(this.mission) {
            case 0:
                this.speed = this.maxSpeed + ((this.px - (this._prop[0] || 350)/*0v*/) - this.x) / (this._prop[1] || 7)/*1v*/;
                this.speed = this.speed < 0 ? -((this._prop[2] || 2)/*2v*/) : this.speed;
                break;
            case 1:
                this.speed = this.maxSpeed + ((this.px - 100 + this.dist) - this.x) / 60;
                break;
        }
    }
};;DP3.ai_jailCar = class extends DP3.AI {
    constructor(vrbls) {
        super(vrbls);
    }

    update(vrbls) {
        super.update(vrbls);
        //this.speed = this.maxSpeed + ((this.px + 250) - this.x) / 50;
        //this.speed = this.speed < 1 ? 1 : this.speed;
        const x0 = this.px - 200;
        
        if(x0 > this.x) {
            this.speed = 5;
        } else {
            const dx = this.x - x0;
            this.speed = Math.max(1, 5 - dx / 100);
        }
    }
};;DP3.CheckboxGroup = class extends Phaser.Sprite {
    constructor(settings) {
        super(settings.game);
        let conf = settings || {};
        this.game = settings.game;
        
        this.data = {
            value: conf.value || 0,
            count: conf.count || 2,
            checkboxes: [],
            callback: conf.callback || null,
            onover: conf.onover || null
        };
        
        this.create();
        this.select(conf.select || 0);
    }
    
    create() {
        for(let i = 0, l = this.data.count; (i | 0) < l; i+=1) {
            let button = new Phaser.Image(this.game, 0, 0, "setting1", "chekBox_001.png");
            button._value = i;
            button.anchor.set(0.5, 0.5);
            
            button.inputEnabled = true;
            button.input.useHandCursor = true;
            button.events.onInputDown.add(() => {this.select(i);}, this);
            button.events.onInputOut.add(() => {this._onOut(i);}, this);
            button.events.onInputOver.add(() => {this._onOver(i);}, this);
            
            this.data.checkboxes.push(button);
            this.addChild(button);
        }
    }
    
    select(n) {
        let elem = this.getCheckbox(n);
        if(elem._status) {
            return;
        }
        this.clearStatus();
        this.data.value = n;
        elem._status = true;
        elem.frameName = "chekBox_003.png";
        setTimeout(() => {elem.frameName = "chekBox_004.png";}, 150);
        if(this.data.callback) {
            this.data.callback(this.data.value);
        }
    }
    
    _onOver(n) {
        let elem = this.getCheckbox(n);
        if(!elem._status) {
            elem.frameName = "chekBox_002.png";
        }
        
        if(this.data.onover) {
            this.data.onover();
        }
    }
    
    _onOut(n) {
       let elem = this.getCheckbox(n);
        if(!elem._status) {
            elem.frameName = "chekBox_001.png";
        }
    }
    
    getCheckbox(n) {
        return this.data.checkboxes[n];
    }
    
    clearStatus() {
        for(let i = 0, arr = this.data.checkboxes, l = arr.length; (i | 0) < l; i+=1) {
            arr[i]._status = false;
            arr[i].frameName = "chekBox_001.png";
        }
    }
    
    getCheckboxes() {
        return this.data.checkboxes;
    }
};;DP3.LocaleSaveButton = class extends Phaser.Sprite {
    constructor(settings) {
        super(settings.game);
        let conf = settings || {};
        this.game = settings.game;
        
        this.data = {
            image: conf.image || null,
            callbacks: conf.callbacks || {}, // openSave, deleteSave, newGame
            saveData: conf.saveData || null, // number, car, stars, money
            onover: conf.onover || null,
            ondown: conf.ondown || null
        };
        
        this.create();
    }
    
    create() {
        if(!this.data.image) {
            return;
        }
        
        let button = new Phaser.Image(this.game, 0, 0, this.data.image, "btnNewGames_001.png"),
            context = new Phaser.Sprite(this.game, 0, 0);
        
        button.anchor.set(0.5, 0.5);
        button.inputEnabled = true;
        button.input.useHandCursor = true;
        
        if(this.data.saveData) {
            const data = this.data.saveData,
                  number = new Phaser.Text(this.game, 0, 0, String(data.number || 1), {fontSize: 20, fill: "#00ffe9", fontWeight: "bold", font: DP3.font2}),
                  car = new Phaser.Image(this.game, 0, 0, this.data.image, "slotCars_004.png"),
                  stars = new Phaser.Text(this.game, 0, 0, (data.stars || 0) + "/39", {fontSize: 18, fill: "#00ffe9", fontWeight: "bold", font: DP3.font2}),
                  iconStar = new Phaser.Image(this.game, 0, 0, "galleryStar_02"),
                  money = new Phaser.Text(this.game, 0, 0, String(data.money || 0), {fontSize: 18, fill: "#00ffe9", fontWeight: "bold", font: DP3.font2}),
                  iconMoney = new Phaser.Image(this.game, 0, 0, "pauseIcoMoney"),
                  removeButton = new Phaser.Button(this.game, 0, 0, "button1", this._openRemoveMenu.bind(this), this, "btnCancelSmall_002.png", "btnCancelSmall_001.png", "btnCancelSmall_003.png", "btnCancelSmall_001.png");
            
            if(this.data.onover) {
                removeButton.onInputOver.add(this.data.onover);
            }
            
            number.position.set(-122, 2);
            number.anchor.set(0.5, 0.5);
            context.addChild(number);
            
            car.position.set(-82, 0);
            car.anchor.set(0.5, 0.5);
            context.addChild(car);
            
            stars.position.set(7, 2);
            stars.anchor.set(1, 0.5);
            context.addChild(stars);
            
            iconStar.position.set(23, 0);
            iconStar.anchor.set(0.5, 0.5);
            iconStar.scale.set(0.8);
            context.addChild(iconStar);
            
            money.position.set(101, 4);
            money.anchor.set(1, 0.5);
            context.addChild(money);
            
            iconMoney.position.set(114, 0);
            iconMoney.anchor.set(0.5, 0.5);
            context.addChild(iconMoney);
            
            removeButton.position.set(136, -20);
            removeButton.anchor.set(0.5, 0.5);
            removeButton.scale.set(0.45);
            context.addChild(removeButton);
            
            button.events.onInputDown.add(this._onDown, this);
            button.events.onInputUp.add(this._onUp, this);
            button.events.onInputOut.add(this._onOut, this);
            button.events.onInputOver.add(this._onOver, this);
        } else {
            let text = new Phaser.Text(this.game, 0, 0, "NEW GAME", {fontSize: 25, fill: "#00ffe9", fontWeight: "bold", font: DP3.font1});
            
            text.anchor.set(0.5, 0.5);
            context.addChild(text);
            this.text = text;
            
            
            button.events.onInputDown.add(this._onDown, this);
            button.events.onInputUp.add(this._onUp, this);
            button.events.onInputOut.add(this._onOut, this);
            button.events.onInputOver.add(this._onOver, this);
        }
        
        this.button = button;
        this.context = context;
        
        this.addChild(button);
        this.addChild(context);
    }
    
    _createRemoveMenu() {
        const wrap = new Phaser.Sprite(this.game, 0, 0, "slots1", "btnNewGames_003.png"),
              text = new Phaser.Text(this.game, -125, 2, "Clear slot ?", {fontSize: 18, fill: "#00ffe9", fontWeight: "bold", font: DP3.font1}),
              yesButton = new Phaser.Button(this.game, 35, 0, "slots1", () => {
                  if(this.data.callbacks.remove) {
                      this.data.callbacks.remove();
                  };
                  if(this.data.ondown) {
                      this.data.ondown();
                  }
              }, this, "btnYes_002.png", "btnYes_001.png", "btnYes_003.png", "btnYes_001.png"),
              noButton = new Phaser.Button(this.game, 97, 0, "slots1", this._closeRemoveMenu.bind(this), this, "btnNo_002.png", "btnNo_001.png", "btnNo_003.png", "btnNo_001.png");
        
        wrap.anchor.set(0.5);
        text.anchor.set(0, 0.5);
        yesButton.anchor.set(0.5);
        noButton.anchor.set(0.5);
        
        wrap.addChild(text);
        wrap.addChild(yesButton);
        wrap.addChild(noButton);
        
        this.addChild(wrap);
        
        this.removeMenu = wrap;
    }
    
    _openRemoveMenu() {
        if(this.button) {
            this.button.visible = false;
        }
        
        if(this.context) {
            this.context.visible = false;
        }
        
        if(!this.removeMenu)this._createRemoveMenu();
        
        this.removeMenu.visible = true;
    }
    
    _closeRemoveMenu() {
        if(this.button) {
            this.button.visible = true;
        }
        
        if(this.context) {
            this.context.visible = true;
        }
        
        if(this.removeMenu) {
            this.removeMenu.visible = false;
        }
    }
    
    _onDown(n) {
        this.button.frameName = "btnNewGames_003.png";
        
        if(this.data.callbacks.open) {
            this.data.callbacks.open();
        }
        
        if(this.data.ondown) {
            this.data.ondown();
        }
    }
    
    _onUp(n) {
        if(this.button.input.pointerOver()) {
            this._onOver();
        } else {
            this._onOut();
        }
    }
    
    _onOver() {
        if(this.text) {
            this.text.fill = "#61fff1";
            this.text.fontSize = 28;
        }
        this.button.frameName = "btnNewGames_002.png";
        
        if(this.data.onover) {
            this.data.onover();
        }
    }
    
    _onOut() {
        if(this.text) {
            this.text.fill = "#00ffe9";
            this.text.fontSize = 25;
        }
        this.button.frameName = "btnNewGames_001.png";
    }
};;DP3.ProgressButton = class extends Phaser.Sprite {
    constructor(settings) {
        super(settings.game);
        let conf = settings || {};
        this.game = settings.game;
        
        this.data = {
            maxLength: 400,
            min: conf.minLength || 0,
            max: conf.maxLength || 100,
            keysImages: conf.keysImages || null, // button: {key, buttonDefault, buttonActive, buttonHover}, back, light, frame
            callback: conf.callback || null,
            onover: conf.onover || null,
            ondown: conf.ondown || null
        };
        
        this.create();
    }
    
    create() {
        if(!this.data.keysImages) {
            return;
        }
        let button = new Phaser.Sprite(this.game, 0, 0, this.data.keysImages.button.key, this.data.keysImages.button.buttonDefault),
            back = new Phaser.Image(this.game, 0, 0, this.data.keysImages.back),
            light = new Phaser.Sprite(this.game, 0, 0, this.data.keysImages.light),
            frame = new Phaser.Image(this.game, 0, 0, this.data.keysImages.frame),
            image = this.game.cache.getImage(this.data.keysImages.light),
            mask = new Phaser.Graphics(this.game, 0, 0);
        
        back.anchor.set(0, 0.5);
        light.anchor.set(0, 0.5);
        frame.anchor.set(0, 0.5);
        button.anchor.set(0, 0.5);
        
        light.alpha = 0.4;
        light.tint = 0x0eddff;
        
        button.inputEnabled = true;
        button.input.useHandCursor = true;
        button.input.enableDrag();
        button.events.onInputDown.add(this._onDown, this);
        button.events.onInputUp.add(this._onUp, this);
        button.events.onInputOut.add(this._onOut, this);
        button.events.onInputOver.add(this._onOver, this);
        button.events.onDragUpdate.add(this._dragUpdate, this);
        
        //mask
        mask.beginFill(0xffffff);
        mask.drawRect(-image.width + 24, -image.height * 0.5, image.width, image.height);
        light.mask = mask;
        
        this.lightMask = mask;
        this.button = button;
        
        this.addChild(mask);
        this.addChild(back);
        this.addChild(light);
        this.addChild(frame);
        this.addChild(button);
    }
    
    _dragUpdate() {
        this.button.position.y = 0;
        
        if(this.button.position.x < this.data.min) {
            this.button.position.x = this.data.min;
        } else if(this.button.position.x > this.data.max) {
            this.button.position.x = this.data.max;
        }
        this.updateMask();
        
        this.sendValue();
    }
    
    _onDown(n) {
        let elem = this.button;
        if(elem._status) {
            return;
        }
        elem._status = true;
        elem.frameName = this.data.keysImages.button.buttonActive;
        
        if(this.data.ondown) {
            this.data.ondown();
        }
    }
    
    _onUp(n) {
        let elem = this.button;
        elem._status = false;
        if(elem.input.pointerOver()) {
            this._onOver();
        } else {
            this._onOut();
        }
        this.updateMask();
        
        this.sendValue();
    }
    
    _onOver() {
        if(!this.button._status) {
            this.button.frameName = this.data.keysImages.button.buttonHover;
        }
        
        if(this.data.onover) {
            this.data.onover();
        }
    }
    
    _onOut() {
        if(!this.button._status) {
            this.button.frameName = this.data.keysImages.button.buttonDefault;
        }
    }
    
    getValue() {
        return this.button.position.x / this.data.max;
    }
    
    setValue(x) {
        this.button.position.x = x * this.data.max;
        this.updateMask();
    }
    
    sendValue() {
        if(this.data.callback) {
            this.data.callback(this.getValue());
        }
    }
    
    updateMask() {
        this.lightMask.position.x = this.button.position.x;
    }
};;DP3.Ally = class extends DP3.CarPhysics {
    constructor(prop = {}) {
        super(prop);
    }
    
    step(self) {
        this._moveCtrl();
        
        const pos = this.getPosition(),
              target = self.getTarget(pos.x, pos.y, this._type, 700);
        
        if(!target)return;
        
        const L = this._absAngle(this.game.math.angleBetweenPoints(pos, target.getPosition()));
        
        if(L < (Math.PI / 2) || L > Math.PI * 3 / 2) {
            this.rotateTower("right");
        } else {
            this.rotateTower("left");
        }
    }
    
    get finished() {
        return this.dataPosition.finished;
    }
    
    get motorStatus() {
        return this.dataPosition.motor;
    }
    
    _moveCtrl() {
        const p = this._body.GetPosition();
        
        if(this.dataPosition.finish <=  p.x) {
            ///STOP!
            if(!this.dataPosition.finished) {
                this.dataPosition.motor = false;
                this.dataPosition.finished = true;
            }
        }
        
        if(!this.motorStatus) {
            this.motor("stop");
        }
    }
    
    setMotorStatus(value = false) {
        if(this.finished)value = false;
        this.dataPosition.motor = !!value;
    }
    
    createMarker() {
        const wrap = this.getWrap(),
              marker = this.getWrap(),
              image = new Phaser.Image(this.game, 0, 0, "markerDefend"),
              text = new Phaser.Text(this.game, 0, -110, "DEFEND", {fontSize: 68, fill: "#ffffff", font: DP3.font5, stroke: "#000", strokeThickness: 8});
        
        this.game.add.tween(marker.position).to({y: -40}, 500, "Linear").to({y: 0}, 300, "Linear", true).loop(true);
        
        text.anchor.set(0.5, 1);
        image.anchor.set(0.5, 1);
        
        marker.addChild(image);
        marker.addChild(text);
        wrap.addChild(marker);
        
        wrap.scale.set(0.22);
        
        this._marker = wrap;
        
        return wrap;
    }
    
    setPosData(x, y, L) {
        super.setPosData(x, y, L);
        
        if(this._marker)this._marker.position.set(x, y - 60);
    }
    
    update(self, dt, start) {
        super.update(self, dt, start);
        if(this._shock.fall)return;
        this.step(self);
        this._check(dt);
        
        return;
    }
};;DP3.Bullet = class extends DP3.Image {
    constructor(game) {
        super(game);
        this.game = game;
    }
    
    setData(prop = {}) {
        this.visible = true;
        this.alpha = 1;
        
        this._initImage(prop.image || "pc6_2", prop.frame || "bulletBarrel1.png");
        
        this._speed = prop.speed || 10;
        
        this.car = prop.car;
        
        this._lifeTime = prop._lifeTime || 200;
        this._lifeTime_d = this._lifeTime;
        this._exp = 0;
        this._startSpeed = 10;
        this._maxSpeed = 10;
        
        this._damage = prop.damage || 0;
        this.target = prop.target || null;
        this._scale = prop.scale || [1, 1];
        this._type = prop.type || 1;
        this.status = true;
        this.anim = prop.anim;
        this._defL = this._absAngle(prop.L) || 0;
        this._L = this._defL;
        
        this._isRotate = prop.rotate ? prop.rotate : false;
        
        if(prop.anchor) {
            this.anchor.set(prop.anchor[0], prop.anchor[1]);
        } else {
            this.anchor.set(0.5);
        }
        
        this.isHoming = prop.homing || false;
        this._wait = this.isHoming ? 25 : 0;
        
        this.isRocket = prop.isRocket || false;
        
        this.position.set(prop.x, prop.y);
        
        this._create();
        
        this._rectInit();
    }
    
    getLifeTime() {
        return this._lifeTime_d;
    }
    
    _initImage(image, frame) {
        if(this.key !== image)this.loadTexture(image);
        this.frameName = frame;
    }
    
    _rectInit() {
        if(!this._rect)this._rect = {};
        
        this._rect.width = this.width;
        this._rect.height = this.height;
    }
    
    getRect() {
        return this._rect;
    }
    
    getPosition() {
        return this.position;
    }
    
    _create() {
        this.scale.set(this._scale[0] * 1.9, this._scale[1] * 1.9);
        
        if(this.anim) {
            if(this.anim.name !== this._oldAnim || !this._animation) {
                this._oldAnim = this.anim.name;
                this._animation = this._createFrameAnim(this, this.anim, true, true);
            } else if(this._animation) {
                this._animation.resume();
                this._animation.start();
            }
        }
        
        this._rotateUpdate();
    }
    
    update(dt) {
        const f = dt * 60;
        
        if(this._lifeTime_d <= 0) {
            this.remove();
        } else {
            this._lifeTime_d-=f;
            this._wait-=f;
            
            if(this.isHoming) {
                this._homing(f);
            }
            
            if(this._isRotate) {
                this.rotation+=this._isRotate;
            }

            this.position.set(this.position.x + this._speed * Math.cos(this._L) * f, this.position.y + this._speed * Math.sin(this._L) * f);
        }
    }
    
    _findTarget() {
        if(this.car)this.target = this.car._core.getTarget(this.position.x, this.position.y, this._type) || null;
    }
    
    _homing(f) {
        if(this._wait > 0)return;
        if(!this.target || !this.target._live)this._findTarget();
        
        if(this.target) {
            this._lifeTime_d = this._lifeTime;
            
            const pos0 = this.position,
                  pos1 = this.target.getPosition(),
                  pos = {x: pos1.x - pos0.x, y: pos1.y - pos0.y},
                  L = this._absAngle(this._L),
                  L1 = this._absAngle(this.game.physics.arcade.angleBetween(this, this.target._frontWrap)),
                  dl = Math.abs(L1 - L),
                  d = ((L > L1 ? 1 : -1) * (dl > Math.PI ? -(Math.PI * 2 - dl) : dl)) / (5 / f);
            
            this._L-=d;
        } else {
            this._L = this._defL;
        }
        
        this.rotation = this._L;
    }
    
    _rotateUpdate() {
        this.rotation = this._L;
    }
    
    kill() {
        if(this._animation) {
            this._animation.pause();
        }
        
        this.visible = false;
        this.alpha = 0;
    }
    
    remove() {
        this.status = false;
    }
};
;DP3.Burn = class extends DP3.Image {
    constructor(game, car, type) {
        super(game, 0, 0, "effectAll1", "effectBurning" + (["", "Toxic", "Plasma"])[type - 1] + "_001.png");
        this.game = game;
        
        this._type = type;
        this.car = car || null;
        this.isBurn = true;
        
        this._create();
    }
    
    setData(prop = {}) {
        this.visible = true;
        this.position.set(prop.x, prop.y);
        this._init(prop.type);
        this._startAnim();
    }
    
    _init(type = 0) {
        this._lifeTime = 200;
        this.status = true;
    }
    
    _create() {
        this.anchor.set(0.5, 1);
        this.scale.set(0.5);
        this._createAnim();
    }
    
    _createAnim() {
        this.anim = this._createFrameAnim(this, "burn" + this._type, false, true, null, Math.round(Math.random() * 15));
    }
    
    _startAnim() {
        if(this.anim) {
            this.anim.resume();
            this.anim.start();
        }
    }
    
    _stopAnim() {
        if(this.anim) {
            this.anim.pause();
        }
    }
    
    getDamage() {
        switch(this._type) {
            case 2:
                return 12;
            case 3:
                return 17;
            default:
                return 7;
        }
    }
    
    update(dt) {
        if(this._lifeTime <= 0) {
            this.kill();
            return;
        }
        
        const f = dt * 60,
              scale = this.scale;
        
        scale.x -= (scale.x - 0.5) / 10;
        scale.y -= (scale.y - 0.5) / 10;
        
        if (Math.random() < 0.02) {
            scale.x += Math.random() * 0.7;
            scale.y += Math.random() * 0.7;
        }
        
        this._lifeTime-=f;
    }
    
    kill() {
        this.visible = false;
        this.status = false;
        this._stopAnim();
    }
};;DP3.Car = class extends DP3.CarPhysics {
    constructor(prop = {}) {
        super(prop);
        
        //this.maxHealth = 10000;
        this.setMaxHealth();
        
        this.fuel = this._correctData.fuel || 375;
        this.d_fuel = this.fuel;
        
        this.bomb = 3;//3;
        
        this._stoping = 100;
        this._stuck = false;
    }
    
    get stuck() {
        return this._stuck;
    }
    
    activeBoost(num) {
        switch(num) {
            case 1://health
                this.maxHealth*=2;
                this.setMaxHealth();
                break;
            case 2://fuel
                this.fuel*=2;
                this.d_fuel = this.fuel;
                break;
            case 4://damage
                this.dblDamage = true;
                break;
            case 3://rockets
                this.bomb*=2;
                break;
            default:
                break;
        }
    }
    
    launcherFire() {
        if(!this.bomb || this.isFallInShock())return;
        
        const launcher = this._launcher,
              data = launcher.bullet || {animation: {}}
        
        this.bomb-=1;
        
        if(this.bomb === 0)this._core.talk("YOU OUT OF\nROCKETS!", 0);
        
        super.launcherFire();
        
        if(this._core && this._core.addBullet) {
            const generBullet = (i) => {
                        const pos = this.getPosition(),
                              posL = launcher.position,
                              posB = launcher.bulletsPositions ? (i >= launcher.bulletsPositions.length ? launcher.bulletsPositions[launcher.bulletsPositions.length - 1] : launcher.bulletsPositions[i]) : [0, 0],
                              s = this.getMainScale().x,
                              L = this.getRotation(),
                              dx = posL.x + posB[0],
                              dy = posL.y + posB[1],
                              sinL = Math.sin(L),
                              cosL = Math.cos(L),
                              obj = {
                                  game: this.game, 
                                  car: this, 
                                  image: data.image || "pc6_8", 
                                  frame: data.frame || "missile2_001.png", 
                                  x: pos.x + (dy * sinL + dx * cosL) * s, 
                                  y: pos.y + (dy * cosL + dx * sinL) * s, 
                                  L: (launcher.bulletsAngles ? (i >= launcher.bulletsAngles.length ? launcher.bulletsAngles[launcher.bulletsAngles.length - 1] : launcher.bulletsAngles[i]) : -0.75) + L, 
                                  anchor: [0.5, 0.8],
                                  anim: data.animation.name || "missile2", 
                                  type: this._type, 
                                  scale: data.scale || [0.3, 0.3], 
                                  damage: data.damage || 14250, 
                                  speed: data.speed || 9,
                                  homing: true,
                                  target: this.getTarget(),
                                isRocket: true
                        };
                      
                      this._core.addBullet(obj);
                  };
            
            for(let i = 0, l = launcher.shots; (i | 0) < l; i+=1) {
                if(launcher.bulletsDelay) {
                    this.game.time.events.add(i >= launcher.bulletsDelay.length ? launcher.bulletsDelay[launcher.bulletsDelay.length - 1] : launcher.bulletsDelay[i], () => {generBullet(i);});
                } else {
                    generBullet(i);
                }
            }
            
            return true;
        }
    }
    
    checkStuck(started = false, up = false, down = false, f = 1) {
        const body = this._body;
        
        if(!body)return;
        
        if(started && (down || up)) {
            if (Math.abs(body.GetLinearVelocity().x) < 4) {
                this._stoping = this._stoping >= 100 ? this._stoping - 1 * f : this._stoping;
            } else {
                this._stoping = 100;
            }
        }
        
        if(this._stoping < 100) {
            if(this._stoping-- < 0) {
                if(!this._stuck) {
                    this._stuck = true;
                }
            }
        } else {
            if(this._stuck) {
                this._stuck = false;
            }
        }
        
        
        return this._stuck;
    }
    
    createMarker() {
        const wrap = this.getWrap(),
              marker = this.getWrap(),
              image = new Phaser.Image(this.game, 0, 0, "markerBody"),
              text = new Phaser.Text(this.game, 0, -144, "STUCK?", {fontSize: 60, fill: "#000000", font: DP3.font5}),
              text2 = new Phaser.Text(this.game, 0, -110, "PRESS SHIFT!", {fontSize: 36, fill: "#000000", font: DP3.font5});
        
        this.game.add.tween(marker.position).to({y: -40}, 500, "Linear").to({y: 0}, 300, "Linear", true).loop(true);
        
        text.anchor.set(0.5, 1);
        text2.anchor.set(0.5, 1);
        image.anchor.set(0.5, 1);
        
        text2.addColor('#cd0101', 6);
        text2.addColor('#000000', 11);
        
        marker.addChild(image);
        marker.addChild(text);
        marker.addChild(text2);
        wrap.addChild(marker);
        
        wrap.scale.set(0.25);
        
        wrap.visible = false;
        
        this.marker = wrap;
        
        return wrap;
    }
    
    getTarget() {
        return this._target;
    }
    
    __getSide() {
        if(this._turrets[0]) {
            return this._turrets[0].getSide();
        }
    }
    
    updateTarget() {
        const pos = this.getPosition(),
              B = this.getRotation() + (this.__getSide === "left" ? Math.PI : 0) - (Math.PI / 2);
            
        this._target = this.getMainTarget() || this._core.getTarget(pos.x, pos.y, this._type, 700, true, Math.PI, B) || this._core.getTarget(pos.x, pos.y, this._type) || null;
    }
    
    /*Deactivate(time:int = int.MAX_VALUE):void {
        if (_deactive)
            return;
        _activeTime = time;
        _deactive = true;
        _electro = new Shape();
        _main.transform.colorTransform = new ColorTransform(1, 1, 1, 1, -100, -100, -20);
        var i:int = _wheels.length;
        while (--i > -1) {
            _wheels[i].body.SetLinearVelocity(new b2Vec2(0, 0));
        }
        AddEffect(_electro, false, _main.numChildren - 1);
    }
    
    public function Activate():void {
			_deactive = false;
			_main.transform.colorTransform = new ColorTransform();
			RemoveEffect();
		}
		
    
    */
    
    _control() {
        //fuel-=0.1;
        //start time = 20
        //_body.ApplyTorque(-1000);
        
        
        //sound track 2 for 1,2,3,7,8,9,10,11,12,13,14,15 and 4,5,6
        
        //wheels.motor(1 || -1 || 0);
        
        //fuel fire: fuel-=1.5;
        
        //STOPPING
        /*
        if(Desktop.GetGame().started && (down || up))
			{
				if (Math.abs(_body.GetLinearVelocity().x) < 4)
				{
					_stoping = _stoping == 100 ? _stoping - 1 : _stoping;
				}
				else
				{
					_stoping = 100;
				}
			}
			if (_stoping < 100)
			{
				if (_stoping-- < 0)
				{
					if (!_stuck)
					{
						_stuck = new Indicator2("Stuck");
						Desktop.GetGame().Add(_stuck.Costume(), Desktop.GetGame().numChildren - 1);
						Input.addDownList(Input.SHIFT, stuckOut);
					}
				}
			}
			else
			{
				if (_stuck)
				{
					Desktop.GetGame().Remove(_stuck.Costume());
					Input.remove(stuckOut);
					_stuck = null;
				}
			}*/
        
        //BALANCE
        /*
        var headOverHeels:Boolean = false;
			var a:Number = Dmath.OptimalRadian(_body.GetAngle());
			if (Math.abs(a) > Math.PI / 4 * 3)
				headOverHeels = true;
			if (Input.isPressed(Input.RIGHT, Input.D) && _body.GetAngularVelocity() < 5) {
				if (_body.GetAngularVelocity() < 0)
					_body.SetAngularVelocity(0);
				_body.ApplyTorque(headOverHeels ? 1000 : 180);
			}else if (Input.isPressed(Input.LEFT, Input.A) && _body.GetAngularVelocity() > -5) {
				if (_body.GetAngularVelocity() > 0)
					_body.SetAngularVelocity(0);
				_body.ApplyTorque(headOverHeels ? -1000 : -170);
			}else{
				_body.ApplyTorque(0);
			}*/
    }
    
    /*
    private function stuck():void 
		{
			if (_player && Math.cos(_body.GetAngle()) < 0)
			{
				if (_stuckTime-- < 0)
				{
					if (!_stuck)
					{
						_stuck = new Indicator2("Stuck");
						Desktop.GetGame().Add(_stuck.Costume(), Desktop.GetGame().numChildren - 1);
						Input.addDownList(Input.SHIFT, stuckOut);
					}
				}
			}
			else
			{
				_stuckTime = 50;
				Input.remove(stuckOut);
				if (_stuck && _stoping == 100)
				{
					Desktop.GetGame().Remove(_stuck.Costume());
					_stuck = null;
				}
			}
		}
		
		private function stuckOut(e:Event):void 
		{
			_stoping = 100;
			Teleporting(x, y - 100, 0);
		}
        
        
        private function taskManager():void 
		{
			if (_task_enable-- > 0)
				return;
			_task_enable = 100;
			
			var UI:Interfac = Desktop.GetI();
			/*var isHevyArmor:Boolean = false;
			var totalArmor:int = 0;
			var turnCommand:int = 0;
			var task_slowSpeed:Boolean = false;
			var d:Number = int.MAX_VALUE;
			
			if (Math.abs(_body.GetLinearVelocity().x) < 5) {
				task_slowSpeed = true;
			}*/
			//ENEMY MONITOR
			/*var actors:Vector.<Car> = Desktop.GetGame().GetActors();
			var actor:Car;
			var i:int = actors.length;
			while (--i > -1) {
				actor = actors[i];
				if (actor === this)
					continue;
				totalArmor += actor.Health();
				if (actor.Health() > 3000) {
					isHevyArmor = true;
				}
				if (actor.x < d) {
					turnCommand = (x - actor.x > 0) ? -1 : 1;
				}
			}*/
			/*//USE ROCKETS!!!
			if (isHevyArmor) {
				UI.talkBabe("useRockets");
			}*/
			
			/*//TURN BACK (FORWARD) !!!!
			if (turnCommand != 0 && _direction != turnCommand) {
				UI.talkBabe("gun" + (turnCommand < 0 ? "Back" : "Forward"));
			}*/
			
			//GO GO GO !!
    ///////////////////////////////////////
			/*if (x < 1000 && _started) {
				UI.talkBabe("gogogo");
			}*/
			
			/*//FASTER !!!
			if (totalArmor > 10000 && task_slowSpeed) {
				UI.talkBabe("faster");
			}*/
			
			//WE DID IT!!! OH, NO!!!!
    ///////////////////////////////
			/*if (_started && Desktop.GetGame().gameIsOver) {
				if(Desktop.GetGame().win){
					UI.talkBabe(Dmath.Choicer("great", "fantastic", "excellent", "letsRide", "weDidIt"));
				}else {
					UI.talkBabe("ohno");
				}
			}
		}
    */
    
    addBomb(value = 0) {
        this.bomb+=value;
    }
    
    addFuel(value = 0) {
        this.d_fuel+=value;
    }
    
    healthStatus() {
        return this.health / this.maxHealth;
    }
    
    fuelStatus() {
        return this.d_fuel / this.fuel;
    }
    
    checkFuel() {
        return this.d_fuel > 0;
    }
    
    getFuel() {
        return this.d_fuel;
    }
    
    useFuel(f = 0) {
        this.d_fuel-=f;
        
        if(this.d_fuel < 0) {
            if(this.callbacks.kill) {
                this.callbacks.kill();
            }
            return;
        }
        
        this.d_fuel = this.fuel < this.d_fuel ? this.fuel : this.d_fuel;
    }
    
    setPosData(x, y, L) {
        super.setPosData(x, y, L);
        
        if(this.marker)this.marker.position.set(x, y - 45);
    }
    
    update(self, dt, start) {
        super.update(self, dt, start);
        
        //this.damage(50);
        this.updateTarget();
        
        this._control();
    }
};;DP3.Carriage = class extends DP3.Image {
    constructor(game, car, data) {
        const pos = data.position || [0, 0];
        super(game, pos[0], pos[1], data.image, data.frame);
        this.game = game
        this.car = car;
        
        if(!data)return;
        
        this._init(data);
        this._create(data.decore, data.guns);
    }
    
    _init(data) {
        this._buletAngle = 0;
        this.side = "right";
        this.target = null;
        this._guns = [];
        this._decor = [];
        this._limits = this._limitsToRadian(data.limits) || [0, 0];
        this._lookDistance = data.lookDistance || [10, 500];
    }
    
    _create(decore, guns) {
        this._createDecore(decore);
        this._createGuns(guns);
        
        /*const gr = new Phaser.Graphics(this.game);
        gr.beginFill(0xFF3300);
        gr.lineStyle(5, 0x3dff3d, 0.8);
        gr.moveTo(0,0);
        gr.lineTo(5000, 0);
        gr.endFill();
        gr.beginFill(0x1dff00);
        gr.lineStyle(0);
        gr.drawCircle(0, 0, 15);
        gr.endFill();
        this.addChildAt(gr, 0);/**/
    }
    
    _limitsToRadian(limits) {
        if(!limits || !(limits instanceof Array))return false;
        
        const L = (limits[0] / 180) * Math.PI,
              B = (limits[1] / 180) * Math.PI;
        
        return [L, B];
    }
    
    _getPoint() {
        const scale = this.game.camera.scale.x;
        return {x: this.world.x / scale, y: this.world.y / scale};
    }
    
    _createGuns(data) {
        if(!data)return;
        for(let i = 0, arr = data, l = arr.length; (i | 0) < l; i+=1) {
            this._createGun(arr[i]);
        }
    }
    
    _createGun(data) {
        const gun = new DP3.Gun(this.game, this.car, data, this);
        
        this._guns.push(gun);
        
        if(data.front) {
            this.addChild(gun);
        } else {
            this.addChildAt(gun, 0);
        }
    }
    
    _createDecore(arr = []) {
        for(let i = 0, l = arr.length; (i | 0) < l; i+=1) {
            const data = arr[i];
            
            const elm = this._createElement(data, false);
        
            if(data["animation"]) {
                elm._anim = this._createFrameAnim(elm, data["animation"]["name"], data["animation"]["start"], data["animation"]["loop"]);
            }

            if(data.front) {
                this.addChild(elm);
            } else {
                this.addChildAt(elm, 0);
            }
        }
    }
    
    _homing(self) {
        this.target = null;
        if(!self)return;
        const posG = this._getPoint(),
              carL = this.car._frontWrap.rotation,
              limits = this._limits;
        
        const target = self.getTarget(posG.x, posG.y, this.car._type, this._lookDistance, true, limits[0], limits[1] + carL + (this.side === "left" ? Math.PI : 0));
        
        if(target && target._frontWrap) {
            const posT = target._frontWrap.position,
                  L0 = this.game.math.angleBetween(posG.x, posG.y, posT.x, posT.y),
                  L = L0 - carL;
            this._buletAngle = L0;
            this.rotation = this.side === "left" ? (Math.PI - L) : L;
            
            this.target = target;
        } else {
            this._buletAngle = carL;
            this.rotation = 0;
        }
    }
    
    getGuns() {
        return this._guns;
    }
    
    getBulletAngle() {
        return this._buletAngle;
    }
    
    _updateGuns(self, dt, target) {
        for(let i = 0, arr = this._guns, l = arr.length; (i | 0) < l; i+=1) {
            arr[i].update(self, dt, target);
        }
    }
    
    getTarget() {
        return this.target;
    }
    
    update(self, dt) {
        this._homing(self);
        
        this._updateGuns(self, dt, this.target);
    }
};;DP3.Enemy = class extends DP3.CarPhysics {
    constructor(prop = {}) {
        super(prop);
        
        this.dataPosition = {
            L: 0,
            x: 0,
            y: 0,
            c: 0,//count
            max: 30,
            finish: prop.finish || 50,
            finished: false,
            motor: false
        };
    }
    
    _autoBalance() {
        const body = this._body,
              L = this._body.GetAngle(),
              p = body.GetPosition(),
              dP = this.dataPosition;
        
        if(L > 0) {
            this.balance("top");
        } else {
            this.balance("down");
        }
        
        if(L == dP.L || p.x == dP.x) {
            dP.c+=1;
        } else {
            dP.c = 0;
            dP.L = L;
            dP.x = p.x;
            dP.y = p.y;
        }
        
        if(dP.c >= dP.max && this.dataPosition.motor) {
            this.shift();
            dP.c = 0;
        }
    }
    
    update(self, dt, start) {
        super.update(self, dt, start);
        
        if(start)this._aimAI(self);
        this._autoBalance();
    }
};;DP3.Gun = class extends DP3.Image {
    constructor(game, car, data, carriage) {
        const pos = data.position || [0, 0];
        super(game, pos[0], pos[1], data.image, data.frame);
        this.game = game;
        
        this.car = car || null;
        this.carriage = carriage;
        this.side = "right";
        
        if(!data)return;
        
        this._init(data);
        this._create(data);
    }
    
    _init(data) {
        this.bulletData = data.bullet || {};
        this._lesionAngle = Math.PI * 0.8;
        this._animData = data.animation || null;
        this.sound = this.car.sound || null;
        
        this._pouse = data.pouse * 2 || 100;
        this._rate = data.rate * 2 || 100;
        this._shots = data.shots || 1;
        this._pouse_d = this._pouse;
        this._rate_d = this._rate;
        this._shots_d = this._shots;
        
        this.waitOnFire = false;
        
        this._fireDistance = data.fireDistance || [10, 500];
        this._song = data.song;
        this._volume = data.volume || 100;
        
        this.isMain = this.car instanceof DP3.Car;
    }
    
    _create(data) {
        if(this._animData) {
            this._anim = this._createFrameAnim(this, this._animData["name"], this._animData["start"] || false, this._animData["loop"] || false);
        }
        
        if(data.anchor) {
            this.anchor.set(data.anchor[0], data.anchor[1]);
        }
        
        //laser
        /*const gr = new Phaser.Graphics(this.game);
        gr.beginFill(0xFF3300);
        gr.lineStyle(3, 0xff3d3d, 0.8);
        gr.moveTo(0,0);
        gr.lineTo(5000, 0);
        gr.endFill();
        gr.beginFill(0xff0000);
        gr.lineStyle(0);
        gr.drawCircle(0, 0, 10);
        gr.endFill();
        this.addChild(gr);/**/
    }
    
    _getPoint() {
        const scale = this.game.camera.scale.x;
        return {x: this.world.x / scale, y: this.world.y / scale};
    }
    
    fire(self) {
        this.waitOnFire = true;

        if(this.car && this.car._core) {
            const point = this._getPoint();

            this.car._core.addBullet({
                game: this.game, 
                car: this.car, 
                image: this.bulletData.image, 
                frame: this.bulletData.frame,
                rotate: this.bulletData.rotate,
                x: point.x, 
                y: point.y, 
                L: this.carriage.getBulletAngle(), 
                //target: this.target, 
                speed: this.bulletData.speed, 
                damage: this.bulletData.damage * (this.car.dblDamage ? 2 : 1), 
                type: this.car._type, 
                anim: this.bulletData.animation, 
                scale: this.bulletData.scale
            });

            this._animFire();
            
            if(this.isMain)self.user.addTo(1, ["stats", "shot"]);
        }
        
        if(this.sound && this._song) {
            this.sound.play(this._song);
        }
    }
    
    _animFire() {
        if(this._anim) {
            this._anim.resume();
            this._anim.start();
        }
    }
    
    getParameters() {
        return {
            shots: this._shots,
            pouse: this._pouse,
            rate: this._rate
        };
    }
    
    update(self, dt, target) {
        
        let shoot = false,
            isWait = false,
            f = dt * 60;
        
        if(this._rate_d <= 0) {
            shoot = target;
        } else {
            if(this._pouse_d <= 0) {
                if (this._rate_d > 0) {
                    this._rate_d-=f;
                }
            } else {
                this._pouse_d-=f;
            }
        }

        if(shoot || this.waitOnFire) {
            if(target) {
                const posG = this._getPoint(),
                      carL = this.car._frontWrap.rotation,
                      limits = this._limits;
                if(target instanceof Boolean || self.checkTarget(target, posG.x, posG.y, this.car._type, this._fireDistance)) {
                    this.fire(self);
                }
            }
            this.waitOnFire = false;
            this._rate_d = this._rate;
            this._shots_d-=f;
            if(this._shots_d <= 0) {
                this._shots_d = this._shots;
                this._pouse_d = this._pouse;
            }
        }
    }
};;DP3.HealthBar = class extends DP3.Image {
    constructor(prop = {}) {
        super(prop.game);
        
        this._percent = 1;
        this.__MaxWidth = 90;
        this.__Height = 10;
        
        this._create();
        
        //this.alpha = 0.1;
    }
    
    _create() {
        const fill = new Phaser.Graphics(this.game),
              wrap = new Phaser.Image(this.game, 0, 0, "healthBar");
        
        wrap.anchor.set(0.5);
        
        this._fill = fill;
        
        this.addChild(fill);
        this.addChild(wrap);
        
        this._draw();
    }
    
    setPercent(x) {
        if(x && x !== this._percent) {
            this._percent = Number(x);
            this._draw();
        }
    }
    
    _draw() {
        const gr = this._fill,
              w = this.__MaxWidth,
              h = this.__Height;
        
        gr.clear();
        
        gr.beginFill(0xff0000);
        gr.lineStyle(0, 0x000000, 1);
        gr.drawRect(-(w / 2), -(h / 2), w * this._percent, h);
    }
};;DP3.ShopCar = class extends DP3.CarSprite {
    constructor(prop = {}, focus = false) {
        prop.way = true;
        super(prop);
        
        this._infoWrap.visible = false; 
        //this._wheelsWrap.visible = false;
        
        this._wheels = [];
        
        this._createWheels();
        
        this._checkFocus(focus);
        
        this.__animation();
    }
    
    __animation() {
        const t1 = Math.random() * 700,
              t = (1.5 + Math.random()) * 1000,
              f1 = this.launcherFire.bind(this),
              f = this.__animation.bind(this),
              guns = this.__getTurretsAnimData();
        
        for(let i = 0, times = guns.t.concat([t1, t]), arr = guns.f.concat([f1, f]), l = Math.min(times.length, arr.length); (i | 0) < l; i+=1) {
            this.game.add.tween(this).to({}, times[i], "Linear", true).onComplete.add(arr[i]);
        }
    }
    
    __getTurretsAnimData() {
        const res = {
                f: [],
                t: []
            };
        
        let guns = [];
        
        //search guns
        for(let i = 0, arr = this._turrets, l = arr.length; (i | 0) < l; i+=1) {
            for(let j = 0, arr2 = arr[i].getCarriages(), k = arr2.length; (j | 0) < k; j+=1) {
                guns = guns.concat(arr2[j].getGuns());
            }
        }
        
        //gener dat
        for(let i = 0, arr = guns, l = arr.length; (i | 0) < l; i+=1) {
            const gun = arr[i],
                  data = gun.getParameters(),
                  t = Math.random() * 1000,
                  c = Math.max(Math.round(60 / data.pouse * data.shots), 1),
                  f = gun._animFire.bind(gun);
            
            res.t.push(t);
            if(c > 1) {
                res.f.push(() => {
                    this.game.add.tween(this).to({}, data.rate * 17, "Linear", true).repeat(c).onRepeat.add(f);
                });
            } else {
                res.f.push(f);
            }
        }
        
        return res;
    }
    
    _checkFocus(focus) {
        if(!focus || focus == "wheels")return;
        
        for(let i = 0, names = ["shield", "motor", "fuel tank", "wheels", "guns", "rocket launcher", "back"], elements = [this._shield, this._motor, this._tank, this._wheelsWrap, this._turrets[0], this._launcher, this._back], l = Math.min(names.length, elements.length); (i | 0) < l; i+=1) {
            const name = names[i],
                  elem = elements[i],
                  setTint = function f(elem) {
                      if(elem.children && elem.children.length > 0) {
                          for(let i = 0, arr = elem.children, l = arr.length; (i | 0) < l; i+=1) {
                              f(arr[i]);
                          }
                      }
                      
                      elem.tint = "0x00a7ff";
                  };
            
            if(name !== focus) {
                elem.alpha = 0.6;
                setTint(elem);
            } else {
                if(name === "shield") {
                    const shop = this.getShopData(),
                          anchor = shop ? (shop["shield"][1] - 1) : 0;
                    for(let j = 0, arr = this._shields, k = arr.length; (j | 0) < k; j+=1) {
                        if(j !== anchor) {
                            arr[j].alpha = 0.6;
                            setTint(arr[j]);
                        } else {
                            this._frontWrap.addChild(arr[j]);
                        }
                    }
                } else {
                    this._frontWrap.addChild(elem);
                }
            }
        }
    }
    
    getWrap() {
        return new Phaser.Sprite(this.game, 0, 0);
    }
    
    _tuning() {
        const data = this._dataCar["properties"],
              way = this.getWay() ? 1 : -1,
              scale = 1.3;
        
        this._backWrap.scale.set(scale * way, scale);
        this._frontWrap.scale.set(scale * way, scale);
        if(this._wheelsWrap)this._wheelsWrap.scale.set(scale * way, scale);
    }
    
    _createWheels() {
        if(this._dataCar["elements"]["wheels"] && this._dataCar["body"]["wheels"]) {

            const s = 1 / this._dataCar["properties"]["scale"],
                  way = this.getWay() ? 1 : -1,
                  dtEL = this._dataCar["elements"]["wheels"],
                  dtPh = this._dataCar["body"]["wheels"],
                  data = dtEL[0] instanceof Array ? dtEL[this.getShopData()["wheels"][1] - 1 || 0] : dtEL,
                  dataP = dtPh[0] instanceof Array ? dtPh[this.getShopData()["wheels"][1] - 1 || 0] : dtPh,
                  wheelsData = this._correctData.wheels,
                  p0 = {x: 0, y: 0};
            
            let front = null;

            for(let i = data.length - 1; (i | 0) > -1; i-=1) {
                const cwd = wheelsData[i] || {},
                      f = data[i].front ? 2.9 : s,
                      wheel = new Phaser.Image(this.game, 0, 0, data[i].image, data[i].frame);
                
                //wheel.scale.set(data[i].radius * box2d.SCALE / (this.game.cache.getImage(data[i].image).width));
                if(data[i].front) {
                    wheel.scale.set(1.5);
                }
                
                if(data[i].anim) {
                    this._createFrameAnim(wheel, data[i].anim, true, true);
                }
                
                wheel.anchor.set(0.5);
                
                wheel.position.set(p0.x + cwd.x * f * way, p0.y + cwd.y * f);
                
                
                if(data[i].front) {
                    if(!front) {
                       front = this.getWrap();
                       this.addChild(front);
                    }
                    front.addChild(wheel);
                    
                } else {
                    this._wheelsWrap.addChild(wheel);
                }
                
                //this._wheels.push(wheel);
            }

        }
    }
};;DP3.StaticEnemy = class extends DP3.CarSprite {
    constructor(prop = {}) {
        super(prop);
    }
    
    update(self, dt, start) {
        super.update(self, dt, start);
        
        this._aimAI(self);
    }
};;DP3.Turret = class extends DP3.Image {
    constructor(prop = {}) {
        super(prop.game, 0, 0);
        this.game = prop.game;
        this.car = prop.car || null;
        
        if(this.car)this._posScale = this.car._posScale;
        
        if(!prop.data)return;
        this._init(prop.data);
        this._create(prop.data);
    }
    
    _init(data) {
        this._carriages = [];
        this._guns = [];
        this._decor = [];
        this._side = "right";
        this._direction = data.direction || 1;
        this._directionBlock = data.directionBlock || false;
    }
    
    getTarget() {
        if(this._carriages[0])return this._carriages[0].getTarget();
    }
    
    fillAll(color = 0xffffff) {
        const setTint = function f(elem, c) {
              if(elem.children && elem.children.length > 0) {
                  for(let i = 0, arr = elem.children, l = arr.length; (i | 0) < l; i+=1) {
                      f(arr[i], c);
                  }
              }

              elem.tint = c;
          };
        
        setTint(this, color);
    }
    
    _create(data) {
        if(data["image"]) {
            const img = this._createElement(data);
            
            img.alpha = 1;

            img.position.set(0,0);
            this._image = img;
            this.addChild(img);
        }

        if(data.position) {
            this.position.set(data.position[0], data.position[1]);
        }
        
        if(data.carriages) {
            this._createCarriages(data.carriages);
        }
        
        if(data.guns) {
            this._createGuns(data.guns);
        }
        
        this._createDecore(data.decore);
    }
    
    _createGuns(data) {
        if(!data)return;
        for(let i = 0, arr = data, l = arr.length; (i | 0) < l; i+=1) {
            this._createGun(arr[i]);
        }
    }
    
    _createGun(data) {
        const gun = new DP3.Gun(this.game, this.car, data, this);
        
        this._guns.push(gun);
        
        if(data.front) {
            this.addChild(gun);
        } else {
            this.addChildAt(gun, 0);
        }
    }
    
    getCarriages() {
        return this._carriages;
    }
    
    getBulletAngle() {
        return 0;
    }
    
    _createCarriages(data) {
        for(let i = 0, arr = data, l = arr.length; (i | 0) < l; i+=1) {
            this._createCarriage(arr[i]);
        }
                    
    }
    
    _createCarriage(data) {
        const elm = new DP3.Carriage(this.game, this.car, data);
        
        //!!!!!
        elm.position.x*=this._posScale;
        elm.position.y*=this._posScale;
        
        this._carriages.push(elm);
        
        if(data.front) {
            this.addChild(elm);
        } else {
            this.addChildAt(elm, 0);
        }
    }
    
     _createDecore(arr = []) {
        for(let i = 0, l = arr.length; (i | 0) < l; i+=1) {
            const data = arr[i];
            
            const elm = this._createElement(data);
        
            if(data["animation"]) {
                elm._anim = this._createFrameAnim(elm, data["animation"]["name"], data["animation"]["start"], data["animation"]["loop"]);
            }

            if(data.front) {
                this.addChild(elm);
            } else {
                this.addChildAt(elm, 0);
            }
        }
    }
    
    setDirection(direction = 1, side) {
        if(this._directionBlock)return;
        this._direction = (direction === 1) ? 1 : -1;
        
        this.scale.x = direction;
        
        this._side = side;
        
        for(let i = 0, arr = this._carriages, l = arr.length; (i | 0) < l; i+=1) {
            arr[i].side = side;
        }
    }
    
    getSide() {
        return this._side;
    }
    
    update(self, dt) {
        for(let i = 0, arr = this._carriages, l = arr.length; (i | 0) < l; i+=1) {
            arr[i].update(self, dt);
        }
        
        for(let i = 0, arr = this._guns, l = arr.length; (i | 0) < l; i+=1) {
            arr[i].update(self, dt, true);
        }
    }
};;DP3.Wheel = class extends DP3.Body {
    constructor(settings) {
        let prop = settings || {};
        super(prop);
        
        this.data = {
            spriteRadius: (prop.spriteRadius * 29 / 30) || 10,
            image: prop.image || "",
            frame: prop.frame || "",
            speed: prop.speed || 10, 
            twist: prop.twist
        };
        
        this.dynamicMode();
        
        if(prop.anim) {
            this._createFrameAnim(this, prop.anim, true, true);
        }
        
        this._draw();
    }
    
    motor(value) {
        this._body.SetAngularVelocity(Number(value) * this.data.speed);
    }
    
    getDump() {
        return this._dump;
    }
    
    _draw() {
        this.loadTexture(this.data.image);
        this.frameName = this.data.frame;
        this.scale.set(this.data.spriteRadius * box2d.SCALE / (this.game.cache.getImage(this.data.image).width));
        this.anchor.set(0.5);
    }
    
    update() {
        if(this.data.twist) {
            super.update();
        } else {
            if(this._body) {
                let p = this._body.GetPosition();

                this.position.set(p.x * box2d.SCALE, p.y * box2d.SCALE);
                this.rotation = this._body.GetLinearVelocity().x / 30;
            }
        }
    }
};//Main logic
DP3.Game = class {
    constructor() {
        this.init();

        this._frameDelta = 0;

        h5branding.Branding.analyticsEnabled = true;
        h5branding.SplashLoader.getInstance({
            gameId: 'd3285e53f8e14f6ab47c4a35d9fd2530',
            gameName: DP3.title,
            gameTitle: DP3.title,
            libs: [],
            version: version
        }).create();

        const format = this.isIE() ? "eot" : "otf";

        this.loadFonts([
            {
                name: "F3theHardwayRMX",
                url: '/fonts/F3theHardwayRMX.' + format + DP3.cachebuster
            },
            {
                name: "Century Gothic Bold",
                url: '/fonts/CenturyGothicBold.' + format + DP3.cachebuster
            },
            {
                name: "Arial Black",
                url: '/fonts/ArialBlack.' + format + DP3.cachebuster
            },
            {
                name: "F321impact",
                url: '/fonts/F321impact.' + format + DP3.cachebuster
            }
        ],
        () => {
            this.create();
        });
    }

    isIE() {
        var ua = window.navigator.userAgent.toLowerCase();
        return (/trident/gi).test(ua) || (/msie/gi).test(ua);
    }

    loadFonts(fonts, cb) {
        if (!fonts || !fonts.length) {
            if(cb) {
                cb();
            }
            return Promise.resolve();
        }

        var container = document.getElementsByTagName('head')[0];
        var observer = [];

        for (var i = 0; (i | 0) < fonts.length; i++) {
            var font = fonts[i];

            var s = document.createElement('style');
            s.type = "text/css";
            s.appendChild(document.createTextNode("@font-face {font-family: " + font.name + "; src: url(" + this.basePath + font.url + ");" + "}"));

            container.appendChild(s);

            observer.push(new FontFaceObserver(font.name).load());
        }

        return Promise.all(observer).then(cb, function(err) {
            console.warn("Failed to load font", err);
            if(cb) cb();
        });
    }

    init() {
        ///test
        this.counter = 0;

        this.status = false;

        this.data = {
            width: 800,
            height: 600,
            mainScale: 1,
            protSize: {
                width: 1960,
                height: 1280
            }
        };

        this.data.mainScale = (this.data.width / this.data.protSize.width);

        this.user = new DP3.User();

        //path
        let pathArray = window.location.pathname.split( '/' );

        this.basePath = window.location.origin + pathArray.splice(0, pathArray.length - 1).join('/');
    }

    create() {

        this.game = new Phaser.Game({
            width: 800,
            height: 600,
            renderer: Phaser.AUTO,
            antialias: true,
            transparent: false,
            enableDebug: false,
            mspointer: false,
            state: {
                ///FPS
                render: () => {
                    if(this.game.time && !this.game.debug.isDisabled) {this.game.debug.text('FPS: ' + this.game.time.fps, 40, 40, "#00ff00"); this.game.time.advancedTiming = true;}
                },
                preload: () => {
                    this._canvasCtrl();
                    this.game.clearBeforeRender = false;
                    this.game.renderer.clearBeforeRender = false;
                    const device = this.game.device;
                    this.game.isMobile = !!(device.iOS || device.mobileSafari || device.webApp || device.android);
                    this.sound = new DP3.SoundController(this.game);

                    this.game.plugins.add(PhaserCachebuster.CacheBuster);

                    h5branding.gameanalytics.setup(DP3.gameKey, DP3.secret, version);

                    h5branding.google.setup(DP3.googleID, DP3.googleGameName, version);
                    h5branding.google.sendScreenView('splash');

                    var phaserAdProvider;
                    var adProvider = new h5ads.GameDistribution('d3285e53f8e14f6ab47c4a35d9fd2530');

                    this.game.load.cacheBuster = (typeof version === 'undefined') ? null : version;

                    h5ads.adWrapper.setAdProvider(adProvider);
                    this.game.load
                        .image("icobtn_001", "res/images/icobtn_001.png")
                        .image("start_logo", "res/images/start_logo.png");

                    this.loader = new DP3.Loader({
                        game: this.game,
                        json: "./res/resources.json",
                        pacRes: "./res/pacRes.json",
                        basePath: this.basePath + "/res",
                        sound: this.sound, onLoad: this.loadComplete.bind(this)});
                },
                create: () => {
                    this.game.paused = true;
                    this.game.scale.trackParentInterval = 1;
                },
                update: (e) => {
                    this.update(e.time.elapsedMS);
                }
            }
        });
    }

    _create_debug_fps() {
        const text = new Phaser.Text(this.game, 0, 0, "test", {fontSize: 24, fontWeight: "bold", fill: "#2bde00", stroke: "#000000", strokeThickness: 2});
        this._debugFps = text;
        text.fixedToCamera = true;
        this.game.add.existing(text);
    }

    _canvasCtrl() {
        const scale = this.game.scale;

        if(!scale)return;

        scale.setMinMax(1, 1, 800, 600);

        scale.scaleMode = Phaser.ScaleManager.USER_SCALE;

        scale.pageAlignHorizontally = true;
        scale.pageAlignVertically = true;

        scale.setResizeCallback(this.gameResized, this);
    }

    gameResized(manager) {
        const scale = Math.min(
            Math.min(window.innerWidth, window.outerWidth) / this.game.width,
            Math.min(window.innerHeight, window.outerHeight) / this.game.height
        );

        manager.setUserScale(scale, scale);
    }

    calculLevelMoney() {
        const user = this.user;
        user.addTo(user.getLevelData().money, "money");
        user.addTo(user.getLevelData().money, ["stats", "earned"]);
    }

    calculLevelScore() {
        const user = this.user,
              data = user.getLevelData();

        user.setRecordFrom(data.num, data.score);
    }

    calculDistance() {
        const user = this.user,
              data = user.getLevelData();

        user.addTo(data.distance, ["stats", "distance"]);
    }

    createLevel() {
        if(!this.levelCore) {
            this.levelCore = new DP3.LevelCore({
                game: this.game,
                sound: this.sound,
                user: this.user,
                width: this.data.protSize.width,
                height: this.data.protSize.height,
                callbacks: {
                    "failed": (type) => {
                        this.openMenuFinish(false, type);
                    },
                    "complete": () => {
                        this.openMenuFinish(true);
                    },
                    "addLoot": (x, y, type) => {
                        if(this.uiCore) {
                            this.uiCore.addLootAnim(x, y, type);
                        }
                    },
                    "girlTalk": (text, type) => {
                        if(this.uiCore) {
                            this.uiCore.girlTalk(text, type);
                        }
                    }
                }
            });
        }
        this.mainWrap.addChild(this.levelCore);
        return this.levelCore;
    }

    getUser() {
        return this.user;
    }

    updateShopData() {
        if(this.levelCore)this.levelCore.setShopData(this.getShopData());
    }

    _createBG() {
        const bg = this.getBGGraphics();
        bg.fixedToCamera = true;
        this.fillBg = bg;
        //this.mainWrap.addChild(this.uiCore);
        this.game.add.existing(bg);
    }

    _removeLogo() {
        if(this.logo) {
            this.logo.destroy();
            this.logo = null;
        }
        if(this.splashBtn) {
            this.splashBtn.destroy();
            this.splashBtn = null;
        }
    }

    loadComplete() {
        this.status = true;
        this._removeLogo();
        this._createBG();
        this.createMainWrap();
        this.createLevel();
        this.uiCore = new DP3.UICore({
            game: this.game,
            core: this,
            callbacks: {
                "openMainMenu": this.openMainMenu.bind(this),
                "openCrossPromo": this.openCrossPromo.bind(this),
                "openLevelsMenu": this.openLevelsMenu.bind(this),
                "selectLevel": this.openLevel.bind(this),
                "openIntro": this.openIntro.bind(this),
                "restartLevel": this.restartLevel.bind(this),
                "openMenuPause": this.openMenuPause.bind(this),
                "playGame": this.closeMenuPause.bind(this),
                "nextLevel": this.nextLevel.bind(this),
                "playLevel": () => {this.levelCore.play();},
                "activeBoost": (num) => {
                    if(this.levelCore && this.levelCore.hero) {
                        this.levelCore.hero.activeBoost(num);
                    }
                }
            }
        });
        this.mainWrap.addChild(this.uiCore);
        this.mainWrap.addChild(this.loader);
        this.uiCore.fixedToCamera = true;
        this.loader.fixedToCamera = true;

        this.includePauseCtrl();

        this.sound.setVolumeMusic(this.user.getSetting("music"));
        this.sound.setVolumeSound(this.user.getSetting("sound"));

        this.sound.play("102_Menu_ms", true);
        this.sound.play("4_Wind_sn", true);

        //this.openLevel(1);
    }

    includePauseCtrl() {
        this.game.onPause.add(() => {
            if(this.levelCore && this.levelCore.status) {
                this.openMenuPause(false);
            }
        });

        this.game.onResume.add(() => {
            if(this.sound) {
                this.sound.crutchIOC13();
            }
        });
    }

    nextLevel(cb) {
        if(this.uiCore && this.levelCore) {
            const num = Number(this.levelCore.getNumLevel()) + 1,
                  user = this.getUser();
            if(num === 13 && Number(user.getStoryStep()) <= 12) {
                user.setStoryStep(13);
                this.openEndComix();
            } else if(num > 12) {
                this.openLevelsMenu();
            } else {
                this.uiCore.openBriefingMenu(num, cb);
            }
        }
    }

    openLevel(num) {
        h5branding.google.sendScreenView('gameplay');
        this.loader.loadPackages(["levelUI", "main3", "effects", "location" + Math.ceil(num / 3), "mission" + num, "missionContent" + num, "busterShop"], () => {
            this.uiCore.removeAllPages();
            this.user.createLevelData(num);
            this.uiCore.openLevelUIPage();
            this.updateShopData();
            this.levelCore.clearLevel();
            this.levelCore.createLevel(num || 1);
            this.playLevelSound(num);

            //DEBUG
            this.game.add.tween(this).to({}, 20, "Linear", true).onComplete.add(this.openTutor.bind(this, num));
        });
    }

    openTutor(num) {
        this.levelCore.pause();
        this.uiCore.openTutorPage(num);
    }

    playLevelSound(num = 1) {
        switch(Math.ceil(num / 3)) {
            case 2:
                this.sound.play("59_Loc2_sn", true);
                break;
            case 3:
                this.sound.play("58_Loc3_sn", true);
                break;
            case 4:
            case 5:
                this.sound.play("57_Loc4_sn", true);
                break;
           default:
                this.sound.play("66_Loc1_sn", true);
                break;
        }
    }

    includeHelper(num) {
        this.loader.loadPackages(["levelUI"], () => {
            let res = [],
                res1 = [],
                obj = {},
                pac = this.game.cache.getJSON("pacRes");

            for(let i = 0, l = 15; (i | 0) < l; i+=1) {
                let arr = pac["missionContent" + (i + 1)].slice(0);
                for(let j = 0, k = arr.length; (j | 0) < k; j+=1) {
                    let str = arr[j];
                    if(!obj[str] && str.split("_")[0] == "Dcr") {
                        let elem = obj[str] = {arr: str.split("_")};
                        let src = "res";
                        for(let n = 0, arr1 = elem.arr, m = arr1.length; (n | 0) < m; n+=1) {
                            src+=this.getSorcePathTo(arr1[n]);
                        }
                        elem.src = src;
                    }
                }
            }

            for(let key in obj) {
                res.push(key);
            }

            res.sort();
            res1 = res.splice(0, 100);
        });
    }

    getSorcePathTo(str) {
        let res = "";
        switch(str) {
            case "Dcr": res = "decore"; break;
            case "Bridge": res = "bridge"; break;
            case "Cave": res = "cave"; break;
            case "Colums": res = "columns"; break;
            default:
                if(Number(str) == str) {
                    return "_" + str
                } else {
                    res = str;
                }
        };

        return "/" + res;
    }

    getShopData(num = -1) {
        try {
            const user = this.getUser(),
                  money = user.getVariable("money"),
                  res = {
                      cars: user.getVariable("cars"),
                      shield: [],
                      motor: [],
                      "fuel tank": [],
                      wheels: [],
                      guns: [],
                      "rocket launcher": []
                  },
                  shop = user.getVariable('shop'),
                  select = num !== -1 ? num : res.cars.indexOf(2),
                  carsConfig = this.game.cache.getJSON("config").shop.cars,
                  config = carsConfig[select ? "corsair" : "predator"];

            if(!shop)return;

            for(let i = 0, arr = res.cars, names = ["predator", "corsair"], l = arr.length; (i | 0) < l; i+=1) {
                if(Number(arr[i]) === 0 && carsConfig[names[i]].cost <= money)arr[i] = 4;
            }

            for(let i = 0, arr = ["shield", "motor", "fuel tank", "wheels", "guns", "rocket launcher"], l = arr.length, j = select * l; (i | 0) < l; i+=1) {
                const name = arr[i],
                      elem = res[name],
                      data = shop[i + j],
                      anchor = data[0],
                      next = config[name][anchor];

                elem.push(anchor * 2 + (next ? (next.cost <= money ? 1 : 0) : 0));
                elem.push(data[1]);
            }

            return res;
        } catch (e) {
            return {};
        }
    }

    closeLevel() {
        this.levelCore.clearLevel();
    }

    openMainMenu() {
        if(DP3.sendMenuEvents) {
            h5branding.google.sendScreenView('main_menu');
            DP3.sendMenuEvents = false;
        }
        this.loader.loadPackage("main", () => {
            this.uiCore.removeAllPages();
            this.uiCore.openMainMenuPage();

            this.sound.play("102_Menu_ms", true);
            this.sound.play("4_Wind_sn", true);
        });
    }

    openCrossPromo() {
        this.loader.loadPackage("main2", () => {
            this.uiCore.removeAllPages();
            this.uiCore.openCrossPromoPage();

            this.sound.play("100_Interface_ms", true);
            this.sound.play("16_GalleryOpen_sn", false);
        });
    }

    openIntro() {
        if(this.getUser().getStoryStep() > 0) {
            this.openLevelsMenu();
            return;
        }

        this.getUser().setStoryStep(1);
        this.getUser().save();

        this.loader.loadPackage("intro", () => {
            this.uiCore.removeAllPages();
            this.uiCore.openIntro();

            this.sound.play("101_Comix_ms", true);
        });
    }

    openEndComix() {
        this.loader.loadPackage("final", () => {
            this.uiCore.removeAllPages();
            this.uiCore.openEndComix();

            this.sound.play("101_Comix_ms", true);
        });
    }

    openLevelsMenu() {
        this.loader.loadPackages(["main2", "main3"], () => {
            this.closeLevel();

            this.uiCore.removeAllPages();
            this.uiCore.openLevelsMenuPage();

            this.sound.play("100_Interface_ms", true);
            this.sound.play("16_GalleryOpen_sn", false);

            ///TEST
            //this.uiCore.openShop();
        });
    }

    restartLevel() {
        this.loader.loadPackages(["levelUI"], () => {
            if(this.levelCore && this.uiCore && this.user) {
                this.user.createLevelData(this.levelCore.getNumLevel());
                this.uiCore.removeAllPages();
                this.uiCore.openLevelUIPage();
                this.playLevelSound(this.levelCore.getNumLevel());
                this.updateShopData();
                this.levelCore.restart();
            }
        });

    }

    openMenuPause(anim = true) {
        if(this.levelCore && this.levelCore.data.status && !this.levelCore._end) {
            this.levelCore.pause();

            if(this.uiCore) {
                this.sound.pauseAll();
                this.uiCore.openMenuPause({level: this.levelCore.data.level}, anim);
            }
        }
    }

    openMenuFinish(win, type = 0) {
        if(this.levelCore) {
            this.levelCore.pause();

            if(this.uiCore) {
                const user = this.getUser();
                if(win) {
                    if(this.levelCore.data.level < 13) {
                        this.getUser().addTo(1, ["stats", "levels"]);
                    } else {
                        this.getUser().addTo(1, ["stats", "special"]);
                    }
                    this.getUser().setStoryStep((this.levelCore.data.level + 1) || 2);
                } else {
                    this.getUser().getLevelData().score = 0;
                }
                this.uiCore.openMenuFinish({level: this.levelCore.data.level, type: type}, win);
                this.calculLevelMoney();
                this.calculLevelScore();
                this.calculDistance();
                this.uiCore._calculStars();
                user.save();
            }
        }
    }

    closeMenuPause() {
        if(this.levelCore) {
            this.sound.resumeAll();
            this.levelCore.play();
        }
    }

    createMainWrap() {
        this.mainWrap = new Phaser.Sprite(this.game);
        this.game.add.existing(this.mainWrap);
    }

    getBGGraphics(color = 0x000000, alpha = 1) {
        let bg = new Phaser.Graphics(this.game, 0, 0);

        bg.beginFill(color, alpha);
        bg.drawRect(0, 0, 800, 600);
        bg.endFill();
        return bg;
    }

    update(e) {
        let limit = 1000 / 60,
            dt = e / 1000;

        if(this.fillBg)this.fillBg.scale.set(1 / this.game.camera.scale.x);


        if(this.levelCore && this.uiCore) {
            this.levelCore.update(dt, this.uiCore.getMobileData());
            this.uiCore.update();

            this.uiCore.scale.set(1 / this.game.camera.scale.x);
            this.loader.scale.set(1 / this.game.camera.scale.x);
        }

        if(this.loader)this.loader.update();
    }
};
;DP3.Ground = class extends Phaser.Image {
    constructor(settings) {
        super(settings.game);
        let conf = settings || {};
        
        this.game = conf.game || null;
        
        this.init(conf);
        
        this.create();
    }
    
    init(obj) {
        this.data = {
            points: this.changePoints(obj.points),
            lines: [],
            finish: 0,
            sf: 10, ///scale
            cacheLines: [],
            world: obj.world,
            density: 0.5,
            friction: 1,
            restitution: 0.2,
            texture: "textureLoc1",
            lineWidth1: 20,
            lineWidth2: 32,
            lineColor1: 0xfff,
            lineColor2: 0xfff,
            size: {
                width: 800,
                height: 600
            }
        };
    }
    
    create() {
        this.createPhysics();
        this.createMainWrap();
        this._createTexturesWrap();
    }
    
    setLevelData(prop = {}) {
        this.data.finish = prop.endPoint;
        
        let w = prop.width || 800,
            h = prop.height || 600;
        if(prop.lines) {
            this.data.lineWidth1 = prop.lines.width1 * 2;
            this.data.lineWidth2 = (prop.lines.width1 + prop.lines.width2) * 2;
            this.data.lineColor1 = prop.lines.color1;
            this.data.lineColor2 = prop.lines.color2;
        }
        this.clear();
        this._createGlobalBorder(w, h);
        //this._createMoveBorder(6500, h);
        //this._createFinishBorder(this.data.finish, h);
        this.data.size.width = w;
        this.data.size.height = h;
        this.setPoints(prop.points);
        this._texturesWrap.setTexture(prop.texture, prop.textureScale);
        
        //this.checkLines([0, 150]);
        this.checkLines(this.getNumPointsFrom(0, this.data.finish * box2d.SCALE));
    }
    
    createPhysics() {
        this.bodyDef = new box2d.b2BodyDef();
        this.bodyDef.type = box2d.b2Body.b2_staticBody;
        this.bodyDef.position.x = 0;
        this.bodyDef.position.y = 0;
        
        this._body = this.data.world.CreateBody(this.bodyDef);
        
        /*let test = this.getFixtureLine([{x: 0, y: 0}, {x: 0, y: 1200}]);
        let test1 = this._body.CreateFixture(test);*/
    }
    
    _createFinishBorder(x = 0, height) {
        if(this._finishBorder && this._finishBorder.GetWorld()) {
            this._finishBorder.GetWorld().DestroyBody(this._finishBorder);
        }
        
        let h = height || 1,
            hh = h / 2;
        
        const defBorder = new box2d.b2BodyDef();
        
        defBorder.type = box2d.b2Body.b2_staticBody;
        defBorder.position.x = x;
        defBorder.position.y = 0;
        
        const border = this.data.world.CreateBody(defBorder);
        
        border.CreateFixture(this.getFixtureLine([{x: 0, y: -hh}, {x: 0, y: hh}]));
        
        return (this._finishBorder = border);
    }
    
    _createBorder(width, height) {
        let w = width || 1,
            h = height || 1,
            hh = h / 2;
        
        const defBorder = new box2d.b2BodyDef();
        
        defBorder.type = box2d.b2Body.b2_staticBody;
        defBorder.position.x = 0;
        defBorder.position.y = 0;
        
        const border = this.data.world.CreateBody(defBorder);
        
        //left
        border.CreateFixture(this.getFixtureLine([{x: 0, y: -hh}, {x: 0, y: hh}]));
        //right
        border.CreateFixture(this.getFixtureLine([{x: w, y: -hh}, {x: w, y: hh}]));
        //top
        border.CreateFixture(this.getFixtureLine([{x: 0, y: -hh}, {x: w, y: -hh}]));
        //bottom
        border.CreateFixture(this.getFixtureLine([{x: 0, y: hh}, {x: w, y: hh}]));
        
        return border;
    }
    
    _createMoveBorder(w, h) {
        if(this._border && this._border.GetWorld()) {
            this._border.GetWorld().DestroyBody(this._border);
        }
        
        this._border = this._createBorder(w, h);
        
        return this._border;
    }
    
    _createGlobalBorder(w, h) {
        if(this._globalBorder && this._globalBorder.GetWorld()) {
            this._globalBorder.GetWorld().DestroyBody(this._globalBorder);
        }
        
        this._globalBorder = this._createBorder(w, h);
        
        return this._globalBorder;
    }
    
    getFixtureLine(arr) {
        let line = new box2d.b2FixtureDef();
        line.density = this.data.density;
        line.friction = this.data.friction;
        line.restitution = this.data.restitution;
        
        line.shape = new box2d.b2PolygonShape();
        line.shape.SetAsEdge(new box2d.b2Vec2(arr[0].x / box2d.SCALE, arr[0].y / box2d.SCALE), new box2d.b2Vec2(arr[1].x / box2d.SCALE, arr[1].y / box2d.SCALE));
        return line;
    }
    
    getY(x = 0) {
        let y = 0;
        
        if(this.data.points) {
            let p1 = this.data.points[0],
                p2 = this.data.points[1];
            
            for(let i = 1, arr = this.data.points, l = arr.length; (i | 0) < l; i+=1) {
                if(x < arr[i].x) {
                    p1 = arr[i - 1];
                    p2 = arr[i];
                    break;
                }
            }
            
            y = p1.y + ((x - p1.x) * ((p1.y - p2.y) / (p1.x - p2.x)));
        }
        
        return y;
    }
    
    createMainWrap() {
        let wrap = new Phaser.Image(this.game);
        this.addChild(wrap);
        this.mainWrap = wrap;
    }
    
    generFrame(pg, wg, hg, pp, wp) {
        //qwerty
        /*let x1 = pos,
            x2 = pos + w,
            arr = this.getNumPointsFrom(x1, x2);
        
        this.checkLines(arr);
        this.drawGround(arr);*/
        
        //this.checkLines(this.getNumPointsFrom(pp.x - wp / 2, pp.x + wp / 2));
        this.drawGround(this.getNumPointsFrom(pg.x - wg / 2, pg.x + wg / 2), pg.y + hg / 2);
    }
    
    drawGround(arr, low) { 
        if(this.data.points.length) {
            this.drawMask(arr, low);
            this.drawLines(arr);
        }
    }
    
    checkLines(arr) {
        let lines = this.data.lines;
        
        //remove
        for(let i = 0, l = lines.length; (i | 0) < l; ) {
            if(lines[i].num < arr[0] || lines[i].num > arr[1] - 1) {
                this.removeLine(i);
            } else {
                i+=1;
            }
        }
            
        //add
        for(let i = arr[0], l = arr[1] - 1; (i | 0) < l; i+=1) {
            let check = true;
            for(let j = 0, k = lines.length; (j | 0) < k; j+=1) {
                if(lines[j].num == i) {
                    check = false;
                    break;
                }
            }
            
            if(check) {
                let line = this.getLine();
                line.setData({num: i, points: this.getPointsFromLine(i)});
                line.create();
                this.addLine(line);
            }
        }
    }
    
    getPointsFromLine(num) {
        return [this.data.points[num], this.data.points[num+1]];
    }
    
    addLine(line) {
        if(line) {
            this.data.lines.push(line);
        }
    }
    
    removeLine(num) {
        this.data.lines[num].clear();
        this.data.cacheLines.push(this.data.lines[num]);
        this.data.lines.splice(num, 1);
    }
    
    getLine() {
        let line = null;
        
        if(this.data.cacheLines.length > 0) {
            line = this.data.cacheLines[this.data.cacheLines.length - 1];
            this.data.cacheLines.splice(this.data.cacheLines.length - 1, 1);
        } else {
            line = new DP3.GroundLine({ground: this, body: this._body});
        }
            
        return line;
    }
    
    drawLines(points) {
        let gr = this.getMainGraphics(),
            w1 = this.data.lineWidth1,
            w2 = this.data.lineWidth2,
            draw = function(gr, point0, point1, arr, lnst, w, h) {
                let p0 = point0 || 0,
                    p1 = point1 || arr.length;
                
                gr.lineStyle(w, lnst, 1);
                
                //
                gr.moveTo(arr[p0].x, arr[p0].y);
                
                for(let i = p0 + 1, l = p1; (i | 0) < l; i+=1) {
                    gr.lineTo(arr[i].x, arr[i].y);
                }
                
                //gr.lineTo(arr[p1].x, h);
                
            };
        
        gr.clear();
        //gr.beginFill(0xff00ff, 0);
        
        draw(gr, points[0], points[1], this.data.points, this.data.lineColor2, w2);
        draw(gr, points[0], points[1], this.data.points, this.data.lineColor1, w1);
        
        return gr;
    }
    
    clearWrapLines() {
        this.getMainGraphics().clear();
    }
    
    drawMask(points, low = 800) {
        let res = [],
            p0 = points[0] || 0,
            p1 = points[1] || 1,
            polygon = null,
            gr = this.getMainMask();
        
        gr.clear();
        
        res.push(new Phaser.Point(this.data.points[p0].x, low));
        for(let i = p0, arr = this.data.points, l = p1; (i | 0) < l; i+=1) {
            res.push(new Phaser.Point(arr[i].x, arr[i].y));
        }
        res.push(new Phaser.Point(this.data.points[p1].x, low));
        
        polygon = new Phaser.Polygon(res);
        
        gr.beginFill(0xFF33ff);
        gr.drawPolygon(polygon.points);
        gr.endFill();
        
        return gr;
    }
    
    clearMask() {
        this.getMainMask().clear();
    }
    
    getMainGround() {
        if(!this.mainGround) {
            this.mainGround = new Phaser.Image(this.game, 0, 0);
            this.addChild(this.mainGround);
        }
        
        return this.mainGround;
    }
    
    getMainMask() {
        let wrap = this.getMainGround();
        if(!wrap.mask) {
            wrap.mask = new Phaser.Graphics(this.game, 0, 0);
            this.addChild(wrap.mask);
        }
        
        return wrap.mask;
    }
    
    getTexturesWrap() {
        if(!this._texturesWrap) {
            this._createTexturesWrap();
        }
        
        return this._texturesWrap;
    }
    
    _createTexturesWrap() {
        this._texturesWrap = new DP3.GroundTexturesWrap({
                game: this.game,
                width: 800,
                height: 600,
                scaleTexture: 2
            });
        this.getMainGround().addChild(this._texturesWrap);
    }
    
    getMainGraphics() {
        if(!this.mainGraphics) {
            this.mainGraphics = new Phaser.Graphics(this.game, 0, 0);
            this.getMainGround().addChild(this.mainGraphics);
        }
        
        return this.mainGraphics;
    }
    
    getBody() {
        return this._body;
    }
                
    getNumPointsFrom(x1, x2) {
        let n1 = 0,
            n2 = 1,
            arr = this.data.points,
            l = arr.length;
        
        for(let i = 0; (i | 0) < l; i+=1) {
            if(x1 <= arr[i].x) {
                n1 = i - 1;
                break;
            }
        }
        
        if(n1 < 0) {
            n1 = 0;
        }
        
        for(let i = n1; (i | 0) < l; i+=1) {
            n2 = i + 1;
            if(x2 <= arr[i].x) {
                break;
            }
        }
        
        if(n2 >= l) {
            n2 = l - 1;
        }
        
        return [n1, n2];
    }
    
    clear() {
        this.data.points = [];
        this.removeAllLines();
        this.clearMask();
        this.clearWrapLines();
        
        this._texturesWrap.clear();
    }
    
    removeAllLines() {
        while(this.data.lines.length) {
            this.removeLine(0);
        }
    }
    
    setPoints(points) {
        this.data.points = this.changePoints(points);
    }
    
    changePoints(points) {
        let res = [];
        
        for(let i = 0, arr = points || [], l = arr.length; (i | 0) < l; i+=1) {
            res[i] = {
                x: arr[i].x * 30,
                y: arr[i].y * 30
            };
        }
        
        return res;
    }
    
    draw(pg, wg, hg, pp, wp) {
        //pg - graphics point(center)
        //wg - graphics width
        //hg - graphics height
        //pp - physics point
        //wp - physics width
        
        if(this._texturesWrap) {
            this._texturesWrap.update(pg, wg, hg);
        }
        
        /*if(this._border) {
            this._border.SetPosition({x: pp.x / box2d.SCALE, y: 0});
        }*/
        
        this.generFrame(pg, wg, hg, pp, wp);
    }
};;DP3.GroundLine = class {
    constructor(properties) {
        this.data = {
            body: null,
            ground: null
        };
        this.setData(properties);
        //this._createFixture();
    }
    
    setData(properties) {
        let prop = properties || {};
        
        this.num = prop.num || 0;
        this.data.points = prop.points || [{x: 0, y: 0}, {x: 0, y: 0}];
        
        if(prop.body) {
            this.data.body = prop.body;
        }
        
        if(prop.ground) {
            this.data.ground = prop.ground;
        }
    }
    
    create() {
        if(this.data.ground) {
            let line = new box2d.b2FixtureDef(),
                arr = this.data.points;
            line.density = this.data.ground.data.density;
            line.friction = this.data.ground.data.friction;
            
            //filter
            line.filter.categoryBits = 512;
            line.filter.maskBits = 1023;
            
            line.shape = new box2d.b2PolygonShape();
            line.shape.SetAsEdge(new box2d.b2Vec2(arr[0].x / box2d.SCALE, arr[0].y / box2d.SCALE), new box2d.b2Vec2(arr[1].x / box2d.SCALE, arr[1].y / box2d.SCALE));
            this.fixture = this.data.body.CreateFixture(line);
        }
    }
    
    /*_createFixture() {
        if(this.data.ground) {
            let line = new box2d.b2FixtureDef(),
                arr = this.data.points;
            line.density = this.data.ground.data.density;
            line.friction = this.data.ground.data.friction;
            
            //filter
            line.filter.categoryBits = 512;
            line.filter.maskBits = 1023;
            
            line.shape = new box2d.b2PolygonShape();
            line.shape.SetAsEdge(new box2d.b2Vec2(arr[0].x / box2d.SCALE, arr[0].y / box2d.SCALE), new box2d.b2Vec2(arr[1].x / box2d.SCALE, arr[1].y / box2d.SCALE));
            this.fixture = this.data.body.CreateFixture(line);
        }
    }
    
    create() {
        if(this.fixture) {
            const shape = new box2d.b2PolygonShape(),
                  arr = this.data.points;
            shape.SetAsEdge(new box2d.b2Vec2(arr[0].x / box2d.SCALE, arr[0].y / box2d.SCALE), new box2d.b2Vec2(arr[1].x / box2d.SCALE, arr[1].y / box2d.SCALE));
            this.fixture = shape;
            //console.log(this.fixture);
        }
    }*/
    
    clear() {
        this.data.body.DestroyFixture(this.fixture);
    }
};;DP3.GroundTexturesWrap = class extends Phaser.Sprite {
    constructor(properties) {
        let prop = properties || {};
        super(prop.game);
        this.game = prop.game;
        
        this._init(prop);
        this._draw();
    }
    
    _init(prop) {
        this.data = {
            texture: prop.texture || null,
            image: prop.texture ? this.game.cache.getImage(prop.texture) : null,
            width: prop.width || 1,
            height: prop.height || 1,
            dx: 0,
            scale: prop.scaleTexture || 1
        };
    }
    
    setTexture(texture, scale) {
        if(texture) {
            this.removeChildren();
            this.data.scale = scale || 1;
            this.data.texture = texture;
            this.data.image = this.game.cache.getImage(texture);
            this._draw();
        }
    }
    
    _draw() {
        if(this.data.texture) {
            const W = this.data.width,
                H = this.data.height,
                w = this.data.image.width * this.data.scale,
                h = this.data.image.height * this.data.scale,
                col = Math.ceil(W / w + 2),
                row = Math.ceil(H / h + 2),
                need = col * row,
                children = this.children,
                count = children.length;
            
            if(need > count) {
                for(let i = count, l = need; (i | 0) < l; i+=1) {
                    let elem = new Phaser.Image(this.game, 0, 0, this.data.texture);
                    elem.anchor.set(0.5, 0.5);
                    elem.scale.set(this.data.scale);
                    this.addChild(elem);
                }
            } else {
                for(let i = count, l = children.length; (i | 0) < l; i+=1) {
                    children[i].visible = false;
                }
            }

            for(let i = 0; (i | 0) < row; i+=1) {
                for(let j = 0; (j | 0) < col; j+=1) {
                    let elem = children[i * col + j];
                    elem.position.set(w * j, h * i);
                    elem.visible = true;
                }
            }
        }
    }
    
    setPos(p) {
        const image = this.data.image;
        if(image) {
            const s = this.data.scale;
            //this.position.x = this.data.image.width * this.data.scale * Math.floor(x / (this.data.image.width  * this.data.scale));
            
            this.position.set(image.width * s * Math.floor(p.x / (image.width  * s)), image.height * s * Math.floor(p.y / (image.height  * s)));
        }
    }
    
    _setSize(w = 800, h = 600) {
        this.data.width = w;
        this.data.height = h;
    }
    
    update(p, w, h) {
        this.setPos({x: p.x - w / 2, y: p.y - h / 2});
        this._setSize(w, h);
        this._draw();
    }
    
    clear() {
        this.removeChildren();
    }
};;DP3.Background = class extends Phaser.Image{
    constructor(settings) {
        super(settings.game,0,0);
        let conf = settings || {};
        this.game = settings.game;
        this.self = settings.self || null;
        
        this.data = {
            mainBack: null,
            scale: 1,
            width: conf.width || 800,
            height: conf.height || 600,
            cacheImages: []
        };
        
        this.create();
    }
    
    create() {
        this.createMainWrap();
        this.createMainBack();
        this.createFirstBack();
        this.createSecondBack();
    }
    
    createMainWrap() {
        this.mainWrap = new Phaser.Image(this.game, 0, 0);
    }
    
    createMainBack() {
        let back = new Phaser.Image(this.game, 0, 0);
        this.mainWrap.addChild(back);
        this.mainBack = back;
    }
    
    _getBack(scale) {
        const back = new Phaser.Image(this.game, 0, this.data.height);
        back.scale.set(0.4);
        back._scaleDef = 0.4;
        back._elements = [];
        back._cache = [];
        return back;
    }
    
    createFirstBack() {
        this.firstWrap = this._getBack(0.2);
        this.mainWrap.addChild(this.firstWrap);
    }
    
    createSecondBack() {
        this.secondWrap = this._getBack(0.2);
        this.mainWrap.addChild(this.secondWrap);
    }
    
    setBackData(prop) {
        this.clear();
        if(prop) {
            this.setMainBack(prop.mainBack);
            this._setDataWrap(this.firstWrap, prop.firstBack);
            this._setDataWrap(this.secondWrap, prop.secondBack, 0.7);
        }
        if(!this.mainWrap.parent) {
            this.addChild(this.mainWrap);
        }
    }
    
    setMainBack(str) {
        let image = this.game.cache.getImage(str);
        this.mainBack.scale.set(this.data.width / image.width);
        this.mainBack._scaleDef = this.data.width / image.width;
        this.mainBack.loadTexture(str);
    }
    
    _setDataWrap(wrap, images, anch) {
        if(wrap && images) {
            wrap._images = images.slice(0);
            wrap.removeChildren();
            wrap._elements = [];
            wrap._cache = [];
            wrap._anch = anch;
            
            wrap._widthEl = this.game.cache.getImage(wrap._images[0]).width;
        }
    }
    
    clear() {
        if(this.mainWrap && this.mainWrap.parent) {
            this.mainWrap.parent.removeChild(this.mainWrap);
            this.secondWrap.removeChildren();
            this.secondWrap.position.x = 0;
            this.firstWrap.removeChildren();
            this.firstWrap.position.x = 0;
        }
    }
    
    _moveWrap(wrap, pos, fx, fy, scale = 1, fs = 0) {
        if(wrap && pos) {
            let s = wrap._scaleDef + (scale - 1) * fs,
                f = s / wrap._scaleDef,
                x = -(pos.x || 0) * f * fx,
                y = -(pos.y || 0) * f * fy + this.data.height,
                p = wrap.position,
                z = wrap.scale.x;
            //wrap.position.set(x / scale, y / scale);
            wrap.position.set(p.x + (x - p.x) / 10, p.y + (y - p.y) / 10);
            wrap.scale.set(z + (s - z) / 10);
            this._stepWrap(wrap);
        }
    }
    
    _generateElement(wrap, num) {
        if(!(wrap && wrap._images))return;
        
        const images = wrap._images,
              n = num % images.length,
              w = this.game.cache.getImage(images[n]).width;
        let image = null;
        
        if(wrap._cache.length < 1) {
            image = new Phaser.Image(this.game, num * w, 0, images[n]);
        } else {
            image = wrap._cache.pop();
            image.position.set(num * w, 0);
            image.loadTexture(images[n]);
        }
        
        image.anchor.set(0, (wrap._anch || 1));
        image.imgNum = n;
        image.num = num;
        
        wrap._elements.push(image);
        wrap.addChild(image);
    }
    
    _deleteAllElements(wrap) {
        if(!wrap)return;
        while(wrap._elements.length) {
            this._deleteElement(wrap, wrap._elements.length - 1);
        }
    }
    
    _deleteElement(wrap, num = 0) {
        if(!wrap)return;
        const elem = wrap._elements.splice(num, 1)[0];
        if(elem.parent) {
            elem.parent.removeChild(elem);
        }
        wrap._cache.push(elem);
    }
    
    _stepWrap(wrap) {
        if(!(wrap && wrap._elements))return;
        const x = -wrap.position.x,
              w = wrap._widthEl,
              sw = w * wrap.scale.x,
              W = this.data.width,
              hW = W / 2,
              x0 = x - hW,
              x1 = x + hW,
              max = Math.ceil(x1 / sw) + 2,
              min = Math.max(0, Math.ceil(x0 / sw));
        
        this._deleteAllElements(wrap);
        
        for(let i = 0, cache = wrap._cache, l = max - min; (i | 0) < l; i+=1) {
            this._generateElement(wrap, i + min);
        }
    }
    
    draw(p, w) {
        const scale = this.game.camera.scale.x;
        
        this.scale.set(1/scale);
        
        this._moveWrap(this.firstWrap, p, 0.07, 0.05, scale, 0.01);
        this._moveWrap(this.secondWrap, p, 0.1, 0.07, scale, 0.02);
    }
};;DP3.Cache = class {
    constructor() {
        this.pool = {};
    }
    
    getElement(type) {
        if(this.pool.hasOwnProperty(type) && this.pool[type].length > 0) {
            return this.pool[type].pop();
        }
        
        return false;
    }
    
    addElement(type, elem) {
        if(!this.pool.hasOwnProperty(type)) {
            this.pool[type] = [];
        }
        
        this.pool[type].push(elem);
    }
    
    clear() {
        for(let key in this.pool) {
            const arr = this.pool[key];
            
            while(arr.length > 0) {
                const elem = arr.pop();
                if(elem && elem.destroy)elem.destroy();
            }
        }
        
        this.pool = {};
    }
};;DP3.ContentCore = class extends Phaser.Sprite {
    constructor(properties) {
        super(properties.game);
        let prop = properties || {};
        this.game = prop.game;
        this._level = prop.level;
        this.sound = prop.sound;
        this._world = prop.world;
        this.init();
        this._create();
    }
    
    init() {
        this.data = {
            lastCarX: 0,
            delta: 0,
            scenario: null,
            carList: [],
            decor: [],
            cars: [],
            explosions: [],
            loot: [],
            items: [],
            rectangles: [],
            scraps: [],
            bullets: [],
            burns: []
        };
        
        this.cache = new DP3.Cache();
        
        this.cameraData = {};
        this.__updateCameraData();
    }
    
    getCars() {
        return this.data.cars;
    }
    
    getLoot() {
        return this.data.loot;
    }
    
    getItems() {
        return this.data.items;
    }
    
    getDecor() {
        return this.data.decor;
    }
    
    getBurns() {
        return this.data.burns;
    }
    
    setScenario(scen) {
        
        if(scen) {
            this.data.scenario = scen;
        }
        
        this._ctrlScenario();
    }
    
    _createJoints(data = {x: []}) {
        for(let i = 0, j = data.x.length; (i | 0) < j; i+=1) {
            this._createJoint(new box2d.b2Vec2(data.x[i] / box2d.SCALE, data.y[i] / box2d.SCALE), data, i);
        }
    }
    
    _createRects(data = {x: []}) {
        const w = 10,
              h = 10,
              phScale = box2d.SCALE;
        
        for(let i = 0, l = data.x.length; (i | 0) < l; i+=1) {
            const hsw = w * data.scaleX[i] / 2 / phScale,
                  hsh = h * data.scaleY[i] / 2 / phScale,
                  rect = new DP3.Body({
                        game: this.game, 
                        world: this._world,
                        data: {
                            x: data.x[i],
                            y: data.y[i],
                            rotation: data.rotation[i],
                            fixtures: {
                                shape: {type: 1, points: [new box2d.b2Vec2(-hsw, -hsh), new box2d.b2Vec2(hsw, -hsh), new box2d.b2Vec2(hsw, hsh), new box2d.b2Vec2(-hsw, hsh)]},
                                density: 0.5,
                                friction: 1,
                                restitution: 0.7,
                                filter: {"categoryBits": 512, "groupIndex": 0, "maskBits": 1023}
                            }
                        }
                    });
            
            rect.staticMode();
            
            rect.update();
            
            this.data.rectangles.push(rect);
            this.front.addChild(rect);
        }
    }
    
    _createElements(scen, name, func) {
        if(!(scen && name && func))return;
        
        for(let key in scen) {
            const data = key.toLowerCase().split('_');
            if(data[0] === name) {
                func(key, scen[key], data);
            }
        }
    }
    
    _initCars(scen) {
        if(!scen)return;
        const cars = [];
            
        for(let key in scen) {
            let data = key.toLowerCase().split('_');
            
            if(data[0] === 'car' && !(data[1] === "pc" || data[2] === "jailcar") && (scen[key] && scen[key].x)) {
                
                for(let i = 0, arr = scen[key], l = arr.x.length; (i | 0) < l; i+=1) {
                    const res = {
                              x: arr.x[i],
                              y: arr.y[i],
                              name: key,
                              status: false,
                              rotation: arr.rotation[i],
                              way: arr.scaleX[i] > 0
                          };
                    cars.push(res);
                }
            }
        }

        cars.sort((a, b) => {return a.x - b.x});
            
        this.data.carList = cars;
    }
    
    _ctrlScenario() {
        const scen = this.data.scenario;
        
        if(!scen)return;
        
        this._createElements(scen, 'dcr', this._addDecor.bind(this));
        this._createElements(scen, 'itm', this._addItem.bind(this));
        this._createElements(scen, 'stt', this._addLoot.bind(this));
        this._createJoints(scen["Joint_mk"]);
        this._createRects(scen["Rect_st"]);
        
        //this._test_points(scen["Gunpoint_mk"]);
        
        this._initCars(scen);
    }
    
    _test_points(obj) {
        if(!obj)return;
        
        for(let i = 0, l = obj.x.length; (i | 0) < l; i+=1) {
            const elem = new Phaser.Image(this.game, obj.x[i], obj.y[i], "dialogBox1", "revardBlockStar_002.png");
            
            elem.anchor.set(0.5);
            
            this.front.addChild(elem);
        }
    }
    
    _createImage(key, x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0) {
        const image = new DP3.Image(this.game, x, y, key);
        image.scale.set(scaleX, scaleY);
        image.anchor.set(0.5, 0.5);

        image.rotation = (rotation / 180) * Math.PI;
        
        return image;
    }
    
    _createJoint(v, data, num) {
        let b1 = null,
            b2 = null,
            f = null,
            b = this._world.GetBodyList();
        
        /*const scale = box2d.SCALE,
              gr = new Phaser.Graphics(this.game, v.x * scale, v.y * scale);
        
        gr.beginFill(0xd000e2, 1);
        gr.lineStyle(0);
        gr.drawCircle(0, 0, 5);
        gr.endFill();
        this.addChild(gr);/**/
        
        while(b) {
            if(b.GetFixtureList()) {
                f = b.GetFixtureList();
                while (f){
                    if(f.TestPoint(v)) {
                        if(!b1) {
                            b1 = b;
                        } else if (!b2) {
                            b2 = b;
                        }
                    }
                    f = f.GetNext();
                }
            }
            b = b.GetNext();
        }
        
        const def = new box2d.b2RevoluteJointDef();
        
        if(!b1)return true;
        
        def.Initialize(b1, b2 ? b2 : this._world.GetGroundBody(), v);
        
        const joint = this._world.CreateJoint(def);
        
        joint._p = v;
        
        if(data.destroyed)joint._destructible = data.destroyed[num];
        
        return joint;
    }
    
    _addItem(key, elem, arr) {
        const name = arr.slice(1, arr.length).join("_");
        
        for(let i = 0, l = elem.x.length; (i | 0) < l; i+=1) {
            const item = new DP3.Item({game: this.game, world: this._world, key: key, data: {x: elem.x[i], y: elem.y[i], scaleX: elem.scaleX[i], scaleY: elem.scaleY[i], rotation: elem.rotation[i]}});

            this._addElement(arr, item);
            
            this.data.items.push(item);
        }
    }
    
    _addLoot(key, elem, arr) {
        const name = arr.slice(1, arr.length).join("_");
        
        for(let i = 0, l = elem.x.length; (i | 0) < l; i+=1) {
            const image = this._createImage(key, elem.x[i], elem.y[i], elem.scaleX[i], elem.scaleY[i], elem.rotation[i]);
            
            image._loot_type = name;

            this._addElement(arr, image, true);
            
            this.data.loot.push(image);
        }
    }
    
    _addElement(data, elem, front = false) {
        if(!(data && elem))return;
        
        if(front) {
            this.front.addChild(elem);
        } else {
            if(data.indexOf("front") !== -1) {
                this.front.addChild(elem);
            } else if(data.indexOf("back") !== -1) {
                this.back.addChild(elem);
            } else {
                this.mainWrap.addChild(elem);
            }
        }
    }
    
    _addDecor(key, elem, arr) {
        for(let i = 0, l = elem.x.length; (i | 0) < l; i+=1) {
            const image = this._createImage(key, elem.x[i], elem.y[i], elem.scaleX[i], elem.scaleY[i], elem.rotation[i]);

            this._addElement(arr, image);
            
            this.data.decor.push(image);
        }
    }
    
    _create() {
        this.back = new Phaser.Sprite(this.game, 0, 0);
        this.addChild(this.back);
        
        this.mainWrap = new Phaser.Sprite(this.game, 0, 0);
        this.addChild(this.mainWrap);
        
        this.front = new Phaser.Sprite(this.game, 0, 0);
        this.addChild(this.front);
    }
    
    clear() {    
        for(let arr = this.data.cars, i = arr.length; (i | 0) > 0; i-=1) {
            this._deleteCar(i - 1);
        }
        
        this._clearElements();
        
        if(this.front) {
            this.front.removeChildren();
        }
        
        if(this.mainWrap) {
            this.mainWrap.removeChildren();
        }
        
        if(this.back) {
            this.back.removeChildren();
        }
        
        this._clearData();
        
        this.cache.clear();
    }
    
    _clearData() {
        this.data.cars = [];
        this.data.items = [];
        this.data.loot = [];
        this.data.decor = [];
        this.data.rectangles = [];
        this.data.bullets = [];
        this.data.burns = [];
    }
    
    _clearElements() {
        const data = [
            {arr: this.data.cars, func: "remove"},
            {arr: this.data.rectangles, func: "remove"},
            {arr: this.data.items, func: "remove"},
            {arr: this.data.scraps, func: "destroy"},
            {arr: this.data.decor, func: "destroy"},
            {arr: this.data.loot, func: "destroy"},
            {arr: this.data.explosions, func: "destroy"},
            {arr: this.data.bullets, func: "destroy"},
            {arr: this.data.burns, func: "destroy"}
        ];
        
        for(let i = 0, arr = data, l = arr.length; (i | 0) < l; i+=1) {
            for(let j = 0, arr1 = arr[i].arr, k = arr1.length; (j | 0) < k; j+=1) {
                (arr1[j][data[i].func])();
            }
            arr[i].arr.splice(0);
        }
    }
    
    _getUnitData(title) {
        const res = {car: true, name: "enemyHummer", class: title};
        
        if(title) {
            const arr = title.split('_');
            
            switch(arr[1].toLowerCase()) {
                case "infantry":
                    res.car = false;
                    if(arr[2] === "MG42") {
                        res.name = "enemyStaticInfantry";
                    } else {
                        res.name = "enemyStaticInfantryRocket";
                    }
                    break;
                case "flak":
                    res.car = false;
                    res.name = "enemyStaticCannon";
                    break;
                case "foe":
                    res.car = true;
                    switch(arr[2]) {
                        case "humvy":
                            res.name = "enemyHummer";
                            break;
                        case "heavyTruck":
                            res.name = "enemyHeavytruck";
                            break;
                        case "MT":
                            res.name = "bossMT";
                            break;
                        case "quadBike":
                            res.name = "enemyQuadBike";
                            break;
                        case "cougar":
                            res.name = "enemyCougar";
                            break;
                        case "pickUp":
                            res.name = "enemyPickup";
                            break;
                        case "lightCar":
                            res.name = "enemyLight";
                            break;
                        case "RV":
                            res.name = "enemyRecreation";
                            break; 
                        case "podBike":
                            res.name = "enemyPodBike";
                            break;
                        case "Shocker":
                            res.name = "enemyShock";
                            break;
                        case "muscle":
                            res.name = "enemyMuscle";
                            break;
                        case "snowBike2":
                            res.name = "enemyShowBike2";
                            break;
                        case "snowBike1":
                            res.name = "enemyShowBike1";
                            break;
                        case "hodRod":
                            res.name = "enemyHodrod";
                            break; 
                        case "monsterTruck":
                            res.name = "enemyMonsterTruk";
                            break;
                        case "tanker":
                            res.name = "enemyTanker";
                            break;
                        case "Bike":
                            res.name = "enemyBike";
                            break;
                    }
                    break;
                case "boss":
                    res.car = true;
                    switch(arr[2]) {
                        case "COT":
                            res.name = "bossCot";
                            break;
                        case "Secator":
                            res.name = "bossSecator";
                            break;
                        case "Tank":
                            res.name = "bossTank";
                            break;
                    }
                    break;
                case "npc":
                    res.car = true;
                    res.name = "enemyBuggie";
                    break;
                case "foe91":
                    res.car = true;
                    res.name = "enemyNomad";
                    break;
                case "alligator":
                    res.car = true;
                    res.name = "enemyAligator";
                    break;
                default:
                    break;
            }
        }
        
        return res;
    }
    
    _deleteCar(num) {
        const elem = this.data.cars.splice(num, 1)[0];
        
        if(elem instanceof DP3.CarPhysics) {
            elem.destr();
        } else {
            elem.remove();
        }
    }
    
    getUser() {
        return this._level.user;
    }
    
    getLevelData() {
        return this.getUser().getLevelData();
    }
    
    addScore() {
        const data = this.getLevelData();
        if(data)data.score+=1;
    }
    
    addMoney(value = 0) {
        const data = this.getLevelData();
        if(data)data.money+=value;
    }
    
    _killCar(num) {
        const elem = this._removeCar(num),
              pos = elem.getPosition(),
              scale = elem.getMainScale(),
              body = elem._body,
              end = elem._endDamage,
              user = this.getUser();
        this.addExplosion(pos.x, pos.y, 0.5);
        this.addMoney(Number(elem.getPrice()));
        this._sndExplosionCar(elem.getClassName());
        
        if(end && end.car instanceof DP3.Car) {
            if(end.isRocket) {
                user.addTo(1, ["stats", "rocketeer"]);
            } else if(end.isBurn) {
                user.addTo(1, ["stats", "arsonist"]);
            } else {
                user.addTo(1, ["stats", "gunner"]);
            }
        }
        
        this.addScore();
        
        if(elem instanceof DP3.StaticEnemy || elem instanceof DP3.Enemy) {
            this.getUser().addTo(1, ["stats", "killed"]);
            
            if(elem.visible) {
                const p = elem._frontWrap.worldPosition;
                this.addLootAnim(p.x, p.y, "car");
            }
        }
        
        if(elem.visibleScaps) {
            const scraps = elem.getScraps();
            
            if(scraps && scraps.length > 0) {
                for(let i = 0, arr = scraps, l = arr.length; (i | 0) < l; i+=1) {
                    const scrap = scraps[i];
                    let image;
                    
                    if(elem.getClassName() === "Car_FOE_heavyTruck_3lp" && (Number(scrap.name.split("").pop()) > 3)) {
                        image = "enemyHeavytruck2";
                    } else {
                        image = elem.getMainImage();
                    }
                    
                    this._addScrap(scrap.x * scale.x + pos.x, scrap.y * scale.y + pos.y, image, new Phaser.Point(body ? body.GetLinearVelocity().x / 3 : (Math.random() * 20 - 10), Math.random() * -10), scrap.name + ".png", scale);
                }
            }
        }
        
        this.__killAndSaveCarsX(elem);
    }
    
    __killAndSaveCarsX(car) {
        if(car && car instanceof DP3.CarPhysics) {
            this.data.lastCarX = car.kill(this.data.lastCarX);
        }
    }
    
    _removeCar(num) {
        const car = this.data.cars.splice(num, 1)[0];
        this.cache.addElement(car.getClassName(), car);
        return car;
    }
    
    _sndExplosionCar(name) {
        if(name && this.sound){
            if (name.search("Bike")) {
                this.sound.play("117_MotoExp_sn");
            }
            switch(name) {
                case "Car_BOSS_COT_3lp":
                case "Car_BOSS_Secator_3lp":
                case "Car_BOSS_Tank_3lp":
                    this.sound.play("115_BigCarExp_sn");
                    break;
                /*case "Car_FOE_shocker":
                    Snd.Stop("Sparks_sn");
                    break;*/
                default:
                    this.sound.play("117_MotoExp_sn");
                    break;
            }
        }
    }
    
    addExplosion(x = 0, y = 0, s = 1) {
        //return;
        const expl = new DP3.ExplosionCanvas({game: this.game, scale: s, x: x, y: y, sound: this.sound});
        this.front.addChild(expl);
        this.data.explosions.push(expl);
        
        this._level.addQuake(20, 2);
    }
    
    _ctrlExplosions(dt) {
        for(let i = 0, arr = this.data.explosions; (i | 0) < arr.length; i+=1) {
            const elem = arr[i];
            if(elem.live) {
                elem.update(dt);
            } else {
                if(elem.parent) {
                    elem.parent.removeChild(elem);
                }
                arr.splice(i, 1);
                i-=1;
            }
        }
        
        return;
        //test
        if(this.data.explosions.length > 2)return;
        
        const pos = this._level._cameraPoint.position,
              camera = this.game.camera,
              cs = 1 / camera.scale.x,
              r = camera.height * cs * Math.random() / 2,
              L = Math.random() * Math.PI * 2;
        
        this.addExplosion(r * Math.cos(L) + pos.x, r * Math.sin(L) + pos.y, 0.5);
    }
    
    _ctrlItems() {
        for(let i = 0, arr = this.data.items; (i | 0) < arr.length; i+=1) {
            const elem = arr[i];
            
            if(elem._live) {
                elem.update();
            } else {
                const name = elem.getName(),
                      scraps = elem.getScraps();
                
                if (name == "Itm_box_08") {
					this.sound.play("BarrelCrash_sn");
				}else if (name.search("brick") != -1){
					this.sound.play("Brick_sn");
				}else if (name.search("barrel") != -1 || name.search("Barrel") != -1) {
					this.sound.play("BarrelCrash_sn");
				}else if (name.search("box") != -1) {
					this.sound.play((["BoxCrush_sn", "BoxCrush2_sn", "BoxCrush3_sn"])[Math.round(Math.random() * 2)]);
				}
                /*
                var impulce:Point;
				if (_bulHit) {
					impulce = new Point(Bullet.vec.x - 3 + Math.random() * 6,  -2 - Math.random() * 2);
				}else {
					impulce = new Point( _body.GetLinearVelocity().x / 5 - 3 + Math.random() * 6, -2 - Math.random() * 2)
				}*/
                //Scraps    
                //new rcStaticScrap(Dmath.getClassName(_scraps[0]) , _x + _scraps[0].x, _y + _scraps[0].y, impulce);  
                
                if(scraps) {
                    const body = elem._body,
                          s = elem.scale;
                    
                    for(let j = 0, k = scraps.length; (j | 0) < k; j+=1) {
                        const scrap = scraps[j],
                              impulce = new Phaser.Point( body.GetLinearVelocity().x / 5 - 3 + Math.random() * 6, -2 - Math.random() * 2);
                        impulce.x*=1.8;
                        impulce.y*=1.8;
                        this._addScrap(elem.position.x + scrap.x * s.x, elem.position.y + scrap.y * s.y, scrap.name, impulce);
                    }
                }
                
                arr.splice(i, 1);
                i-=1;
            }
            
            if(this._checkBombItem(elem)) {
                this.addExplosion(elem.position.x, elem.position.y, 0.5);
                this.sound.play("68_BombExplosion_sn");
                if(elem._live) {
                    elem.kill();
                }
            }
        }
    }
    
    _checkBombItem(elem) {
        if(!elem || (elem._live && !elem.visible))return false;
        
        const data = elem.getBombData();
        
        if(data && data.power > 0) {
            const p0 = this._level.getHero().getPosition(),
                  p1 = elem.position,
                  d = Math.sqrt(Math.pow(p0.x - p1.x, 2) + Math.pow(p0.y - p1.y, 2));
            if(d < data.distance || data.touch < 0 || p0.x > p1.x) {
                if (data.time-- < 0) {
                    this._level.addImpulse(p1.x / box2d.SCALE, p1.y / box2d.SCALE, data.power / 50);
					return true;
				}
            } else if(!elem._live) {
                this._level.addImpulse(p1.x / box2d.SCALE, p1.y / box2d.SCALE, data.power / 50);
                return true;
            }
        }
        
        return false;
    }
    
    _getScrap() {
        let scrap = this.cache.getElement("Scrap");
        if(!scrap) {
            scrap = new DP3.Scrap(this.game);
        }
        return scrap;
    }
    
    _removeScrap(scrap) {
        scrap.kill();
        this.cache.addElement("Scrap", scrap);
    }
    
    _addScrap(x = 0, y = 0, name, impulce, key, scale) {
        //const scrap = new DP3.Scrap({game: this.game, x: x, y: y, name: name, impulce: impulce, key: key});
        const scrap = this._getScrap();
        
        scrap.setData({x: x, y: y, name: name, impulce: impulce, key: key});
        
        if(scale) {
            scrap.scale.set(scale.x, scale.y);
        }
        
        this.mainWrap.addChild(scrap);
        this.data.scraps.push(scrap);
    }
    
    _ctrlScraps(dt) {
        for(let i = 0, arr = this.data.scraps; (i | 0) < arr.length; i+=1) {
            const elem = arr[i]
            if(elem._live) {
                elem.update(dt);
            } else {
                arr.splice(i, 1);
                this._removeScrap(elem);
                i-=1;
            }
        }
    }
    
    _ctrlLoot() {
        const hero = this._level.hero,
              ally = this._level.ally,
              p = hero.getPosition(),
              p2 = ally ? ally.getPosition() : null;
        for(let i = 0, arr = this.data.loot; (i | 0) < arr.length;) {
            const elem = arr[i],
                  p1 = elem.position;
            
            if(p2 && elem._loot_type == "repair" && (Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)) < 85)) {
                ally.addHealth(10000);
                this.sound.play("28_Repair_sn");
                this.getUser().addTo(1, ["stats", "repairC"]);
                
                if(elem.parent) {
                    elem.parent.removeChild(elem);
                }
                arr.splice(i, 1);
                
            } else if(elem.visible && Math.sqrt(Math.pow(p.x - p1.x, 2) + Math.pow(p.y - p1.y, 2)) < 85) {
                switch(elem._loot_type) {
                    case "coin_static":
                        this.sound.play("84_Cash_sn");
                        this.addMoney(20);
                        this.getUser().addTo(1, ["stats", "moneyC"]);
                        break;
                    case "repair":
                        hero.addHealth(10000);
                        this.sound.play("28_Repair_sn");
                        this.getUser().addTo(1, ["stats", "repairC"]);
                        break;
                    case "amunition":
                        hero.addBomb(3);
                        this.sound.play("29_Reload_sn");
                        break;
                    case "fuel":
                        hero.addFuel(100);
                        this.sound.play("65_Fuel_sn");
                        this.getUser().addTo(1, ["stats", "fuelC"]);
                        break;
                    default:
                        break;
                }
                
                this.addLootAnim(elem.worldPosition.x, elem.worldPosition.y, elem._loot_type);
                
                if(elem.parent) {
                    elem.parent.removeChild(elem);
                }
                arr.splice(i, 1);
            } else {
                i+=1;
            }
        }
    }
    
    addLootAnim(x, y, type) {
        if(this._level.callbacks.addLoot)this._level.callbacks.addLoot(x, y, type);
    }
    
    _checkBurnsTo(car) {
        if(!car)return;
        
        const rect = car.getRect(),
              b = rect.bottom + 50,
              l = rect.left,
              r = rect.right,
              t = rect.top;
        
        for(let i = 0, arr = this.getBurns(), l = arr.length; (i | 0) < l; i+=1) {
            const burn = arr[i],
                  pos = burn.position;
            
            if(pos.x >= l && pos.x <= r && pos.y >= t && pos.y <= b) {
                car.damage(burn.getDamage()  || 1);
                car._endDamage = burn;
            }
        }
    }
    
    getBullet() {
        let bullet = this.cache.getElement("bullet");
        if(!bullet) {
            bullet = new DP3.Bullet(this.game);
        }
        return bullet;
    }
    
    removeBullet(bullet) {
        if(!bullet)return;
        bullet.kill();
        this.cache.addElement("bullet", bullet);
    }
    
    addBullet(obj) {
        if(obj) {
            const bullet = this.getBullet();
            
            bullet.setData(obj);
            
            this.data.bullets.push(bullet);
            
            this.addChild(bullet);
        }
    }
    
    _bulletHitCheck(bullet, targets) {
        if(!bullet || !targets)return;
        
        const rect1 = bullet.getRect(),
              pos1 = bullet.position;
        
        for(let i = 0, arr = targets, l = arr.length; (i | 0) < l; i+=1) {
            const elem = arr[i];
            
            if(elem._type === bullet._type)continue;
            
            const rect2 = elem.getRect(),
                  pos2 = elem.getPosition();
            
            if((Math.abs(pos1.x - pos2.x) <= (rect2.width / 2 - rect1.width / 2)) && (Math.abs(pos1.y - pos2.y) <= (rect2.height / 2 - rect1.height / 2))) {
                return elem;
            }
        }
        
        return false;
    }
    
    bulletsUpdate(dt) {
        const targets = this.data.cars.concat(this.data.items.filter((elem) => {
            return (elem._visible && elem._destructible);
        }));
        
        for(let i = 0 , arr = this.data.bullets; (i | 0) < arr.length;) {
            const bullet = arr[i],
                  hit = this._bulletHitCheck(bullet, targets);
            
            if(hit && hit.health > 0) {
                hit._endDamage = bullet;
                hit.damage(bullet._damage);
            }
            
            if(hit || bullet.getLifeTime() <= 0) {
                arr.splice(i, 1);
                
                if(bullet.isRocket && hit) {
                    const pos = bullet.getPosition();
                    this.addExplosion(pos.x, pos.y, 0.25);
                }
                
                this.removeBullet(bullet);
            } else {
                bullet.update(dt);
                this.__checkElement1(bullet);
                i+=1;
            }
        }
    }
    
    _getBurn(type = 1) {
        let burn = this.cache.getElement("Burn");
        if(!burn) {
            burn = new DP3.Burn(this.game, this._level.getHero(), type);
        }
        return burn;
    }
    
    _removeBurn(burn) {
        burn.kill();
        this.cache.addElement("Burn", burn);
    }
    
    addBurn(x = 0, y = 0, type = 1) {
        const burn = this._getBurn(type);
        
        burn.setData({
            x: x,
            y: y
        });
        
        this.data.burns.push(burn);
        this.front.addChild(burn);
    }
    
    _ctrlBurns(dt) {
        for(let i = 0, arr = this.data.burns; (i | 0) < arr.length; ) {
            const burn = arr[i];
            
            if(burn.status) {
                burn.update(dt);
                this.__checkElement2(burn);
                i+=1;
            } else {
                arr.splice(i, 1);
                this._removeBurn(burn);
            }
        }
    }
    
    __updateCameraData() {
        const camera = this.game.camera;
        if(!camera)return;
        const s = camera.scale.x;
        
        this.cameraData.camera = camera;
        this.cameraData.s = s;
        this.cameraData.w = camera.width / s;
        this.cameraData.h = camera.height / s;
        if(!this._level._cameraPoint)return;
        this.cameraData.x = this._level._cameraPoint.position.x;
        this.cameraData.y = this._level._cameraPoint.position.y;
    }
    
    __checkElement1(elem) {
        const data = this.cameraData,
              s = data.s,
              w = data.w,
              h = data.h,
              x = data.x || 0,
              y = data.y || 0;
        
        
        const rect = elem.getRect(),
              pos = elem.getPosition();

        if((Math.abs(pos.x - x) <= (w + rect.width) / 2) && (Math.abs(pos.y - y) <= (h + rect.height) / 2)) {
            elem.visible = true;
        } else {
            elem.visible = false;
        }
    }
    
    __checkElement2(elem) {
        const data = this.cameraData,
              s = data.s,
              w = data.w,
              h = data.h,
              x = data.x || 0,
              y = data.y || 0;

        const pos = elem.position,
              size = elem.getSizeData(),
              f = Math.max(size.width * elem.scale.x, size.height * elem.scale.y);

        if((Math.abs(pos.x - x) <= (w + f) / 2) && (Math.abs(pos.y - y) <= (h + f) / 2)) {
            elem.visible = true;
        } else {
            elem.visible = false;
        }
    }
    
    _ctrlELements() {
        const data = this.cameraData,
              s = data.s,
              w = data.w,
              h = data.h,
              x = data.x || 0,
              y = data.y || 0;
        
        for(let j = 0, all = [this.getLoot(), this.getDecor()], k = all.length; (j | 0) < k; j+=1) {
            for(let i = 0, arr = all[j], l = arr.length; (i | 0) < l; i+=1) {
                this.__checkElement2(arr[i]);
            }
            
        }
        
        for(let i = 0, arr = this.getItems(), l = arr.length; (i | 0) < l; i+=1) {
            const elem = arr[i],
                  pos = elem.position;

            if((Math.abs(pos.x - x) <= (w + elem.width) / 2) && (Math.abs(pos.y - y) <= (h + elem.height) / 2)) {
                elem.visible = true;
                if(!elem._always_static) {
                    elem.dynamicMode();
                }
            } else {
                elem.staticMode();
                elem.visible = false;
            }
        }
    }
    
    addCar(car, front = false) {
        if(car instanceof DP3.CarSprite){
            if(front) {
                this.data.cars.push(car);
                this.front.addChildAt(car, 0);
            } else {
                this.data.cars.push(car);
                this.mainWrap.addChild(car);
            }
        }
    }
    
    _createCar(num) {
        const elem = this.data.carList[num],
              data = this._getUnitData(elem.name);
        
        elem.status = true;
        
        //qwerty
        const car = this.cache.getElement(data.class);
        if(car) {
            car.refresh();
            car.setData({rotation: elem.rotation / 180 * Math.PI, way: elem.way, x: elem.x, y: elem.y});
            this.addCar(car);
        } else {
            if(data.car) {
                const enemy = new DP3.Enemy({game: this.game, sound: this.sound, car: data.name, class: data.class, world: this._world, rotation: elem.rotation / 180 * Math.PI, way: elem.way, x: elem.x, y: elem.y, core: this._level, physicsGroup: 2, correctData: this.game.cache.getJSON("dataCars")[data.class]});
                enemy.shift();
                this.addCar(enemy);
            } else {
                this.addCar(new DP3.StaticEnemy({game: this.game, sound: this.sound, car: data.name, class: data.class, world: this._world, rotation: elem.rotation / 180 * Math.PI, way: elem.way, x: elem.x, y: elem.y, core: this._level, physicsGroup: 2, correctData: this.game.cache.getJSON("dataCars")[data.class]}));
            }
        }
    }
    
    _ctrlCars(x = 0, w = 3000, dt) {
        let dw = w / 2,
            dw2 = 1000,
            start = this._level._start && !this._level._end;
        
        for(let i = 0, arr = this.data.cars; (i | 0) < arr.length; ) {
            const elem = arr[i],
                  pos = elem.getPosition();
            if(pos.x > (x + dw) || pos.x < (x - dw)) {
                this.__killAndSaveCarsX(this._removeCar(i));
            } else if(!elem._live) {
                this._killCar(i);
            } else {
                if(!(elem._player || elem._convoy)) {
                    this._checkBurnsTo(elem);
                }
                elem.update(this._level, dt, start);
                this.__checkElement1(elem);
                i+=1;
            }
        }
        
        for(let i = 0, arr = this.data.carList, l = arr.length; (i | 0) < l; i+=1) {
            const elem = arr[i];
            
            if(!elem.status && elem.x < (x + dw2)) {
                if(elem.way) {
                    if(elem.x < (x - dw2)) {
                        this._createCar(i);
                    }
                } else {
                    if(elem.x > (x - dw2)) {
                        this._createCar(i);
                    }
                }
            }
        }
    }
    
    update(x, w, dt) {
        this.__updateCameraData();
        this._ctrlELements();
        this._ctrlCars(x, w, dt);
        this._ctrlLoot();
        this._ctrlItems();
        this._ctrlScraps(dt);
        this._ctrlExplosions(dt);
        this._ctrlBurns(dt);
        this.bulletsUpdate(dt);
    }
};;DP3.ExplosionCanvas = class extends DP3.Image {
    constructor(prop = {}) {
        super(prop.game, prop.x, prop.y);
        
        this.live = true;
        this.scale.set(prop.scale || 1);
        this._lifeTime = 70 + 10 * this.scale.x;
        this._cloud = null;
        this._fire = [];
        this._clouds = [];
        this._sparks = [];
        
        this.create();
    }
    
    create() {
        const scale = this.scale.x,
              t = this._lifeTime * 16.667;
              //cloud = new Phaser.Image(this.game, 0, 0, "effectAll2", "effectExplosion2_001.png");
        //const emitter = new Phaser.Particles.Arcade.Emitter(this.game, 0, 0, 100 * scale);
        
        //cloud
        /*cloud.anchor.set(0.5);
        this._createFrameAnim(cloud, "explosion2", true);
        this.addChild(cloud);
        this._cloud = cloud;*/
        
        //clouds
        /*emitter.height = emitter.width = 150;
        emitter.makeParticles('cloudSmoke01');
        emitter.minParticleScale = 1;
        emitter.maxParticleScale = 1;
        emitter.setYSpeed(15, 15 + 30);
        emitter.setXSpeed(15, 15 + 30);
        emitter.minRotation = 0;
        emitter.maxRotation = 0;
        emitter.start(false, 1600, 5, 0);
        this.addChild(emitter);
        this.game.particles.add(emitter);
        this._emitter = emitter;/*/

        const emitter = this.game.add.emitter(0, 0, 10);

        emitter.makeParticles('cloudSmoke01');
        emitter.gravity = -60;
        emitter.setRotation(-Math.PI * 20, Math.PI * 20);
        emitter.start(true, t, null, Math.round(100 * scale));
        
        this.addChild(emitter);
        
        this._emitter = emitter;
        
        //sparks
        
        for(let i = 0, arr = this._sparks, l = 10; (i | 0) < l; i+=1) {
            const anim = ([["explosion", "explosion_001.png"], ["explosion2", "effectExplosion2_001.png"]])[Math.round(Math.random())],
                  a = Math.random() * Math.PI * 2,
                  s = Math.random() * 7 + 7,
                  vec = new Phaser.Point(Math.cos(a), Math.sin(a)),
                  elem = new Phaser.Image(this.game, 0, 0, "effectAll2", anim[1]);
            
            elem.scale.set(0.5);
            elem.time = 10;
            elem._speed = s;
            elem._vec = vec;
            elem.rotation = Math.random() * Math.PI * 2;
            elem.anchor.set(0.5);
            this._createFrameAnim(elem, anim[0], true);
            this.addChild(elem);
            this._sparks.push(elem);
        }
        
        //fire
        
        for(let i = 0, arr = this._fire, l = 5; (i | 0) < l; i+=1) {
            const elem = new Phaser.Image(this.game, Math.random() * 60 - 30, Math.random() * 60 - 30, "cloudSmoke03");
            
            //elem.scale.set(0.5);
            elem.rotation = Math.random() * Math.PI * 2;
            elem.anchor.set(0.5);
            this.addChild(elem);
            this._fire.push(elem);
        }
    }
    
    update(dt) {
        const f = dt * 60;
        
        this._lifeTime-=f;
        
        if(this._lifeTime < 0) {
            this.remove();
            return;
        }
        
        this._emitter.alpha*=(1 - 0.05 * f);
        
        for(let i = 0, arr = this._sparks; (i | 0) < arr.length; i+=1) {
            const elem = arr[i];
            if(elem.time < 0 && elem.parent) {
                arr.splice(i, 1);
                elem.parent.removeChild(elem);
                i-=1;
            }
            elem.time-=f;
            elem.position.x+= elem._speed * elem._vec.x * f;
            elem.position.y+= elem._speed * elem._vec.y * f;
            elem.alpha*=(1 - 0.1 * f);
        }
        
        for(let i = 0, arr = this._fire; (i | 0) < arr.length; i+=1) {
            const elem = arr[i];
            elem.position.set(Math.random() * 60 - 30, Math.random() * 60 - 30);
            elem.rotation = Math.random() * Math.PI * 2;
            elem.alpha*=(1 - 0.1 * f);
        }
    }
    
    remove() {
        this.live = false;
        if(this._emitter)this._emitter.destroy();
    }
};;DP3.Item = class extends DP3.Body {
    constructor(prop = {}) {
        super(prop);
        
        if(!this.data) {
            this.data = {};
        }
        
        this.maxHealth = 3000;
        this.setHealth(this.maxHealth);
        this.data.key = prop.key || "";
        this._destructible = false;
        this._scenData = prop.data;
        
        this._live = true;
        
        this._create(prop.data);
        
        this._rectInit();
    }
    
    _rectInit() {
        this._rect = {
            width: this.width,
            height: this.height
        };
    }
    
    getRect() {
        return this._rect;
    }
    
    getPosition() {
        return this.position;
    }
    
    _phDebug(fixtures = [], s = {x:1 , y:1}) {
        const gr = new Phaser.Graphics(this.game, 0, 0),
              scale = box2d.SCALE,
              fixt = Array.isArray(fixtures) ? fixtures : [fixtures];
        
        gr.beginFill(0x2dc100, 0.1);
        gr.lineStyle(2, 0xbc2600, 1);
        
        for(let i = 0, arr = fixt, l = arr.length; (i | 0) < l; i+=1) {
            const shape = arr[i].shape || {};
            if(shape.type == 1) {
                const points = shape.points;
                if(!points)continue;

                // draw a shape
                gr.moveTo(points[0].x * scale * s.x, points[0].y * scale * s.y);
                for(let j = 1, k = points.length; (j | 0) < k; j+=1) {
                    gr.lineTo(points[j].x * scale * s.x, points[j].y * scale * s.y);
                }
            } else {
                gr.drawCircle(0, 0, shape.r * scale * 2);
                
            }
            gr.endFill();
            
        } 
        
        gr.scale.set(1/s.x, 1/s.y);
        
        gr.beginFill(0xff0000, 1);
        gr.lineStyle(0);
        gr.drawCircle(0, 0, 7);
        gr.endFill();
        
        this._debug = gr;
        //gr.alpha = 0.5;
        //gr.scale.set(1/this._frontWrap.scale.x);
        this.addChild(gr);/**/
    }
    
    _create(data = {}) {
        this._createBody(data);
        this._initImage(data);
    }
    
    _initImage(data) {
        this.loadTexture(this.data.key);
        this.position.set(data.x, data.y);
        this.scale.set(data.scaleX, data.scaleY);
        this.anchor.set(0.5);
        this.rotation = (data.rotation / 180) * Math.PI;
        
        /*if((data.scaleX < 0 && data.scaleY >= 0) || (data.scaleX >= 0 && data.scaleY < 0)) {
            console.log(this.data.key, data);
        }*/
    }
    
    _getPhysicsData() {
        return this.game.cache.getJSON("dataItems")[this.data.key];
    }
    
    _createShape(data = {}) {
        if(data.type == 0) {
            
            const shapeC = new box2d.b2CircleShape(data.r);
            shapeC.SetLocalPosition(new box2d.b2Vec2(data.x,  data.y));
            return shapeC;
            
        } else {
            if(!data.points)return;
        
            const res = [],
                  shape = new box2d.b2PolygonShape(),
                  scenData = this._scenData || {},
                  scale = {x: scenData.scaleX, y: scenData.scaleY};

            for(let i = 0, arr = data.points, l = arr.length; (i | 0) < l; i+=1) {
                res.push(new box2d.b2Vec2(arr[i].x * scale.x, arr[i].y * scale.y));
            }

            shape.SetAsVector(res, res.length);

            return shape;
        }
    }
    
    getScraps() {
        return this._scraps;
    }
    
    getBombData() {
        return this.bumData || false;
    }
    
     _createBody(data) {
        if(!this.data.key)return;
        const bodyDef = new box2d.b2BodyDef(),
              phData = this._getPhysicsData();
         
         if(phData.bumPower > 0) {
             this.bumData = {
                 power: phData.bumPower,
                 time: phData.bumTime,
                 touch: phData.bumTouch,
                 distance: phData.bumDistance
             };
         }
         
         this._scraps = phData.scraps;
        
        bodyDef.position.x = data.x / box2d.SCALE;
        bodyDef.position.y = data.y / box2d.SCALE;
        bodyDef.angle = data.rotation / 180 * Math.PI;
        
        this._body = this._world.CreateBody(bodyDef);
        
        this._createFixtures(phData.fixtures);
        //this._phDebug(phData.fixtures, {x: data.scaleX, y: data.scaleY});
         
        if(phData.destroy) {
            this._body.SetUserData({
                type: 3,//Item 3(destructible) or 4(non destructible)
                self: this,
                damage: this.damage.bind(this)
            });
        }
        
        if(phData.dynamic) {
            this.dynamicMode();
            this._body.SetAwake(false);
        } else {
            this._always_static = true;
            this.staticMode();
            this._body.SetAwake(true);
        }
    }
    
    getName() {
        return this.data.key;
    }
    
    kill() {
        this._live = false;
        super.kill();
        this.remove();
    }
};;//Level logic
DP3.LevelCore = class extends DP3.Sprite {
    constructor(properties) {
        let prop = properties || {};
        super(prop.game);
        this.game = prop.game;
        
        this.callbacks = prop.callbacks || {};
        
        this._start = false;
        this._end = false;
        this._counter = 40;
        this._counter_d = this._counter;
        
        this._quake = {
            time: 0,
            power: 0,
            step: 0
        };
        
        this._fps_ctrl = {
            fps: 60,
            moda: 60,
            per: 0.2,
            time: 3000,
            d_time: 3000,
            step: 4,
            dt: 0
        };
        
        this.user = prop.user;
        this.sound = prop.sound;
        
        this._init(prop);
        this._create();
        
    }
    
    _init(prop) {
        this.data = {
            level: 1,
            size: {
                width: prop.width || 800,
                height: prop.height || 600,
            },
            status: false,
            levelsData: [
                //1
                {
                    "texture": "textureLoc1",
                    "textureScale": 0.8,
                    "back": {
                        "mainBack": "fillLoc1",
                        "firstBack": ["back1Loc1_001", "back1Loc1_002", "back1Loc1_003", "back1Loc1_004"],
                        "secondBack": ["back2Loc1_001", "back2Loc1_002", "back2Loc1_003", "back2Loc1_004", "back2Loc1_005", "back2Loc1_006", "back2Loc1_007"],
                    },
                    "lines": {
                        "color1": 0x5d4827,
                        "color2": 0xfcf3b4,
                        "width1": 12,
                        "width2": 6
                    }
                },
                //4
                {
                    "texture": "textureLoc2",
                    "textureScale": 0.8,
                    "back": {
                        "mainBack": "fillLoc2",
                        "firstBack": ["back1Loc2_001", "back1Loc2_002", "back1Loc2_003", "back1Loc2_004"],
                        "secondBack": ["back2Loc2_001", "back2Loc2_002", "back2Loc2_003", "back2Loc2_004"],
                    },
                    "lines": {
                        "color1": 0x315991,
                        "color2": 0xddf0ff,
                        "width1": 7,
                        "width2": 14
                    }
                },
                //7
                {
                    "texture": "textureLoc3",
                    "textureScale": 0.8,
                    "back": {
                        "mainBack": "fillLoc3",
                        "firstBack": ["back1Loc3_001", "back1Loc3_002", "back1Loc3_003"],
                        "secondBack": ["back2Loc3_001", "back2Loc3_002", "back2Loc3_003", "back2Loc3_004"],
                    },
                    "lines": {
                        "color1": 0x3a2f19,
                        "color2": 0xcbb886,
                        "width1": 6,
                        "width2": 15
                    }
                },
                //10
                {
                    "texture": "textureLoc4",
                    "textureScale": 0.8,
                    "back": {
                        "mainBack": "fillLoc4",
                        "firstBack": ["back1Loc4_001", "back1Loc4_002", "back1Loc4_003"],
                        "secondBack": ["back2Loc4_001", "back2Loc4_002"],
                    },
                    "lines": {
                        "color1": 0xc3d48a,
                        "color2": 0x262a1b,
                        "width1": 7,
                        "width2": 12
                    }
                },
                //13
                {
                    "texture": "textureLoc5",
                    "textureScale": 0.8,
                    "back": {
                        "mainBack": "fillLoc5",
                        "firstBack": ["back1Loc5_001", "back1Loc5_002", "back1Loc5_003"],
                        "secondBack": ["back2Loc5_001", "back2Loc5_002"],
                    },
                    "lines": {
                        "color1": 0xc3d48a,
                        "color2": 0x262a1b,
                        "width1": 7,
                        "width2": 12
                    }
                }
            ]
        };
        
        this._x_cam_shift = 0;
        this._y_cam_shift = 0;
        
        ///test
        this.debug = null;//{};//null;
        ///
    }
    
    _check_sounds(obj) {
        return false;
    }
    
    _t_searchCars(scen) {
        const res = [],
              check = {};
        
        for(let key in scen) {
            if(key.split("_")[0].toLowerCase() === "car" && !check.hasOwnProperty(key)) {
                check[key] = true;
                res.push(key);
            }
        }
        
        return res;
    }
    
    _calculSound_for_cars(cars) {
        let res = [];
        
        for(let i = 0, arr = cars, l = arr.length; (i | 0) < l; i+=1) {
            res = res.concat(this._get_songs_from(arr[i]));
        }
        
        return res;
    }
    
    _get_songs_from(name) {
        const data = this.game.cache.getJSON("cars")[this.contentCore._getUnitData(name).name].elements;
        let res = [];
        
        if(data) {
            const turrets = data.turrets;
            
            if(turrets && turrets.length > 0) {
                for(let i = 0, arr = turrets, l = arr.length; (i | 0) < l; i+=1) {
                    res = res.concat(this.__getTurret_songs(arr[i]));
                }
            }
        }
        
        return res;
    }
    
    __getTurret_songs(turret) {
        if(!turret)return;
        const data = turret.carriages;
        let res = [];
        
        if(data && data.length > 0) {
            for(let i = 0, arr = data, l = arr.length; (i | 0) < l; i+=1) {
                res = res.concat(this.__getCarriage_songs(arr[i]));
            }
        }
        
        return res;
    }
    
    __getCarriage_songs(carriage) {
        if(!carriage)return;
        const data = carriage.guns;
        let res = [];
        
        if(data && data.length > 0) {
            for(let i = 0, arr = data, l = arr.length; (i | 0) < l; i+=1) {
                const gun = arr[i];
                if(gun.song)res.push(gun.song);
            }
        }
        
        return res;
    }
    
    _createKeypress() {
        //input
        const keyboard = this.game.input.keyboard;
        
        this.allKeys = {
            "KeyZ": keyboard.addKey(Phaser.Keyboard.Z),
            "KeyX": keyboard.addKey(Phaser.Keyboard.X),
            "KeyQ": keyboard.addKey(Phaser.Keyboard.Q),
            "KeyW": keyboard.addKey(Phaser.Keyboard.W),
            "KeyC": keyboard.addKey(Phaser.Keyboard.C)
        };
        
        this.keysCallbacks = {
            "KeyZ": () => {this.hero.rotateTower("left");},
            "KeyX": () => {this.hero.rotateTower("right");},
            "KeyQ": () => {this.hero.rotateTower("left");},
            "KeyW": () => {this.hero.rotateTower("right");},
            "KeyC": () => {this._createBurn();}
        };
    }
    
    getLevelData(num) {
        return this.data.levelsData[Math.floor((num - 1) / 3)];
    }
    
    getLevelPoints(num) {
        return this.game.cache.getJSON('level_ground_'+num)['Level_2_'+num];
    }
    
    getNumLevel() {
        return this.data.level || 1;
    }
    
    createLevel(num = 1) {
        this.clearLevel();
        
        let data = this.getLevelData(num),
            points = this.getLevelPoints(num),
            w = points[points.length - 1].x * 30,
            h = 8000;
        
        this.data.level = num;
        
        this.game.world.setBounds(0, -h/2, w, h);
        
        this.back.setBackData(data.back);
        
        this.contentCore.setScenario(this.game.cache.getJSON("level_scenario_" + num));
        
        this.ground.setLevelData({points: points, texture: data.texture, textureScale: data.textureScale, lines: data.lines, width: w, height: h, endPoint: (this._getFinishPoint() + 250) / 24});
        
        this._createTargetDestroy();
        
        this.levelStart();
    }
    
    _createTargetDestroy() {
        if(this._targetDestroy)return;
        
        const target = new Phaser.Image(this.game, 0, 0, "effectAll1", "effectDestroy_001.png");
        
        target.anchor.set(0.5);
        target.scale.set(0.35);
        
        this._createFrameAnim(target, "effectDestroy", true, true);
        
        this.contentCore.front.addChild(target);
        
        this._targetDestroy = target;
    }
    
    _hideTargetDestroy() {
        this._targetDestroy.visible = false;
    }
    
    setShopData(data) {
        if(data) {
            this._shopData = data;
        }
    }
    
    getShopData() {
        return this._shopData;
    }
    
    clearLevel() {
        this.data.status = false;
        this.ground.clear();
        this.contentCore.clear();
        this.back.clear();
        this._start = false;
        this._end = false;
        this._counter_d = this._counter;
        this.hero = null;
        this.ally = null;
        this._quake.time = 0;
        this._quake.power = 0;
    }
    
    _create() {
        this._createMainWrap();
        this._setupPhisics();
        this._createBackground();
        this._createContentCore();
        this._createGround();
        this._createKeypress();
    }
    
    _createMainWrap() {
        this.mainWrap = new Phaser.Sprite(this.game, 0, 0);
        this.addChild(this.mainWrap);
    }
    
    _createContentCore() {
        this.contentCore = new DP3.ContentCore({game: this.game, world: this.b2World, level: this, sound: this.sound});
        //this.contentCore.scale.set(0.1);
        this.mainWrap.addChild(this.contentCore);
    }
    
    _createGround() {
        this.ground = new DP3.Ground({
            game: this.game,
            world: this.b2World
        });
        
        this.mainWrap.addChild(this.ground);
    }
    
    _createBackground() {
        this.back = new DP3.Background({game: this.game, self: this, width: 800, height: 600});
        this.back.fixedToCamera = true;
        this.game.world.addChildAt(this.back, 1);
    }
    
    _setupPhisics() {
        let world = new box2d.b2World(new box2d.b2Vec2(0, 26), true);//26
        this.b2World = world;
        
        if(this.debug) {
            this.debug.canvas = document.getElementById("myCanvas");
            this.debug.ctx = this.debug.canvas.getContext('2d');
            world.SetDebugDraw(this.setupDebugDraw());
        }
    }
    
    setupDebugDraw() {
        let debugDraw = new box2d.b2DebugDraw();
        debugDraw.SetSprite(this.debug.ctx);
        debugDraw.SetDrawScale(box2d.SCALE);
        debugDraw.SetFlags(box2d.b2DebugDraw.e_shapeBit | box2d.b2DebugDraw.e_joinBit);
        
        
        return debugDraw;
    }
    
    stepDebugDraw(e) {
        if(!this.b2World) {
            return;
        }
        this.b2World.DrawDebugData();
        this.b2World.ClearForces();
    }
    
    restart() {
        this.contentCore.clear();
        this.contentCore.setScenario();
        this.hero = null;
        this.ally = null;
        this._start = false;
        this._end = false;
        this._counter_d = this._counter;
        this._quake.time = 0;
        this._quake.power = 0;
        //test
        this.levelStart();
    }
    
    _createDefendMarker() {
        if(this.ally) {
            const allyMarker = this.ally.createMarker();
            
            this.contentCore.front.addChild(allyMarker);
        }
    }
    
    _showShiftMarker() {
        if(this.hero) {
            const marker = this.hero.marker;
            if(marker) {
                if(this.contentCore && !marker.visible) {
                    this.contentCore.front.addChild(marker);
                    marker.visible = true;
                }
            } else {
                this._createShiftMarker();
                this._showShiftMarker();
            }
        }
    }
    
    _createShiftMarker() {
        if(this.hero)this.hero.createMarker();
    }
    
    _hideShiftMarker() {
        if(this.hero && this.hero.marker) {
            this.hero.marker.visible = false;
        }
    }
    
    levelStart() {
        const num = this.data.level || 1,
              scen = this.game.cache.getJSON("level_scenario_" + num),
              allyData = scen["Car_FOE_jailCar_tier4_3lp"] || scen["Car_FOE_jailCar_tier5_3lp"] || scen["Car_FOE_jailCar_tier6_3lp"] || scen["Car_FOE_jailCar_tier7_3lp"];
        
        if(allyData) {
            this._createAlly(allyData);
        }
        
        this._createMainHero(scen["Car_PC_7"]);
        
        this.cursors = this.game.input.keyboard.createCursorKeys();
        
        //keypress
        this.game.input.keyboard.addCallbacks(null, this.keypress.bind(this));
        
        const testPoint = {
            x: 6549, y: 415
        };
        
        this._createCameraPoint();
        this.game.camera.follow(this._cameraPoint);
        
        this._createDefendMarker();
        
        this.data.status = true;
        
        this._setZeroParameters();
    }
    
    _setZeroParameters() {
        this._updateCamera(1, 0);
    }
    
    addQuake(t = 0, p = 1) {
        const data = this._quake;
        
        data.time = data.time < t ? t : data.time;
        data.power = p;
    }
    
    addImpulse(x = 0, y = 0, p = 1) {
        const def = new box2d.b2BodyDef(),
              world = this.b2World;
        
        def.position.Set(x, y);
        
        const core = world.CreateBody(def),
              shape = new box2d.b2CircleShape(0.1);
        
        core.CreateFixture2(shape);
              
        let output,
            cache,
            input,
            forceVector,
            f,
            minDistance,
            b = world.GetBodyList(),
            d = p * 150,
            userData,
            type;
        
        while(b) {
            if(b.GetType() == box2d.b2Body.b2_dynamicBody) {
                
                userData = b.GetUserData();
                type = userData && (userData.type == 3 || userData.type == 4);
                
                minDistance = null;
                cache = new box2d.b2SimplexCache();
                
                input = new box2d.b2DistanceInput();
				input.transformA = core.GetTransform();
				input.transformB = b.GetTransform();
				input.proxyA = new box2d.b2DistanceProxy();
				input.proxyB = new box2d.b2DistanceProxy();
                input.useRadii = true;
                
                //joints
                let joint = b.GetJointList();

                joint = joint ? joint.joint : null;

                while(joint) {
                    if(joint._destructible) {
                        const j = joint._p;

                        if(j && Math.sqrt(Math.pow(j.x - x, 2) + Math.pow(j.y - y, 2)) < d) {
                            this.b2World.DestroyJoint(joint);
                        }
                    }
                    joint = joint.GetNext();
                }
                
                f = b.GetFixtureList();
                
                while(f) {
                    output = new box2d.b2DistanceOutput();
                    input.proxyA.Set(shape);
                    input.proxyB.Set(f.GetShape());
                    cache.count = 0;
                    box2d.b2Distance.Distance(output, cache, input);
                    
                    if(d >= (output.distance * box2d.SCALE)) {
                        if (!minDistance || minDistance.distance > output.distance) {
                            if(output.distance > 0) {
                                minDistance = output;
                            }
                        }
                    }
                    
                    f = f.GetNext();
				}
                
                output = minDistance;
                if(!output) {
                    b = b.GetNext();
                    continue;
                }
                
                forceVector = output.pointB.Copy();
				forceVector.Subtract(output.pointA);
                
                if(type) {
                    if(userData.damage) {
                        userData.damage(p / this._extremum(output.distance, 1) * 1000);
                    }
                }
                
                if (forceVector.x == 0 && forceVector.y == 0){
					forceVector = b.GetWorldCenter();
					forceVector.Subtract(core.GetWorldCenter());
					forceVector.Multiply(p / this_.extremum(output.distance, 1));
					b.ApplyImpulse(forceVector, b.GetWorldCenter());
				}else{
					forceVector = b.GetWorldCenter().Copy();
					forceVector.Subtract(core.GetWorldCenter());
					forceVector.Multiply(p / this._extremum(output.distance * 5, 1));
					b.ApplyImpulse(forceVector, output.pointA);
				}
                
            }
            b = b.GetNext();
        }
        
        world.DestroyBody(core);
    }
    
    _ctrlQuake() {
        const data = this._quake,
              res = {x: 0, y: 0};
        
        if(data.time > 0) {
            data.time-=1;
            
            data.step = !data.step;
            
            if(Math.random() > 0.5)return res;
            res.x = (data.step && Math.round(Math.random()) ? 1 : -1) * data.power;
            res.y = (data.step && Math.round(Math.random()) ? 1 : -1) * data.power;
        }
        
        return res;
    }
    
    _createCameraPoint() {
        if(this._cameraPoint)return;
        this._cameraPoint = new Phaser.Graphics(this.game, 0, 0);
        /*this._cameraPoint.lineStyle(0);
        this._cameraPoint.beginFill(0xff0b0b, 1);
        this._cameraPoint.drawCircle(0, 0, 40);
        this._cameraPoint.endFill();/**/
        this.addChild(this._cameraPoint);
    }
    
    _updateCamera(dt, type = 1) {
        if(!this.hero || !this._cameraPoint)return;
        
        const pos = this.hero.getPosition(),
              camera = this.game.camera;
        
        if(type) {
            this._updateActorsRect();
        
            const sc = 0.8,
                  rect = this._actorsRect,
                  body = this.hero._body,
                  blv = body.GetLinearVelocity(),
                  xf = blv.x,
                  yf = blv.y,
                  af = Math.atan2(yf, xf),
                  vf = new Phaser.Point(Math.cos(af), Math.sin(af)),
                  camCenter = this._cameraPoint.position,
                  pf = new Phaser.Point(camCenter.x + vf.x * Math.abs(xf) * 10, camCenter.y + vf.y * Math.abs(yf) * 10),
                  f = dt * 60;//frame factor

            rect.left = rect.left > pf.x ? pf.x : rect.left;
            rect.right = rect.right < pf.x ? pf.x : rect.right;
            rect.top = rect.top > pf.y ? pf.y : rect.top;
            rect.bottom = rect.bottom < pf.y ? pf.y : rect.bottom;

            const actorsRCenter = new Phaser.Point(rect.x + rect.width / 2, rect.y + rect.height / 2);
            let _actors_S = rect.width / 800 > rect.height / 600 ? rect.width / 800 : rect.height / 600,
                S = this._extremum(sc + Math.abs(xf) / 40 * 0.6, sc, sc + 0.6);

            this._x_cam_shift += (actorsRCenter.x - camCenter.x - this._x_cam_shift) / 60 * f;
            this._y_cam_shift += (actorsRCenter.y - camCenter.y - this._y_cam_shift) / 60 * f;

            _actors_S = this._extremum(_actors_S, sc, sc + 0.6); 
            S = S < _actors_S ? _actors_S : S;

            const fs = 1 / camera.scale.x;
            S = (fs + (S - fs) / 20 * f);
            
            camera.scale.set(1/S);

            //quake
            const quake = this._ctrlQuake();

            this._cameraPoint.position.set(pos.x + this._x_cam_shift + quake.x, pos.y + this._y_cam_shift - 150/1.25 + quake.y);///
        } else {
            this._x_cam_shift = 0;
            this._y_cam_shift = 0;
            
            camera.scale.set(1);

            this._cameraPoint.position.set(pos.x, pos.y);
        }
    }
    
    _updateActorsRect() {
        if(!this._actorsRect)this._actorsRect = new Phaser.Rectangle(0, 0, 800, 600);
        
        const rect = this._actorsRect,
              cars = this.contentCore.getCars(),
              hr = this.hero.getRect();
        
        rect.setTo(hr.x, hr.y, hr.width, hr.height);
        
        const data = {
                  left: rect.left,
                  top: rect.top,
                  right: rect.right,
                  bottom: rect.bottom
        };
        
        for(let i = 0, arr = cars, l = arr.length; (i | 0) < l; i+=1) {
            const elem = arr[i],
                  er = elem.getRect();
            
            if(er && Math.abs(er.x - hr.x) < 700 && Math.abs(er.y - hr.y) < 700) {
                data.left = data.left > er.left ? er.left : data.left;
                data.right = data.right < er.right ? er.right : data.right;
                data.top = data.top > er.top ? er.top : data.top;
                data.bottom = data.bottom < er.bottom ? er.bottom : data.bottom;
            }
            
        }
        
        rect.setTo(data.left, data.top, data.right - data.left, data.bottom - data.top);
    }
    
    _createMainHero(data = {x: [0], y: [0]}) {
        const shop = this.getShopData(),
              hero = new DP3.Car({
            game: this.game, 
            sound: this.sound,
            car: shop.cars.indexOf(2) ? "corsair" : "predator", 
            world: this.b2World, 
            core: this, type: 1, 
            x: data["x"][0], 
            y: data["y"][0] - 50,
            shop: shop,
            player: true,
            way: true,
            physicsGroup: 2,
            callbacks: {
                "kill": () => {this.failed(0);}
            },
            correctData: this._collectHeroData(this._shopData)
        });
        this.contentCore.addCar(hero, true);
        hero.rotateTower("right");
        this.hero = hero;
        
        /*const enemy = new DP3.Enemy({game: this.game, sound: this.sound, car: "bossTank", class: "Car_BOSS_Tank_3lp", world: this.b2World, rotation: 0, way: true, x: data["x"][0] + 300, y: data["y"][0], core: this, physicsGroup: 2, correctData: this.game.cache.getJSON("dataCars")["Car_BOSS_Tank_3lp"]});
        enemy.shift();
        this.contentCore.addCar(enemy);/**/
        //this.hero._body.ApplyTorque(-1000);
    }
    
    _collectHeroData(shop = {}) {
        const data = this.game.cache.getJSON("dataCars"),
              getDataTo = (type, value) => {
                const car = shop.cars.indexOf(2),
                      str = car ? "Car_PC_5_" : "Car_PC_7_";
                let num = 1;

                if(type === "rect" || type === "health" || type === "fixtures" || type === "massData") {
                    num = value + 1;
                } else {
                    num = value;
                }
                  
                if(car && num > 3)num = 3;

                return data[str + num][type];
            },
              corpus = shop["shield"][1],
              res = {
                  class: "Car_PC_7",
                  price: 0,
                  health: getDataTo("health", corpus),
                  fuel: getDataTo("fuel", shop["fuel tank"][1]),
                  speed: getDataTo("speed", shop["motor"][1]),
                  rect: getDataTo("rect", corpus),
                  wheels: getDataTo("wheels", shop["wheels"][1]),
                  fixtures: getDataTo("fixtures", corpus),
                  massData: getDataTo("massData", corpus)
              };
        return res;
    }
    
    _getMoveFactor() {
        return this._fps_ctrl.f;
    }
    
    _getFinishPoint() {
        return ([22900, 27570, 33720, 40010, 38100, 39620, 38900, 38970, 38600, 39210, 38120, 38540, 38180, 40720, 42360])[this.getNumLevel() - 1];
    }
    
    _createAlly(data = {x: [0], y: [0]}) {
        const ally = new DP3.Ally({
            game: this.game, 
            sound: this.sound,
            car: "jailCar", 
            class: "Car_FOE_jailCar_tier7_3lp",
            world: this.b2World, 
            core: this, type: 1, 
            x: data["x"][0], 
            y: data["y"][0],
            convoy: true,
            way: true,
            finish: this._getFinishPoint() / box2d.SCALE,
            physicsGroup: 3,
            callbacks: {
                "kill": () => {this.failed(1);}
            },
            correctData: this.game.cache.getJSON("dataCars")["Car_FOE_jailCar_tier7_3lp"]
        });
        //ally.maxHealth = 10000;
        ally.setMaxHealth();
        this.contentCore.addCar(ally, true);
        
        this.ally = ally;
    }
    
    get status() {
        return this.data.status;
    }
    
    pause() {
        this.data.status = false;
    }
    
    play() {
        this.data.status = true;
    }
    
    keypress(char) {
        if(!this.hero)return;
        
        switch(Number(char.keyCode)) {
            case 16:
                if(this.hero && this.hero.stuck)this.hero.shift();
                break;
            case 32:
                const t = Date.now();
                if((!this._lastRocketT || this._lastRocketT + 250 < t)) {
                    this._lastRocketT = t;
                    if(this.hero.launcherFire())this.user.addTo(1, ["stats", "used"]);
                }
                break;
            default:
                break;
        }
    }
    
    keypressCTRL(mbd = {}) {
        if(!this.hero || this.hero.isFallInShock())return;
        
        const keys = this.allKeys,
              cbs = this.keysCallbacks,
              mobile = {
                  "KeyZ": "turrLeft",
                  "KeyX": "turrRight",
                  "KeyQ": "turrLeft",
                  "KeyW": "turrRight",
                  "KeyC": "burn"
              };

        for(let key in keys) {
            if((keys[key].isDown || mbd[mobile[key]]) && cbs.hasOwnProperty(key)) {
                cbs[key]();
            }
        }
    }
    
    _createBurn() {
        if(this.contentCore && this.hero) {
            const t = Date.now();
            if((!this._lastBurnT || this._lastBurnT + 35 < t) && this.hero.getFuel() > 2) {
                const hero = this.hero,
                      x = hero.getPosition().x - 80,
                      f = hero.getShopData()["fuel tank"][1],
                      type = (f == 6) ? 3 : ((f == 5) ? 2 : 1);
                
                hero.useFuel(([1, 1.2, 1.5])[type - 1]);
                this.contentCore.addBurn(x, this._foundGroundY(x) + 2, type);//x, y, type
                this._lastBurnT = t;
            }
        }
    }
    
    _foundGroundY(x) {
        if(this.ground) {
            return this.ground.getY(x);
        }
        
        return 0;
    }
    
    heroCTRL(dt, mbd = {}) {
        if(this.hero && this.cursors && this.hero.checkFuel() && !this.hero.isFallInShock()) {
            const body = this.hero._body,
                  cursors = this.cursors,
                  v = dt * 3,
                  down = (cursors.down.isDown || mbd.left),
                  up = (cursors.up.isDown || mbd.right),
                  f = this._getMoveFactor();
            
            if(this._checkStart(dt, mbd)) {
                if(up){
                    this.hero.useFuel(v);
                    this.hero.motor("right", f);
                } else if(down){
                    this.hero.useFuel(v);
                    this.hero.motor("left", f);
                } else {
                    this.hero.motor("stop");
                }
            } else {
                this.hero.motor("stop");
            }
            
            const stuck = this.hero.checkStuck(this._start, up, down, dt * 60);
            
            if(this.game.isMobile) {
                if(mbd.animLamp) {
                    mbd.animLamp(stuck);
                }
            } else {
                if(stuck) {
                    this._showShiftMarker();
                } else {
                    this._hideShiftMarker();
                }
            }
            
            
            /*let headOverHeels = false;
            const a = body.GetAngle(),
                  angVel = body.GetAngularVelocity();
            
			if (Math.abs(a) > Math.PI / 4 * 3) headOverHeels = true;
            
            
			if (cursors.right.isDown && angVel < 5) {
				if (angVel < 0)body.SetAngularVelocity(0);
                
				body.ApplyTorque(headOverHeels ? 10 : 1.8);
			} else if (cursors.left.isDown && angVel > -5) {
				if (angVel > 0)body.SetAngularVelocity(0);
                
				body.ApplyTorque(headOverHeels ? -10 : -1.7);
			}else{
                body.SetAngularVelocity(0)
				body.ApplyTorque(0);
			}*/
            
            
            if (cursors.right.isDown || mbd.bottom){
                this.hero.balance("down");
            } else if (cursors.left.isDown || mbd.top){
                this.hero.balance("up");
            }/**/

        }
    }
    
    _checkStart(dt, mbd) {
        if(this._start) {
            return true;
        } else {
            if(this.cursors.up.isDown || this.cursors.down.isDown || mbd.left || mbd.right) {
                if(this._counter_d == this._counter)this.sound.play("98_StartEngine_sn");
                this._counter_d-=dt*60;
                if(this._counter_d < 0) {
                    if(this.ally) {
                        this.ally.setMotorStatus(true);
                    }
                    this._playLevelMusic(this.getNumLevel());
                    this._start = true;
                }
            } else {
                this.sound.getSound("98_StartEngine_sn").stop();
                this._counter_d = this._counter;
            }
            return false;
        }
    }
    
    _playLevelMusic(num = 1) {
        if(num < 4 || num > 6) {
            this.sound.play("118_Theme1_ms", true);
        } else {
            this.sound.play("42_Theme2_ms", true);
        }
    }
    
    getHero() {
        return this.hero;
    }
    
    addBullet(bullet) {
        if(this.contentCore)this.contentCore.addBullet(bullet);
    }
    
    //B - lesion angle
    //Q - angle of rotation
    getTarget(x = 0, y = 0, type, dist = false, angle = false, B = 3.14, Q = -1.57) {
        let min,
            res = null;
        
        //dist = 1000;
        
        for(let i = 0, arr = this.contentCore.data.cars, l = arr.length; (i | 0) < l; i+=1) {
            
            if(arr[i]._live && arr[i].visible) {
                
                const elem = arr[i],
                      pos = elem.getPosition(),
                      d = Math.sqrt(Math.pow(pos.x - x, 2) + Math.pow(pos.y - y, 2));

                if((dist && ((dist instanceof Array  && (d > dist[1] || d < dist[0])) || d > dist)) || (type === elem._type) || (angle && this._absAngle(this.game.math.angleBetween(x, y, pos.x, pos.y) - Q) > B))continue;

                if(!res || d < min) {
                    min = d;
                    res = elem;
                }

            }
            
        }
        
        return res;
    }
    
    checkTarget(elem, x = 0, y = 0, type, dist = false, angle = false, B = 3.14, Q = -1.57) {
        if(elem && elem._live) {
                
            const pos = elem.getPosition(),
                  d = Math.sqrt(Math.pow(pos.x - x, 2) + Math.pow(pos.y - y, 2));

            if((dist && ((dist instanceof Array  && d > dist[1] && d < dist[0]) || d > dist)) || (type === elem._type) || (angle && this._absAngle(this.game.math.angleBetween(x, y, pos.x, pos.y) - Q) > B))return false;
            
            return true;

        }
        return false;
    }
    
    checkDistance() {
        if(this.hero && this.ally && (Math.abs(this.ally._backWrap.position.x - this.hero._backWrap.position.x) > 3000)) {
            return false;
        }
        
        return true
    }
    
    checkFinish() {
        if(((!this.ally) || (this.ally && this.ally.finished)) && this.hero._backWrap.position.x >= this._getFinishPoint()) {
            return true;
        }
        
        return false;
    }
    
    _updateLevelData() {
        const data = this.user.getLevelData(),
              hero = this.hero,
              ally = this.ally;
        
        data.speed = hero._body.GetLinearVelocity().x * 2;
        data.bomb = hero.bomb;
        data.fuel = hero.fuelStatus();
        data.progress = hero.getPosition().x / this._getFinishPoint();
        data.distance += hero._body.GetLinearVelocity().x / 3000;
        data.health = hero.healthStatus();
        
        if(ally) {
            const p0 = hero.getPosition(),
                  p1 = ally.getPosition(),
                  d = 700 / this.game.camera.scale.x;
            
            if(p0.x + d < p1.x) {
                data.row = 1;
            } else if(p0.x - d > p1.x) {
                data.row = -1;
            } else {
                data.row = 0;
            }
        } else {
            data.row = 0;
        }
    }
    
    _updatePhisics(fps = 60) {
        /*const f = 1 / 60,
              data = this._fps_ctrl;
        if(this.b2World) {
            while(data.dt >= f) {
                data.dt -= f;
                this.b2World.Step(f, 10, 10);
            }
        }*/
        
        /*if(this.b2World) {
            this.b2World.Step(1/60, 10, 10);
        }*/

        const t = 60 / fps;

        if(this.b2World) {
            this.b2World.Step(1 / fps, 20, 20);
        }
    }
    
    _updateGround() {
        if(this.ground) {
            let x = this._cameraPoint.position,
                y = x,
                sc = 1 / this.game.camera.scale.x;
            
            if(this.ally) {
                y = this.ally.getPosition();
            } else if(this.hero) {
                y = this.hero.getPosition();
            }

            this.ground.draw(this._cameraPoint.position, 800 * sc, 600 * sc, y, 7000);
        }
    }
    
    _updateBack() {
        if(this.back) {
            let x = this._cameraPoint.position,
                sc = 1 / this.game.camera.scale.x;

            this.back.draw(this._cameraPoint.position, 800 * sc);
        }
    }
    
    _updateTargetDestroy() {
        const marker = this._targetDestroy,
              data = this.user.getLevelData();
        
        if(data && data.bomb > 0) {
            let target = this.hero.getTarget();
            
            if(!target) {
                const p0 = this.hero.getPosition();
                
                target = this.getTarget(p0.x, p0.y, 1);
            }
            
            if(target && target._live) {
                const p1 = target.getPosition();
                marker.visible = true;
                marker.position.set(p1.x, p1.y);
                
                return;
            }
        }
        
        this._hideTargetDestroy();
    }
    
    _getRandWinText() {
        const arr = ["GREAT!", "FANTASTIC!", "EXCELLENT!", "LETS RIDE!", "WE DID IT!"];
        return arr[Math.round(Math.random() * (arr.length - 1))];
    }
    
    stopCTRL() {
        this._end = true;
    }
    
    failed(type = 1) {
        this.stopCTRL();
        this.talk("OH NO!", 0);
        this.game.time.events.add(Phaser.Timer.SECOND * 2, () => {this.callbacks.failed(type);}, this);
    }
    
    talk(text, type) {
        const talk = this.callbacks.girlTalk;
        if(!talk)return;
        talk(text, type);
    }
    
    _fps_ctrl_update(dt) {
        const data = this._fps_ctrl,
              fps = 1 / dt;
        
        if(Math.abs(fps - data.fps) > data.fps * data.per) {
            data.moda = (data.moda + fps) / 2;
            if(data.d_time <= 0) {
                data.fps = data.moda;
            } else {
                data.d_time -= dt * 1000;
            }
        } else {
            data.moda = data.fps;
            data.d_time = data.time;
        }
        
        data.f = Math.sqrt(Math.pow(60 / data.fps, 0.9));
        
        //this._fps_ctrl.dt+=dt;
    }
    
    update(dt, mobileData) {
        dt = Phaser.Math.clamp(dt, 0.016, 0.033);

        if(this.data.status) {
            if(!this._end) {
                if(mobileData) {
                    if(mobileData.rocket)this.keypress({key: " ", code: "Space", keyCode: 32});
                    
                    if(mobileData.shift) {
                        mobileData.shift = false;
                        this.keypress({code: "ShiftLeft", key: "Shift", keyCode: 16});
                    }
                }

                this.heroCTRL(dt, mobileData);

                this.keypressCTRL(mobileData);
                
                if(this._start && this.hero && this.hero.getPosition().x < 1000) {
                    this.talk("GO! GO! GO!", 1);
                }

                this._updateCamera(dt);

                if(!this.checkDistance() && this.callbacks.failed) {
                    this.failed(1);
                }

                if(this.checkFinish() && this.callbacks.complete) {
                    this.stopCTRL();
                    this.talk(this._getRandWinText(), 1);
                    this.game.time.events.add(Phaser.Timer.SECOND * 2, this.callbacks.complete, this);
                }
            }
            
            
            this._updateLevelData();
            
            this._fps_ctrl_update(dt);
            
            this._updatePhisics(this._fps_ctrl.fps);
            
            this._updateBack();
            
            ////!!!!!!!!!!!!!!!!!!
            this._updateGround();
            
            if(this.contentCore) {
                this.contentCore.update(this.hero._backWrap.position.x, 5000, dt);
            }
            
            this._updateTargetDestroy();
        }
    }
};
;DP3.Scrap = class extends Phaser.Image {
    constructor(game) {
        super(game);
        this.game = game;
        
        this._G = -0.0981 * 2.5;
        this.anchor.set(0.5);
    }
    
    setData(prop = {}) {
        this.visible = true;
        
        this.alpha = 1;
        
        this._lifeTime = 100 + Math.random() * 50;
        this._time = 0;
        this._live = true;
        this._vec = prop.impulce;
        this._p0 = new Phaser.Point(prop.x, prop.y);
        //this._speed = prop.speed;
        this._rotate = -(Math.PI / 18) + Math.random() * (Math.PI / 9);
        
        this._initImage(prop.name, prop.key);
    }
    
    _initImage(image, frame) {
        if(this.key !== image)this.loadTexture(image);
        if(frame) {
            this.frameName = frame;
        } else {
            this.frame = 0;
        }
    }
    
    update(dt) {
        this._time+=dt*60;
        
        const t = this._time;
        
        //const mul = 2 + (3 - (Desktop.GetGame().FPS() - 30) / 10);
        
        this.position.x = this._p0.x + t * this._vec.x;
        this.position.y = this._p0.y + t * this._vec.y - (this._G * t * t) / 2;
        this.rotation = this._rotate * t;
        
        if(this._time / this._lifeTime > 0.5) {
            this.alpha = (1 - this._time / this._lifeTime) * 2;
        }
        
        if(this._time > this._lifeTime) {
            this.kill();
        }
    }
    
    kill() {
        this._live = false;
        this.visible = false;
    }
};DP3.User = class {
    constructor() {
        this.initStorage();
        this._KEY = "DP3";
        this.data = {
            gameplay: 0,
            turret: 0,
            sound: 1,
            music: 1,
            saves: []
        };
        this.levelData = null;
        this.levelData = null;
        this._checkStorage();
        this.selectedSave = 0;
        
        this.checkSaves();
    }
    
    initStorage() {
        this.storage = localStorage || sessionStorage;
    }
    
    createLevelData(num = 1) {
        this.levelData = {
            num: num,
            money: 0,
            bomb: 0, 
            boosters: [0,0,0,0],
            score: 0,
            record: this.getRecordFrom(num),
            fuel: 1,
            progress: 0,
            health: 1,
            speed: 0,
            distance: 0,
            row: 0///-1 - left, 1 - right, 0 - null
        };
    }
    
    getRecordFrom(num = 1) {
        const save = this.getSave();
        return save ? save["levels"][num - 1] : 0;
    }
    
    setRecordFrom(num = 1, value) {
        const record = Number(this.getRecordFrom(num));
        if(value > record)this.setVariable(value, ["levels", num - 1]);
    }
    
    getStars() {
        const save = this.getSave();
        return save ? save.stars : 0;
    }
    
    setStoryStep(step) {
        //0 - intro
        //1-12 - levels
        //13 - end
        const s = this.getStoryStep();
        
        this.getSave().story = step < s ? s : step > 13 ? s : step;
    }
    
    getStoryStep() {
        const save = this.getSave();
        if(save)return this.getSave().story || 0;
    }
    
    getBoosters() {
        if(this.levelData) {
            return this.levelData.boosters;
        }
    }
    
    activeBoost(num = 1) {
        if(this.levelData) {
            this.levelData.boosters[num - 1] = 1;
        }
    }
    
    getLevelData() {
        return this.levelData;
    }
    
    setStars(value) {
        const save = this.getSave();
        if(save)return save.stars = Number(value);
    }
    
    _checkStorage() {
        if(!this.storage) {
            this.initStorage();
            if(!this.storage) {
                return false;
            }
        }
        
        if(this.storage.getItem(this._KEY)) {
            this.getData();
        } else {
            this.setData();
        }
        return true;
    }
    
    setData() {
        if(this.storage) {
            this.storage.setItem(this._KEY, JSON.stringify(this.data));
        }
    }
    
    getData() {
        if(this.storage) {
            const json = this.storage.getItem(this._KEY);
            if(json) {
                const obj = JSON.parse(json),
                      data = this.data;
                for(let key in obj) {
                    data[key] = obj[key];
                }
            }
        }
    }
    
    save() {
        this.setData();
    }
    
    setSetting(value, name) {
        if(this.data.hasOwnProperty(name)) {
            this.data[name] = value;
            this.setData();
        }
    }
    
    getSetting(name) {
        if(this.data.hasOwnProperty(name)) {
            return this.data[name];
        }
    }
    
    getVariable(path) {
        if(!path)return;
        return this._searchWay(this.getSave(), path);
    }
    
    setVariable(value = 0, path) {
        if(!path)return;
        this._searchWay(this.getSave(), path, () => {return value});
    }
    
    addTo(value = 0, path) {
        if(!path)return;
        this._searchWay(this.getSave(), path, x => {return x + value});
    }
    
    _searchWay(self, path = 0, cb) {
        if(!self)return;
        
        let key;
        
        if(path instanceof Array) {
            key = path.shift();
            if(!self.hasOwnProperty(key))return;
            
            if(path.length > 1) {
                return this._searchWay(self[key], path, cb);
            } else {
                return this._searchWay(self[key], path[0], cb);
            }
            
        } else {
            key = path;
            
            if(!self.hasOwnProperty(key))return;
            
            if(cb) {
                self[key] = cb(self[key]);
            }
            
            return self[key];
        }
    }
    
    getSave() {
        if(this.data.saves.length < 0) {
            this.addSave();
        }
        return this.data.saves[this.selectedSave];
    }
    
    getSaves() {
        return this.data.saves;
    }
    
    getMoney() {
        return this.getSave.money;
    }
    
    selectSave(num = 0) {
        if(num > 2) {
            num = 2;
        } else if(num < 0) {
            num = 0;
        }
        
        if(!this.getSaves()[num]) {
            this.addSave();
        } else {
            this.selectedSave = num;
        }
    }
    
    checkSaves() {
        let check = false;
        
        for(let i = 0, arr = this.getSaves(), l = arr.length; (i | 0) < l; i+=1) {
            if(!arr[i].shop) {
                check = true;
                arr[i] = this.getSaveObject();
            }
        }
        
        if(check)this.save();
    }
    
    removeSave(num = -1) {
        if(this.data.saves.length < 0)return;
        if(num < 0)num = this.data.saves.length - 1;
        this.data.saves.splice(num, 1);
        this.setData();
    }
    
    addSave() {
        this.getData();
        if(this.data.saves.length < 3) {
            this.data.saves.push(this.getSaveObject());
        }
        this.selectSave(this.data.saves.length - 1);
        this.setData();
    }
    
    getSaveObject() {
        return {
            money: 0,
            story: 0,
            achiv: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ],
            levels: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ],
            stats: {
                earned: 0,
                killed: 0,
                purchases: 0,
                distance: 0,
                levels: 0,
                special: 0,
                used: 0,
                shot: 0,
                moneyC: 0,
                repairC: 0,
                fuelC: 0,
                gunner: 0,
                rocketeer: 0,
                arsonist: 0,
                mechanic: 0,
                armourer: 0,
                persistent: 0,
                spender: 0
            },
            stars: 0,
            shop: [
                [0, 0],
                [1, 1],
                [1, 1],
                [1, 1],
                [1, 1],
                [1, 1],
                
                [5, 5],
                [1, 1],
                [1, 1],
                [2, 2],
                [3, 3],
                [2, 2]
            ],
            cars: [
                2,
                0,
                -1,
                -1,
                -1,
                -1
            ]
        };
    }
};;window.onload = () => {
  let game = new DP3.Game();
};
;DP3.HintsCompleted = class extends Phaser.Sprite {
    constructor(properties) {
        super(properties.game);
        let prop = properties || {};
        this.game = prop.game || null;
        
        this.data = {
            
        };
        this._create();
    }
    
    setAndShow(properties) {
        this._hide();
        this._setData(properties);
        this._show();
    }
    
    _create() {
        this.inputEnabled = false;
        
        this.mainWrap = new Phaser.Sprite(this.game);
        this.back = new Phaser.Image(this.game, 0, 0, "hintsCompleted_001");
        this.titleText = new Phaser.Text(this.game, 17, -80, "title", {fill: "#fff", fontSize: 17});
        this.statusText = new Phaser.Text(this.game, 280, -80, "status", {fill: "#fecb02", fontSize: 17});
        this.mainText = new Phaser.Text(this.game, 17, -47, "text", {fill: "#fff", fontSize: 17});
        this.rewardText = new Phaser.Text(this.game, 150, -17, "reward:", {fill: "#fff", fontSize: 17});
        this.rewardVakueText = new Phaser.Text(this.game, 280, -17, "0$", {fill: "#fff", fontSize: 17});
        
        this.titleText.anchor.set(0, 1);
        this.statusText.anchor.set(1, 1);
        this.mainText.anchor.set(0, 1);
        this.rewardText.anchor.set(0, 1);
        this.rewardVakueText.anchor.set(1, 1);
        this.back.anchor.set(0, 1);
        
        this.mainWrap.addChild(this.back);
        this.mainWrap.addChild(this.titleText);
        this.mainWrap.addChild(this.statusText);
        this.mainWrap.addChild(this.mainText);
        this.mainWrap.addChild(this.rewardText);
        this.mainWrap.addChild(this.rewardVakueText);
        
        this.addChild(this.mainWrap);
        
        this._hide();
    }
    
    _hide() {
        this.visible = false;
    }
    
    _show() {
        this.visible = true;
    }
    
    _setData(data) {
        if(data) {
            this.titleText.setText(data.title);
            this.statusText.setText((data.status ? "unlocked" : ""));
            this.mainText.setText(data.pref + data.value + data.text);
            this.mainText.clearColors();
            this.mainText.addColor('#fecb02', data.pref.length);
            this.mainText.addColor('#fff', data.pref.length + String(data.value).length);
            this.rewardVakueText.setText(data.reward + "$");
            this.back.loadTexture("hintsCompleted_00" + data.image);
        }
    }
};;DP3.LevelInterface = class extends DP3.Image {
    constructor(prop = {}) {
        super(prop.game);

        this.levelData = prop.levelData;
        this.levelConfig = prop.levelConfig;

        this.stars = [];

        this._create();
    }

    _create() {
        h5branding.google.sendScreenView('level_interface');
        const data = this.levelData,
              isMbl = this.game.isMobile,
              bombText = new Phaser.Text(this.game, -355, -291, String(data.bomb), {fontSize: 19, fill: "#ffffff", font: DP3.font2}),
              moneyText = new Phaser.Text(this.game, -259, -291, String(data.money), {fontSize: 19, fill: "#ffffff", font: DP3.font2}),
              hpLine = new Phaser.Image(this.game, -56, -295),
              hpImage = new Phaser.Image(this.game, 0, 0, "lineRed"),
              maskHp = new Phaser.Graphics(this.game, 0, 0),
              distLine = new Phaser.Image(this.game, isMbl ? 80 : -119, 294),
              distImage = new Phaser.Image(this.game, 0, 0, "lineBlue"),
              maskDist = new Phaser.Graphics(this.game, 0, 0),
              markerLine = new Phaser.Image(this.game, isMbl ? - 12 : -211, 294, "markerLine"),
              stars = this._createStars(),
              boosters = this.getWrap(),
              fuel = new Phaser.Image(this.game, isMbl ? -184 : -383, 275, "gameInterface2", "fuelMinMaxAnim_001.png"),
              speedometer = new Phaser.Image(this.game, isMbl ? -134 : -333, 288, "gameInterface2", "speedAnim_001.png"),
              animFuel = new Phaser.Image(this.game, isMbl ? -184 : -383, 275, "gameInterface1"),
              animBomb = new Phaser.Image(this.game, -355, -293, "gameInterface1"),
              animMoney = new Phaser.Image(this.game, -259, -293, "gameInterface1"),
              animHP = new Phaser.Image(this.game, -56, -295, "gameInterface1"),
              animLampo = new Phaser.Image(this.game, isMbl ? -184 : -383, 290, "gameInterface2", "lampoRedAnim_001.png"),
              leftRow = this.getWrap(),
              leftRowImage = new Phaser.Image(this.game, 0, 0, "convoyMarker"),
              leftRowText = new Phaser.Text(this.game, 33, 3, "CONVOY", {fontSize: 21, fill: "#ffffff", font: DP3.font5, stroke: "#000", strokeThickness: 2}),
              rightRow = this.getWrap(),
              rightRowImage = new Phaser.Image(this.game, 0, 0, "convoyMarker"),
              rightRowText = new Phaser.Text(this.game, -33, 3, "CONVOY", {fontSize: 21, fill: "#ffffff", font: DP3.font5, stroke: "#000", strokeThickness: 2}),
              girlWrap = this.getWrap(),
              girlText = new Phaser.Text(this.game, -40, -45, "", {fill: "#ff0000", font: DP3.font5, fontSize: 30, stroke: "#ffffff", strokeThickness: 3, align: "right"}),
              girl = new Phaser.Image(this.game, 0, 0, "girl_blok");

        //rows
        leftRowText.anchor.set(0, 0.5);
        leftRowImage.anchor.set(1, 0.5);
        leftRowImage.scale.set(-1, 1);
        leftRow.addChild(leftRowImage);
        leftRow.addChild(leftRowText);
        leftRow.position.set(-420, 0);
        leftRow.visible = false;
        this._leftRow = leftRow;
        this.addChild(leftRow);

        rightRowText.anchor.set(1, 0.5);
        rightRowImage.anchor.set(1, 0.5);
        rightRow.addChild(rightRowImage);
        rightRow.addChild(rightRowText);
        rightRow.position.set(420, 0);
        rightRow.visible = false;
        this._rightRow = rightRow;
        this.addChild(rightRow);

        boosters.position.set(112, -291);

        stars.position.set(-55, -253);

        bombText.anchor.set(0.5);
        moneyText.anchor.set(0.5);
        hpImage.anchor.set(0.5);
        distImage.anchor.set(0.5);
        markerLine.anchor.set(0.5);
        speedometer.anchor.set(0.5);
        fuel.anchor.set(0.5);
        animLampo.anchor.set(0.5);

        animFuel.anchor.set(0.5);
        animBomb.anchor.set(0.5);
        animMoney.anchor.set(0.5);
        animHP.anchor.set(0.5);

        fuel.scale.set(0.99);

        animBomb.scale.set(1, 1.1);
        animMoney.scale.set(1.1);

        hpImage.scale.set(1.3);
        hpImage.mask = maskHp;
        hpLine._i_mask = maskHp;

        maskHp.beginFill(0x000000, 1);
        maskHp.lineStyle(0, 0x000000, 1);
        maskHp.drawRect(-92, -9, 185, 18);

        distImage.mask = maskDist;
        distLine._i_mask = maskDist;

        maskDist.beginFill(0x000000, 1);
        maskDist.lineStyle(0, 0x000000, 1);
        maskDist.drawRect(-92, -8, 185, 16);

        this._money = moneyText;
        this._distance = distLine;
        this._bomb = bombText;
        this._fuel = fuel;
        this._speedometer = speedometer;
        this._hp = hpLine;
        this._boosters = [];

        //Fuel
        this._fuel._animGreen = this.__generTween(animFuel, "blinkGreen3");
        this._fuel._animRed = this.__generTween(animFuel, "blinkRed3", true);
        this._fuel._anim = animFuel;

        //lampo
        this._fuel._animLampo = this.__generTween(animLampo, "lampoRedAnim", true);
        this._fuel._lampo = animLampo;

        //Bomb
        this._bomb._animGreen = this.__generTween(animBomb, "blinkGreen");
        this._bomb._animRed = this.__generTween(animBomb, "blinkRed", true);
        this._bomb._anim = animBomb;

        //Money
        this._money._animGreen = this.__generTween(animMoney, "blinkGreen");
        this._money._anim = animMoney;

        //HP
        this._hp._animGreen = this.__generTween(animHP, "blinkGreen2");
        this._hp._animRed = this.__generTween(animHP, "blinkRed2", true);
        this._hp._anim = animHP;

        for(let i = 0, arr = [4, 1, 2, 3], l = arr.length; (i | 0) < l; i+=1) {
            const elem = new Phaser.Image(this.game, i * 50, 0, "gameInterface2", "bosterIco" + arr[i] + "_001.png");
            elem.anchor.set(0.5);
            boosters.addChild(elem);
            this._boosters.push(elem);
        }

        //girl
        girl.anchor.set(0.5);
        girlText.anchor.set(0.5, 1);
        girlText.rotation = -Math.PI / 5;
        girlWrap.addChild(girl);
        girlWrap.addChild(girlText);
        girlWrap.position.set(340, isMbl ? 140 : 240);

        girlWrap.visible = false;
        girlWrap.icon = girl;
        girlWrap.text = girlText;

        this.girl = girlWrap;

        hpLine.addChild(hpImage);
        hpLine.addChild(maskHp);

        distLine.addChild(distImage);
        distLine.addChild(maskDist);

        this.addChild(boosters);
        this.addChild(bombText);
        this.addChild(moneyText);
        this.addChild(hpLine);
        this.addChild(distLine);
        this.addChild(markerLine);
        this.addChild(stars);
        this.addChild(speedometer);
        this.addChild(fuel);

        this.addChild(animFuel);
        this.addChild(animBomb);
        this.addChild(animMoney);
        this.addChild(animHP);
        this.addChild(animLampo);

        this.addChild(girlWrap);
    }

    girlTalk(tx = "", type = 0) {
        const girl = this.girl;

        if(!girl.visible) {
            const text = girl.text,
                  image = girl.icon,
                  t = 200;

            if(type) {
                text.style.fill = "#ffff01";
                text.style.stroke = "#000000";
            } else {
                text.style.fill = "#ff0000";
                text.style.stroke = "#ffffff";
            }

            girl.visible = true;
            text.text = String(tx);

            text.alpha = 1;
            text.position.set(0);
            text.scale.set(0.5);
            image.alpha = 0;

            this.game.add.tween(text.position).to({x: -40, y: -45}, t, "Linear", true);
            this.game.add.tween(text.scale).to({x: 0.75, y: 0.75}, t, "Linear", true);
            this.game.add.tween(image).to({alpha: 1}, t, "Linear", true).onComplete.add(() => {
                const tween = this.game.add.tween(text.scale),
                      t1 = 250;

                for(let i = 0, l = 3; (i | 0) < l; i+=1) {
                    tween.to({x: 1, y: 1}, t1, "Linear").to({x: 0.75, y: 0.75}, t1, "Linear");
                }

                tween.onComplete.add(() => {
                    this.game.add.tween(text.scale).to({x: 2, y: 2}, 150, "Linear", true);
                    this.game.add.tween(text).to({alpha: 0}, 150, "Linear", true).onComplete.add(() => {
                        this.game.add.tween(image).to({alpha: 0}, 150, "Linear", true).onComplete.add(() => {
                            this.game.time.events.add(500, () => {girl.visible = false;});
                        });
                    });
                });

                tween.start();
            });
        }
    }

    __generTween(elem, name, loop) {
        if(!(elem && name))return;

        elem.visible = false;

        return this._createFrameAnim(elem, name, false, loop, (e) => {
            elem.visible = false;
        });
    }

    _createStars() {
        const wrap = this.getWrap();

        for(let i = 0, l = this.levelConfig.stars.length || 0; (i | 0) < l; i+=1) {
            const wrapStar = this.getWrap(),
                  step = 40,
                  dx = (l - 1) * step / 2,
                  bg = new Phaser.Image(this.game, i * 40 - dx, 0, "intefaceStarBg"),
                  star = new Phaser.Image(this.game, i * 40 - dx, 0, "gameInterface2", "interfaceStarAnim_001.png"),
                  starImage = this.game.cache.getImage("galleryStar_03"),
                  textBlack = new Phaser.Text(this.game, 0, 8, 0, {fontSize: 23, fill: "#000000", font: DP3.font2}),
                  textBlue = new Phaser.Text(this.game, 0, 8, 0, {fontSize: 23, fill: "#5ff6fa", font: DP3.font2}),
                  gr = new Phaser.Graphics(this.game, 0, 0),
                  bmd = new Phaser.BitmapData(this.game, "starImage", starImage.width, starImage.height),
                  bmd2 = new Phaser.BitmapData(this.game, "starImage", starImage.width, starImage.height),
                  w = 53,
                  h = 50;

            bmd.fill(27, 167, 228, 1);
            bmd2.alphaMask(bmd, starImage, new Phaser.Rectangle(0, 0, starImage.width, starImage.height), new Phaser.Rectangle(0, 0, starImage.width, starImage.height));

            const progrs = new Phaser.Image(this.game, 0, 0, bmd2);
            progrs.addChild(textBlue);
            progrs.anchor.set(0.5, 0.5);
            progrs.mask = gr;

            bg.anchor.set(0.5);
            star.anchor.set(0.5);
            bg.scale.set(0.67);
            star.scale.set(0.67);
            textBlack.anchor.set(0.5);
            textBlue.anchor.set(0.5);

            gr.beginFill(0x000, 1);
            gr.lineStyle(0, 0x000, 0);
            gr.drawRect(-w / 2, -h / 2, w, h);
            gr.endFill();

            bg.addChild(gr);

            bg.addChild(textBlack);
            bg.addChild(progrs);

            wrapStar.addChild(bg);
            wrapStar.addChild(star);

            wrap.addChild(wrapStar);

            wrapStar.status = 0;/// 0 - lock, 1 - active, 2 - ready
            wrapStar.star = star;
            wrapStar.blue = progrs;
            wrapStar.gr = gr;
            wrapStar.black = textBlack;
            wrapStar.text = textBlue;
            wrapStar.bg = bg;
            textBlack.visible = progrs.visible = star.visible = false;

            this.stars.push(wrapStar);
        }

        return wrap;
    }

    _startAnim(self, name) {
        if(!(self && name && self[name]))return;

        self._anim.visible = true;
        self[name].resume();
        self[name].start();
    }

    _starsUpdate() {
         const data = this.levelData,
               config = this.levelConfig,
               stars = this.stars,
               score = data.score,
               record = data.record,
               max = Math.max(score, record),
               w = 53,
               h = 50;

        let min = 0;

        for(let i = 0, arr = config.stars, l = arr.length; (i | 0) < l; i+=1) {
            const elem = stars[i],
                  target = arr[i].target;

            if(target <= max) {
                min = target;

                if(elem.status < 2) {
                    elem.status = 2
                    elem.star.visible = true;
                    this._createFrameAnim(elem.star, "interfaceStarAnim", true, false, () => {
                        elem.bg.visible = false;
                        elem.star.frameName = "interfaceStarAnim_014.png";
                    });
                }

            } else {

                if(elem.status < 1) {
                    elem.blue.visible = elem.black.visible = true;
                    elem.status = 1;
                }

                const gr = elem.gr,
                      prg = this._extremum((score - min) / (target - min), 0, 1);

                elem.black.text = elem.text.text = String(target - score);

                //Mask
                /*
                gr.clear();
                gr.beginFill(0x000, 1);
                gr.lineStyle(0, 0x000, 0);
                gr.drawRect(-w / 2, h * (0.5 - prg), w, h * prg);
                gr.endFill();*/

                gr.position.y = h * (1 - prg)

                break;
            }
        }
    }

    _getStarsPoint() {
        const stars = this.stars;
        let p = false;

        for(let i = 0, arr = stars, l = arr.length; (i | 0) < l; i+=1) {
            const star = arr[i];
            if(star.status == 1) {
                const pos = star.star.position;
                p = {x: -55 + pos.x, y: -253 + pos.y};
                break;
            }
        }

        return p;
    }

    addLootAnim(x = 0, y = 0, type) {//

        let pack;//{x, y, image}

        switch(type) {
            case "coin_static":
                pack = {
                    image: "Stt_coin_static",
                    x: -259,
                    y: -291
                };
                break;
            case "repair":
                pack = {
                    image: "Stt_Repair",
                    x: -50,
                    y: -300
                };
                break;
            case "amunition":
                pack = {
                    image: "Stt_Amunition",
                    x: -355,
                    y: -291
                };
                break;
            case "fuel":
                pack = {
                    image: "Stt_Fuel",
                    x: (this.game.isMobile ? -184 : -383),
                    y: 275
                };
                break;
            default:
                const point = this._getStarsPoint();
                if(!point) {
                    return;
                }
                pack = {
                    image: "galleryStar_02",
                    x: point.x,
                    y: point.y
                };
                break;
        }

        const p = this.game.camera.position,
              image = new Phaser.Image(this.game, x - 430, y - 320, pack.image);

        image.anchor.set(0.5);

        this.game.add.tween(image.position).to({x: pack.x, y: pack.y}, 420, "Linear").to({}, 20, "Linear", true).onComplete.add(() => {
            image.destroy();
        });

        this.game.add.tween(image.scale).to({x: 0.75, y: 0.75}, 440, "Linear", true);

        this.addChild(image);
    }

    update() {
        const data = this.levelData,
              money = this._money,
              bomb = this._bomb,
              hp = this._hp,
              dist = this._distance,
              fuel = this._fuel,
              speedometer = this._speedometer;

        //row
        switch(data.row) {
            case -1:
                this._leftRow.visible = true;
                this._rightRow.visible = false;
                break;
            case 1:
                this._leftRow.visible = false;
                this._rightRow.visible = true;
                break;
            default:
                this._leftRow.visible = false;
                this._rightRow.visible = false;
                break;
        };

        //money
        if(Number(money.text) < data.money) {
            this._startAnim(money, "_animGreen");
        }

        const checkList = [
            {
                self: hp,
                x0: hp._value,
                x: data.health,
                min: .3,
                f: () => {this.girlTalk("CAR NEEDS\NREPAIR!", 0);}
            },
            {
                self: bomb,
                x0: Number(bomb.text),
                x: data.bomb,
                min: 2
            },
            {
                self: fuel,
                x0: Number(fuel._value || 0),
                x: data.fuel,
                min: .2,
                f: () => {this.girlTalk("YOU OUT OF\nFUEL!", 0);}
            }
        ];

        for(let i = 0, arr = checkList, l = arr.length; (i | 0) < l; i+=1) {
            const elem = arr[i];

            if(elem.x < elem.min) {

                if(elem.self._animRed.isPaused) {
                    if(elem.self._animGreen.isRunning)elem.self._animGreen.pause();
                    this._startAnim(elem.self, "_animRed");

                    if(elem.f)elem.f();
                }

            } else {

                if(!elem.self._animRed.isPaused)elem.self._animRed.pause();

                if(elem.x0 < elem.x) {
                    this._startAnim(elem.self, "_animGreen");
                } else if(elem.self._animGreen.isPaused) {
                    elem.self._anim.visible = false;
                }
            }
        }

        //Set value
        bomb.text = data.bomb;
        money.text = data.money;
        hp._i_mask.position.x = (data.health - 1) * 185;
        hp._value = data.health;
        dist._i_mask.position.x = this.game.isMobile ? (data.progress - 1) * 129 - 56 : (data.progress - 1) * 185;//;//56
        //dist.scale.x = 0.7;

        //fuel
        const fuelFrame = Math.round(this._extremum(data.fuel * 100, 1, 100));
        if(fuelFrame < 20) {
            if(fuel._animLampo.isPaused) {
                fuel._animLampo.resume();
                fuel._animLampo.start();
            }
            fuel._lampo.visible = true;
        } else {
            if(!fuel._animLampo.isPaused) {
                fuel._animLampo.pause();
            }
            fuel._lampo.visible = false;
        }
        fuel.frameName = this._getFrameTo("fuelMinMaxAnim", fuelFrame);
        fuel._value = data.fuel;

        //speed
        const speedFrame = this._extremum(Math.abs(Math.round(data.speed)), 1, 100),
              speedKey = speedFrame < 51 ? "gameInterface2" : "gameInterface3";
        if(speedometer.key != speedKey) {
            speedometer.loadTexture(speedKey);
        }

        speedometer.frameName = this._getFrameTo("speedAnim", speedFrame);


        for(let i = 0, arr = [3, 1, 2, 4], images = [4, 1, 2, 3], elems = this._boosters, status = data.boosters, l = arr.length; (i | 0) < l; i+=1) {
            const elem = elems[i],
                  num = arr[i];

            elem.frameName = "bosterIco" + images[i] + "" + (status[num - 1] ? "_002.png" : "_001.png");
        }

        this._starsUpdate();
    }
};
;DP3.Loader = class extends Phaser.Sprite {
    constructor(settings) {
        super(settings.game);
        let conf = settings || {};
        this.game = settings.game;
        this.sound = settings.sound;

        this.onLoadCallback = conf.onLoad || null;

        this.data = {
            width: conf.width || 800,
            height: conf.height || 600,
            load: false,
            countRes: 0,
            lastProgressValue: 0,
            progressValue: 0,
            open: false
        };

        this.status = false;

        this.resources = null;
        this.listLoadRes = [];

        this.basePath = conf.basePath || "";
        this._json = conf.json;
        this._pacRes = conf.pacRes;

        this.game.load.onFileComplete.add((progress) => {
            h5branding.SplashLoader.getInstance().setLoadProgress(progress);
        });

        h5branding.SplashLoader.getInstance().setButtonCallback(() => {
            h5branding.SplashLoader.getInstance().destroy();
            this.game.scale.trackParentInterval = 2000;
            h5ads.adWrapper.on(h5ads.AdEvents.CONTENT_PAUSED, () => {
                h5branding.google.sendScreenView('advertisement_splash');
                this.game.paused = true;
                this.sound.pauseAll();
            });
            h5ads.adWrapper.on(h5ads.AdEvents.CONTENT_RESUMED, () => {
                this.game.paused = false;
                this.sound.resumeAll();
                h5ads.adWrapper.removeAllListeners(h5ads.AdEvents.CONTENT_PAUSED);
                h5ads.adWrapper.removeAllListeners(h5ads.AdEvents.CONTENT_RESUMED);
            });
            h5ads.adWrapper.showAd(h5ads.AdType.interstitial);

        });

        this.loadJson();
    }

    loadPackage(name, cb) {
        this._clear();
        this.openPreloader();
        this.loadResources(name);
        this.onLoadCallback = cb;
    }

    loadPackages(arr, cb) {
        this._clear();
        this.openPreloader();
        for(let i = 0, l = arr.length; (i | 0) < l; i+=1) {
            let pac = this.game.cache.getJSON('pacRes')[arr[i]];
            if(pac) {
                this.listLoadRes = this.listLoadRes.concat(pac);
            }
        }
        this.data.countRes = this.listLoadRes.length;
        this.onLoadCallback = cb;
        this.startLoad();
    }

    loadJson() {
        this.game.load.onLoadComplete.addOnce(() => {
            this.resources = this.game.cache.getJSON('resources')["resources"];
            this.loadResources("main");
        });
        if(this._json && this._pacRes) {
            this.game.load.json("resources", this._json);
            this.game.load.json("pacRes", this._pacRes);
        }
    }

    _setListResources(res) {
        let arr = this.game.cache.getJSON('pacRes')[res];
        this.listLoadRes = arr.slice(0, arr.length);
        this.data.countRes = arr.length;
    }

    loadResources(pac) {
        this._setListResources(pac);
        this.startLoad();
    }

    addElement(name) {
        const data = this.resources[name];

        if(data) {
            switch(data.type){
                case "music":
                    if(!this.game.cache.checkSoundKey(name)) {
                        this.game.load.audio(name, this.basePath + data.url);
                    }
                    break;
                case "sound":
                    if(!this.game.cache.checkSoundKey(name)) {
                        this.game.load.audio(name, this.basePath + data.url);
                    }
                    break;
                case "atlas":
                    if(!this.game.cache.checkImageKey(name)) {
                        this.game.load.atlas(name, this.basePath + data.url, this.basePath + data.json);
                    }
                    break;
                case "json":
                    if(!this.game.cache.checkJSONKey(name)) {
                        this.game.load.json(name, this.basePath + data.url);
                    }
                    break;
                case "void":
                    break;
                default:
                    if(!this.game.cache.checkImageKey(name) && data.url) {
                        this.game.load.image(name, this.basePath + data.url);
                    }
                    break;
            }
        }
    }

    checkingList(list) {
        const res = [];
        if(list) {
            const check = list.reduce((acum, name) => {
                acum[name] = true;
                return acum;
            }, {});

            for(let key in check) {
                res.push(key);
            }
        }

        return res;
    }

    _addAllMusic(list) {
        if(list) {
            for(let i = 0, l = list.length; (i | 0) < l; i+=1) {
                const name = list[i],
                      data = this.resources[name];

                if(data.type === "sound") {
                    this.sound.addSound(name);
                } else if(data.type === "music") {
                    this.sound.addMusic(name);
                }
            }
        }
    }

    _searchSounds(list) {
        const res = [];
        if(list) {
            for(let i = 0, l = list.length; (i | 0) < l; i+=1) {
                const name = list[i],
                      data = this.resources[name];

                if(data.type === "sound" || data.type === "music") {
                    res.push(name);
                }
            }
        }
        return res;
    }

    startLoad() {
        const list = this.checkingList(this.listLoadRes),
              soundsList = this._searchSounds(list);

        for(let i = 0, l = list.length; (i | 0) < l; i+=1) {
            this.addElement(list[i]);
        }

        this.game.load.onLoadComplete.addOnce(() => {
            this._addAllMusic(soundsList);
            this.sound.decodeAll(() => {
                this._onLoad();
            });
        });

        this.game.load.start();
    }

    _createPreloader() {
        let wrap = new Phaser.Sprite(this.game, 0, 0),
            w = 960,
            h = 640,
            left = new Phaser.Sprite(this.game, -600, 0),
            right = new Phaser.Image(this.game, 500, 0, "goalRight"),
            leftBg = new Phaser.Image(this.game, 0, 0, "goalLeft"),
            prePlash = new Phaser.Image(this.game, 0, 0, "prePlash"),
            glowPreloader = new Phaser.Image(this.game, 0, 0, "glowPreloader"),
            scaleX = this.data.width / w,
            scaleY = this.data.height / h,
            bg = new Phaser.Graphics(this.game),
            mask = new Phaser.Graphics(this.game);

        bg.beginFill(0x000000, 0);
        bg.lineStyle(0, 0xffd900, 1);
        bg.drawRect(- w / 2, - h / 2, w, h);

        wrap.scale.set(scaleY);
        wrap.position.set(this.data.width / 2, this.data.height / 2);

        this.inputEnabled = true;

        prePlash.anchor.set(0.5, 0.5);
        glowPreloader.anchor.set(0.5, 0.5);

        glowPreloader.mask = mask;
        this._preloaderMask = mask;

        this._updateProgressLine(0);

        right.anchor.set(0, 0.5);
        leftBg.anchor.set(1, 0.5);

        leftBg.position.x = 80;

        left.addChild(leftBg);
        left.addChild(glowPreloader);
        left.addChild(prePlash);
        left.addChild(mask);

        wrap.addChild(bg);
        wrap.addChild(right);
        wrap.addChild(left);
        this.addChild(wrap);

        wrap._left = left;
        wrap._right = right;

        this.preloader = wrap;
    }

    _checkLoadingStatus() {
        if(this.preloader && this.data.open && this.data.load && (this.data.lastProgressValue >= 1)) {
            this.closePreloader();
            this._ready();
        }
    }

    _onLoad() {
        this.data.load = true;
        if(this.preloader) {
            this._checkLoadingStatus();
        } else {
            this._ready();
        }
    }

    _ready() {
        h5branding.SplashLoader.getInstance().setLoadProgress(100);
        this.status = true;
        if(this.onLoadCallback) {
            this.onLoadCallback();
        }
    }

    _clear() {
        this.data.progressValue = this.data.lastProgressValue = 0;
        this.data.load = false;
        this.status = true;
        this.listLoadRes = [];
        this._setProgressLine(0);
    }

    _updateProgressValue() {
        this.data.progressValue = this.data.load ? 1 : this.game.load.progress / 100;
    }

    _updateProgressLine() {
        let num0 = this.data.lastProgressValue,
            num1 = this.data.progressValue,
            value = num1,
            maxSpeed = 0.05;

        if(num1 - num0 < maxSpeed) {
            value = num1;
        } else {
            value = num0 + maxSpeed;
        }

        if(value > 1) {
            value = 1;
        }

        this.data.lastProgressValue = value;
        this._setProgressLine(value);
    }

    _setProgressLine(value) {
        if(this._preloaderMask) {
            let gr = this._preloaderMask;
            gr.clear();
            gr.lineStyle(0, 0x000000);
            gr.beginFill(0x000000);
            gr.arc(0, 0, 300, Math.PI * (2 * value - 0.475), - Math.PI*0.5, true);
            gr.endFill();
        }
    }

    openPreloader() {
        if(!this.preloader) {
            this._createPreloader();
        }

        this.data.open = true;

        this.addChild(this.preloader);
        let tween = this.game.add.tween(this.preloader._left.position).to({x: 0}, 700, Phaser.Easing.Bounce.Out, true),
            tween1 = this.game.add.tween(this.preloader._right.position).to({x: 0}, 700, Phaser.Easing.Bounce.Out, true);

        tween.onComplete.addOnce(() => {this.status = false;});

        this.sound.stopAll();

        this.sound.play("112_SlashScreen_sn", false);
    }

    closePreloader() {
        if(this.preloader) {

            this.data.open = false;

            let tween = this.game.add.tween(this.preloader._left.position).to({x: -1200}, 500, "Linear", true),
                tween1 = this.game.add.tween(this.preloader._right.position).to({x: 1000}, 500, "Linear", true);
            tween.onComplete.addOnce(() => {this.removeChild(this.preloader);});
        }
    }

    update() {
        if(this.status)return;
        this._updateProgressValue();
        this._updateProgressLine();
        this._checkLoadingStatus();
    }

    /*loadElement(lf, cb) {
        this.game.load.onLoadComplete.addOnce(cb);
        lf();
        this.game.load.start();
    }*/
};
;DP3.UICore = class extends DP3.Sprite {
    constructor(settings) {
        super(settings.game);
        let conf = settings || {};
        this.game = conf.game;
        this.core = conf.core;

        this.data = {
            stars: this.getUser().getStars(),
            elements: [],
            size: {
                width: 800,
                height: 600
            },
            pages: [],
            callbacks: conf.callbacks || {}
        };

        this.marckersCache = {};

        this.create();
    }

    _checkDevice() {
        if(this.game.isMobile)this._initMobileInputs();
    }

    _initMobileInputs() {
        this._mobInp = {
            "left": false,
            "right": false,
            "top": false,
            "bottom": false,
            "turrLeft": false,
            "turrRight": true,
            "rocket": false,
            "burn": false,
            "shift": false,
            "animLamp": this._mobileLampoAnim.bind(this)
        };
    }

    _setMobInp(name, bool) {
        if(this._mobInp) {
            this._mobInp[name] = !!bool;
        }
    }

    getMobileData() {
        return this._mobInp || false;
    }

    _turnMobile() {
        if(this._mobInp) {
            if(this._mobInp.turrLeft) {
                this._mobInp.turrLeft = false;
                this._mobInp.turrRight = true;
            } else {
                this._mobInp.turrLeft = true;
                this._mobInp.turrRight = false;
            }
        }
    }

    _createMobileInputs() {
        if(this._mobInpWrap)return;

        const wrap = this.getWrap(),
              d = 55,
              y = 234,
              y2 = 275,
              x1 = -326,
              x2 = 225,
              d2 = 76,
              instr = [
                  {
                      image: "ui-r",
                      position: [d + x1, y],
                      cb1: () => {this._setMobInp("bottom", true);},
                      cb2: () => {this._setMobInp("bottom", false);}
                  },
                  {
                      image: "ui-l",
                      position: [-d + x1, y],
                      cb1: () => {this._setMobInp("top", true);},
                      cb2: () => {this._setMobInp("top", false);}
                  },
                  {
                      image: "ui-t",
                      position: [x1, -d + y],
                      cb1: () => {this._setMobInp("right", true);},
                      cb2: () => {this._setMobInp("right", false);}
                  },
                  {
                      image: "ui-b",
                      position: [x1, d + y],
                      cb1: () => {this._setMobInp("left", true);},
                      cb2: () => {this._setMobInp("left", false);}
                  },
                  {
                      image: "ui-1",
                      position: [x2, y2],
                      cb3: () => {this._turnMobile();}
                  },
                  {
                      image: "ui-2",
                      position: [d2 + x2, y2],
                      cb1: () => {this._setMobInp("rocket", true);},
                      cb2: () => {this._setMobInp("rocket", false);}
                  },
                  {
                      image: "ui-3",
                      position: [d2 * 2 + x2, y2],
                      cb1: () => {this._setMobInp("burn", true);},
                      cb2: () => {this._setMobInp("burn", false);}
                  },
                  {
                      image: "shift-btn",
                      position: [-72, 287],
                      cb3: () => {this._setMobInp("shift", true);}
                  }
              ],
              animLamp = new Phaser.Image(this.game, -72, 244, "ui-light");

        for(let i = 0, arr = instr, l = arr.length; i < l; i+=1) {
            const data = arr[i],
                  button = new Phaser.Button(this.game, data.position[0], data.position[1], data.image);

            if(data.cb1) {
                button.events.onInputOver.add(data.cb1);
                button.events.onInputDown.add(data.cb1);
            }

            if(data.cb2) {
                button.events.onInputOut.add(data.cb2);
                button.events.onInputUp.add(data.cb2);
            }

            if(data.cb3) {
                button.events.onInputDown.add(data.cb3);
            }

            if(data.rotation) {
                button.rotation = data.rotation;
            }

            //button.alpha = 0.8;

            button.anchor.set(0.5);
            wrap.addChild(button);
        }

        animLamp.anchor.set(0.5);
        animLamp.visible = false;
        this.__mbl_lamp = animLamp;
        wrap.addChild(animLamp);

        return wrap;
    }

    _mobileLampoAnim(status) {
        const lamp = this.__mbl_lamp;

        if(!lamp)return;

        if(status && !lamp.visible) {
            lamp.visible = true;
            lamp.alpha = 0;
            lamp.tween = this.game.add.tween(lamp).to({alpha: 1}, 300, "Linear").to({alpha: 0}, 300, "Linear", true).loop(true);
        } else if(!status) {
            lamp.visible = false;
            if(lamp.tween) {
                lamp.tween.stop();
                lamp.tween = null;
            }
        }
    }

    create() {
        this.openMainMenuPage();

        this._checkDevice();

        //this.openLocalSaveMenu();
    }

    _addSoundForButton(button) {
        if(!button)return;

        button.onInputOver.add(() => {
            this.sndBtnOver();
        });

        button.onInputDown.add(() => {
            this.sndBtnDown();
        });
    }

    sndBtnOver() {
        this.core.sound.play("104_ButtonOver_sn");
    }

    sndBtnDown() {
        this.core.sound.play("39_Button_sn");
    }

    sndOpenWindow() {
        this.core.sound.play("113_ShowWindow_sn");
    }

    sndHideWindow() {
        this.core.sound.play("110_HideWindow_sn");
    }

    openMainMenuPage() {
        DP3.isMainMenu = true; //hacky fix, no time to put in proper one
        if(DP3.sendMenuEvents) {
            h5branding.google.sendScreenView('main_menu');
            DP3.sendMenuEvents = false;
        }
        this._calculStars();
        let sound = this.core.sound,
            wrap = this.getWrap(),
            mainImage = this.game.cache.getImage("backgroundMainMenu"),
            back = new Phaser.Image(this.game, 0, 0, "backgroundMainMenu"),
            tank = new Phaser.Image(this.game, 0, 0, "tank"),
            bloodPrt01 = new Phaser.Image(this.game, 0, 0, "blood_prt01"),
            bloodPrt02 = new Phaser.Image(this.game, 0, 0, "blood_prt02"),
            bloodPrt03 = new Phaser.Image(this.game, 0, 0, "blood_prt03"),
            bloodPrt04 = new Phaser.Image(this.game, 0, 0, "blood_prt04"),
            blood1 = new Phaser.Image(this.game, 0, 0, "blood1"),
            blood2 = new Phaser.Image(this.game, 0, 0, "blood2"),
            blood21 = new Phaser.Image(this.game, 0, 0, "blood2"),
            dead = new Phaser.Image(this.game, 0, 0, "dead"),
            num3 = new Phaser.Image(this.game, 0, 0, "num3"),
            paradise = new Phaser.Image(this.game, 0, 0, "paradise"),
            title = this.getWrap(),
            num3Shadow = new Phaser.Image(this.game, 0, 0, "num3"),
            paradiseShadow = new Phaser.Image(this.game, 0, 0, "paradise"),
            sand = new Phaser.Image(this.game, 0, 0, "sand"),
            sand2 = new Phaser.Image(this.game, 0, 0, "sand"),
            dust01 = new Phaser.Image(this.game, 0, 0, "dust01"),
            dust02 = new Phaser.Image(this.game, 0, 0, "dust02"),
            dust03 = new Phaser.Image(this.game, 0, 0, "dust03"),
            dust04 = new Phaser.Image(this.game, 0, 0, "dust04"),
            titleShadow = this.getWrap(),
            blood = this.getWrap(),
            sandWrap = this.getWrap();

        back.anchor.set(0.5, 0.5);

        //Tank
        tank.anchor.set(1, 1);
        tank.position.set(mainImage.width * 0.5, mainImage.height * 0.5);

        //Title
        title.anchor.set(0.5, 0.5);
        titleShadow.anchor.set(0.5, 0.5);
        dead.anchor.set(0.5, 0.5);
        paradise.anchor.set(0.5, 0.5);
        num3.anchor.set(0.5, 0.5);
        paradiseShadow.anchor.set(0.5, 0.5);
        num3Shadow.anchor.set(0.5, 0.5);

        paradise.position.set(- mainImage.width * 0.055, - mainImage.height * 0.34);
        num3.position.set(mainImage.width * 0.212, - mainImage.height * 0.33);
        dead.position.set(- mainImage.width * 0.053, - mainImage.height * 0.417);
        title.addChild(paradise);
        title.addChild(num3);
        title.addChild(dead);

        paradiseShadow.tint = 0x000000;
        num3Shadow.tint = 0x000000;
        titleShadow.alpha = 0.6;
        paradiseShadow.position.set(- mainImage.width * 0.055, - mainImage.height * 0.34);
        num3Shadow.position.set(mainImage.width * 0.212, - mainImage.height * 0.33);
        titleShadow.addChild(paradiseShadow);
        titleShadow.addChild(num3Shadow);
        titleShadow.position.set(-10, 8);

        //Blood
        blood1.anchor.set(0.5, 0.5);
        bloodPrt01.anchor.set(0.5, 0);
        bloodPrt02.anchor.set(0.5, 0);
        bloodPrt03.anchor.set(0.5, 0);
        bloodPrt04.anchor.set(0.5, 0);
        blood2.anchor.set(0.5, 0.5);
        blood21.anchor.set(0.5, 0.5);

        blood1.position.set(mainImage.width * -0.34, mainImage.height * -0.13);
        blood2.position.set(mainImage.width * -0.3, mainImage.height * -0.395);
        blood21.position.set(mainImage.width * 0.13, mainImage.height * -0.3);
        blood21.rotation = Math.PI * 0.2;
        bloodPrt01.position.set(mainImage.width * -0.344, mainImage.height * -0.13);//80
        bloodPrt03.position.set(mainImage.width * -0.345, mainImage.height * -0.13);
        bloodPrt02.position.set(mainImage.width * -0.337, mainImage.height * -0.13);//70
        bloodPrt04.position.set(mainImage.width * -0.337, mainImage.height * -0.13);

        let arrParticles = [];
        for(let i = 0, l = 4; i < l; i+=1) {
            let w = new Phaser.Sprite(this.game),
                b = new Phaser.Image(this.game, 0, 0, 'blood3'),
                s = new Phaser.Image(this.game, 0, 0, 'blood3');

            b.anchor.set(0.5, 0.5);
            s.anchor.set(0.5, 0.5);

            s.position.set(0, -6.5);
            s.scale.set(0.4);
            b.rotation = Math.PI * 0.8;

            w.addChild(b);
            w.addChild(s);
            w.scale.set(0);
            arrParticles.push(w);
            blood.addChild(w);
        }

        arrParticles[0].position.set(mainImage.width * -0.28, mainImage.height * -0.19);
        arrParticles[0].rotation = Math.PI * 0.15;
        const tweenPr1 = this.game.add.tween(arrParticles[0].scale).to({}, 900, "Linear").to({x: 1.6, y: 1.6}, 500, Phaser.Easing.Back.Out, true);

        arrParticles[1].position.set(mainImage.width * -0.38, mainImage.height * -0.35);
        arrParticles[1].rotation = Math.PI * 0.05;
        const tweenPr2 = this.game.add.tween(arrParticles[1].scale).to({}, 700, "Linear").to({x: 1.5, y: 1.5}, 500, Phaser.Easing.Back.Out, true);

        arrParticles[2].position.set(mainImage.width * 0.2, mainImage.height * -0.19);
        arrParticles[2].rotation = -Math.PI * 0.15;
        const tweenPr3 = this.game.add.tween(arrParticles[2].scale).to({}, 500, "Linear").to({x: 1.4, y: 1.4}, 500, Phaser.Easing.Back.Out, true);

        arrParticles[3].position.set(mainImage.width * 0.18, mainImage.height * -0.4);
        arrParticles[3].rotation = Math.PI * 0.05;
        const tweenPr4 = this.game.add.tween(arrParticles[3].scale).to({}, 300, "Linear").to({x: 1, y: 1}, 500, Phaser.Easing.Back.Out, true);

        blood.addChild(bloodPrt01);
        blood.addChild(bloodPrt02);
        blood.addChild(bloodPrt03);
        blood.addChild(bloodPrt04);
        blood.addChild(blood1);
        blood.addChild(blood2);
        blood.addChild(blood21);


        dead.scale.set(1.5);

        blood1.scale.set(0);
        blood2.scale.set(0);
        blood21.scale.set(0);

        bloodPrt01.scale.y = 0;
        bloodPrt02.scale.y = 0;
        bloodPrt03.scale.y = 0;
        bloodPrt04.scale.y = 0;

        //Tween
        let tween = this.game.add.tween(sand.position).to({x: 3344}, 800, "Linear", true),
            tween2 = this.game.add.tween(sand2.position).to({x: 3344}, 800, "Linear", true),
            tween3 = this.game.add.tween(dust01.position).to({x: mainImage.width + this.game.cache.getImage("dust01").width}, 2000, "Linear").to({}, 1500, "Linear", true),
            tween4 = this.game.add.tween(dust02.position).to({}, 500, "Linear").to({x: mainImage.width + this.game.cache.getImage("dust02").width}, 2000, "Linear").to({}, 1000, "Linear", true),
            tween5 = this.game.add.tween(dust03.position).to({}, 1000, "Linear").to({x: mainImage.width + this.game.cache.getImage("dust03").width}, 2000, "Linear").to({}, 500, "Linear", true),
            tween6 = this.game.add.tween(dust04.position).to({}, 1500, "Linear").to({x: mainImage.width + this.game.cache.getImage("dust04").width}, 2000, "Linear", true);
        tween.loop(true);
        tween2.loop(true);
        tween3.loop(true);
        tween4.loop(true);
        tween5.loop(true);
        tween6.loop(true);

        //blood tween
        this.game.add.tween(dead.scale).to({}, 100, "Linear").to({x: 1, y: 1}, 600, Phaser.Easing.Back.Out, true);

        this.game.add.tween(blood1.scale).to({}, 400, "Linear").to({x: 1, y: 1}, 500, Phaser.Easing.Back.Out, true);
        this.game.add.tween(blood2.scale).to({}, 100, "Linear").to({x: 1, y: 1}, 500, Phaser.Easing.Back.Out, true);
        this.game.add.tween(blood21.scale).to({}, 300, "Linear").to({x: 0.65, y: 0.65}, 500, Phaser.Easing.Back.Out, true);
        this.game.add.tween(bloodPrt01.scale).to({}, 900, "Linear").to({y: 1}, 1500, "Linear", true);
        this.game.add.tween(bloodPrt01.position).to({}, 2400, "Linear").to({y: 315}, 20000, "Linear", true);//80 * scale - 170
        this.game.add.tween(bloodPrt03.scale).to({}, 2400, "Linear").to({y: 10}, 20000, "Linear", true);

        this.game.add.tween(bloodPrt02.scale).to({}, 4900, "Linear").to({y: 1}, 1400, "Linear", true);
        this.game.add.tween(bloodPrt02.position).to({}, 6300, "Linear").to({y: 335}, 23000, "Linear", true);//70 * scale - 170
        this.game.add.tween(bloodPrt04.scale).to({}, 6300, "Linear").to({y: 12}, 23000, "Linear", true);

        //Sand and dust
        sand.anchor.set(1, 1);
        sand2.anchor.set(0, 1);
        dust01.anchor.set(1, 1);
        dust02.anchor.set(1, 1);
        dust03.anchor.set(1, 1);
        dust04.anchor.set(1, 1);
        sandWrap.alpha = 0.5;
        sandWrap.addChild(dust01);
        sandWrap.addChild(dust02);
        sandWrap.addChild(dust03);
        sandWrap.addChild(dust04);
        sandWrap.addChild(sand);
        sandWrap.addChild(sand2);
        sandWrap.position.set(mainImage.width * -0.5, mainImage.height * 0.2);

        //Buttons
        let playButton = new Phaser.Button(this.game, 0, 0, "button1", () => {this.openLocalSaveMenu();}, this, "btnNextMenu_002.png", "btnNextMenu_001.png", "btnNextMenu_001.png", "btnNextMenu_001.png");
        playButton.anchor.set(0.5, 0.5);
        playButton.scale.set(1.1);
        playButton.position.set(0, mainImage.height * 0.18);
        this._addSoundForButton(playButton);

        let infoButton = new Phaser.Button(this.game, 0, 0, "button1", this.openInfoMenu, this, "btnInfoSmall_002.png", "btnInfoSmall_001.png", "btnInfoSmall_003.png", "btnInfoSmall_001.png");
        infoButton.anchor.set(0.5, 0.5);
        infoButton.scale.set(0.82);
        infoButton.position.set(mainImage.width * (-0.4), mainImage.height * (-0.45));
        this._addSoundForButton(infoButton);

        let helpButton = new Phaser.Button(this.game, 0, 0, "button1", this.openHelpMenu, this, "btnHelp_002.png", "btnHelp_001.png", "btnHelp_003.png", "btnHelp_001.png");
        helpButton.anchor.set(0.5, 0.5);
        helpButton.scale.set(0.82);
        helpButton.position.set(mainImage.width * 0.33, mainImage.height * (-0.45));
        this._addSoundForButton(helpButton);

        let settingsButton = new Phaser.Button(this.game, 0, 0, "button1", this.openSettingsMenu, this, "btnSettings_002.png", "btnSettings_001.png", "btnSettings_003.png", "btnSettings_001.png");
        settingsButton.anchor.set(0.5, 0.5);
        settingsButton.scale.set(0.82);
        settingsButton.position.set(mainImage.width * 0.4, mainImage.height * (-0.45));
        this._addSoundForButton(settingsButton);

        const textWrap = this.getWrap();

        let text = new Phaser.Text(this.game, -20, 4, "PLAY", {fontSize: 32, fontWeight: "bold", fill: "#4ffef0", font: DP3.font1, stroke: "#000000", strokeThickness: 3});
        text.anchor.set(0.5, 0.5);
        textWrap.addChild(text);

        let icon = new Phaser.Image(this.game, 50, 1, "icoSmall", "icoSmall1_001.png");
        icon.anchor.set(0.5, 0.5);
        icon.scale.set(0.75);
        textWrap.addChild(icon);

        playButton.addChild(textWrap);

        //playButton._text = text;
        //playButton._icon = icon;

        playButton.onInputOut.add(() => {
            textWrap.scale.set(1);
        });

        playButton.onInputOver.add(() => {
            textWrap.scale.set(1.08);
        });

        playButton.onInputDown.add(() => {
            icon.frameName = "icoSmall1_003.png";
            text.fill = "#000";
            text.stroke = "#919394";
            textWrap.scale.set(1);
        }, this);

        playButton.onInputUp.add(() => {
            icon.frameName = "icoSmall1_001.png";
            text.fill = "#00ffe9";
            text.stroke = "#000000";
        }, this);

        //this.game.add.image(0, 0, "button1");

        wrap.addChild(back);
        wrap.addChild(sandWrap);
        wrap.addChild(tank);
        wrap.addChild(blood);
        wrap.addChild(titleShadow);
        wrap.addChild(title);

        wrap.addChild(settingsButton);
        wrap.addChild(helpButton);
        wrap.addChild(infoButton);
        wrap.addChild(playButton);

        this.game.time.events.add(800, () => {sound.play("109_TextShow_sn")});
        sound.play("72_Blood_sn");

        this.addPage(wrap);
    }

    _close_crp_and_lvm(wrap, back, left, right, cb, anim) {
        this.coverPages();

        if(anim && anim instanceof Function) {
            anim();
        }

        this.game.add.tween(back).to({}, 400).to({alpha: 0}, 300, "Linear", true);

        const x1 = left._def_x,
              y1 = left._def_y,
              x2 = right._def_x,
              y2 = right._def_y;

        this.game.add.tween(left.position).to({}, 700).to({x: x1 - 244, y: y1}, 250, "Linear", true);
        this.game.add.tween(right.position).to({}, 700).to({x: x2 + 380, y: y2}, 250, "Linear", true).onComplete.add(() => {this.uncoverPages(); this.removePage(wrap); if(cb) {cb();}});
    }

    openTutorPage(type, anim = true) {
        h5branding.google.sendScreenView('tutorial');
        let wrap = this.getWrap(),
            self = this,
            control = this.core.getUser().getSetting("turret"),
            msc = 1 / this.getMainScaleUI(),
            w = msc * this.data.size.width,
            h = msc * this.data.size.height,
            bg = this.getBGGraphics(0.7),
            mainSection = this.getWrap(),
            secondSection = this.getWrap(),
            panel = new Phaser.Image(this.game, 0, 0, "bustersPanel"),
            railL = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            railR = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            title = new Phaser.Text(this.game, 0, 0, "LET'S GET STARTED!", {fill: "#ffffff", fontSize: 32, font: DP3.font2}),
            girl = new Phaser.Image(this.game, 0, 0, "girl"),
            close = (cb) => {
                h5branding.google.sendScreenView('gameplay');
                this.coverPages();
                this.sndHideWindow();

                const x = mainSection._def_x,
                      y = mainSection._def_y + 460,
                      x1 = secondSection._def_x,
                      y1 = secondSection._def_y + 120,
                      x2 = girl._def_x + 450,
                      y2 = girl._def_y,
                      x3 = title._def_x + 450,
                      y3 = title._def_y;

                this.game.add.tween(mainSection.position).to({}, 130, "Linear").to({x: x, y: y}, 250, "Linear", true).onComplete.add(() => {
                    this.uncoverPages();
                    this.removePage(wrap);
                    if(cb && cb instanceof Function)cb();
                });
                this.game.add.tween(secondSection.position).to({x: x1, y: y1}, 80, "Linear", true);
                this.game.add.tween(bg).to({alpha: 0}, 380, "Linear", true);
                this.game.add.tween(girl.position).to({x: x2, y: y2}, 380, "Linear", true);
                this.game.add.tween(title.position).to({x: x3, y: y3}, 380, "Linear", true);
                this.game.add.tween(title).to({alpha: 0}, 380, "Linear", true);
            };

        railL.anchor.set(0.5, 0.1);
        railR.anchor.set(0.5, 0.1);
        title.anchor.set(0.5, 1);

        railL.position.set(-402, 310);
        railR.position.set(142, 310);
        railL.scale.set(1, -1);
        railR.scale.set(-1, -1);

        panel.anchor.set(0.5, 0.5);
        title.anchor.set(0.5, 1);
        girl.anchor.set(0.5, 1);

        wrap.addChild(bg);

        secondSection.addChild(panel);

        let playButton;

        switch(Number(type)) {
            case 1: {
                playButton = this._getPlayButton(() => {close(this.data.callbacks.playLevel);});

                if(this.game.isMobile) {
                    const sprite = new Phaser.Image(this.game, 0, 0, "ui-help"),
                          textSettings = [
                            {
                                text: "move forward",
                                positions: [-265, -320]
                            },
                            {
                                text: "balance left",
                                positions: [-325, -245]
                            },
                            {
                                text: "turn gun\naround",
                                positions: [-211, 182],
                                styles: {align: "center"},
                                lineSpacing: -6
                            },
                            {
                                text: "launch\nrockets",
                                positions: [0, 182],
                                styles: {align: "center"},
                                lineSpacing: -6
                            },
                            {
                                text: "use fuel\nto scroch\nenemies",
                                positions: [211, 195],
                                styles: {align: "center"},
                                lineSpacing: -6
                            },
                            {
                                text: "balance right",
                                positions: [340, -245]
                            },
                            {
                                text: "move backward",
                                positions: [280, -163]
                            }
                        ];

                    sprite.position.set(0, -60);
                    sprite.scale.set(0.85);
                    sprite.anchor.set(0.5);

                    secondSection.addChild(sprite);
                    this.drawTextToInstructions(textSettings, secondSection);
                } else {
                    const tutor1 = new Phaser.Image(this.game, 0, -50, "tutor1"),
                          textStyle = {
                            font: DP3.font4,
                            fontSize: 15,
                            fill: "#ffffff",
                            stroke: "#414141",
                            strokeThickness: 2
                          },
                            textSettings = [
                                {
                                    text: "move forward",
                                    positions: [-170, -340],
                                    anchor: [1, 0.5]
                                },
                                {
                                    text: "balance left",
                                    positions: [-230, -250],
                                    anchor: [1, 0.5]
                                },
                                {
                                    text: "balance right",
                                    positions: [200, -250],
                                    anchor: [0, 0.5]
                                },
                                {
                                    text: "move backward",
                                    positions: [150, -180],
                                    anchor: [0, 0.5]
                                },
                                {
                                    text: "launch rockets",
                                    positions: [-170, -125],
                                    anchor: [1, 0.5]
                                },
                                {
                                    text: "turn gun\nback",
                                    positions: [-100, 195],
                                    anchor: [0.5, 0],
                                    styles: {
                                        align: "center"
                                    }
                                },
                                {
                                    text: "turn gun\nforward",
                                    positions: [85, 195],
                                    anchor: [0.5, 0],
                                    styles: {
                                        align: "center"
                                    }
                                },
                                {
                                    text: control ? "Q" : "Z",
                                    positions: [-117, 115],
                                    anchor: [0.5, 0.5],
                                    styles: {
                                        fill: "0x000000",
                                        font: DP3.font1,
                                        fontWeight: "bold"
                                    }
                                },
                                {
                                    text: control ? "W" : "X",
                                    positions: [68, 115],
                                    anchor: [0.5, 0.5],
                                    styles: {
                                        fill: "0x000000",
                                        font: DP3.font1,
                                        fontWeight: "bold"
                                    }
                                }
                            ],
                            linesSettings = [
                                {
                                    points: [[0, 0], [98, 0]],
                                    positions: [-160, -340]
                                },
                                {
                                    points: [[0, 0], [65, 0]],
                                    positions: [-220, -250]
                                },
                                {
                                    points: [[0, 0], [-62, 0]],
                                    positions: [190, -250]
                                },
                                {
                                    points: [[0, 0], [-150, 0]],
                                    positions: [140, -180]
                                },
                                {
                                    points: [[0, 0], [0, -35]],
                                    positions: [-10, -180]
                                },
                                {
                                    points: [[0, 0], [150, 0]],
                                    positions: [-160, -125]
                                },
                                {
                                    points: [[0, 0], [0, 23]],
                                    positions: [-10, -125]
                                },
                                {
                                    points: [[0, 0], [0, -24]],
                                    positions: [-100, 190]
                                },
                                {
                                    points: [[0, 0], [0, -24]],
                                    positions: [85, 190]
                                }
                            ];

                    for(let i = 0, arr = textSettings, l = arr.length; i < l; i+=1) {
                        if(arr[i].styles) {
                            const obj = arr[i].styles;
                            for(let key in textStyle) {
                                if(!obj.hasOwnProperty(key))obj[key] = textStyle[key];
                            }
                        } else {
                            arr[i].styles = textStyle;
                        }
                    }

                    tutor1.anchor.set(0.5, 0.5);

                    secondSection.addChild(tutor1);

                    this._drawInfo(textSettings, linesSettings, secondSection);

                    //Guns
                    for(let i = 0, arr = [{x: -130, y: 85, mir: true}, {x: 120, y: 85}], l = arr.length; i < l; i+=1) {
                        const elem = arr[i],
                              wrap = this.getWrap(),
                              gun = new Phaser.Sprite(this.game, 20, -35, "pc0_1", "barrelAmbulance_001.png"),
                              turret = new Phaser.Image(this.game, 0, 0, "pc0_1", "turelHullAmbulance.png"),
                              L = -Math.PI / 12;

                        wrap.position.set(elem.x, elem.y);

                        gun.rotation = L;

                        turret.scale.set(-1, 1);

                        turret.anchor.set(0.5);
                        gun.anchor.set(0.5);

                        wrap.scale.set((elem.mir ? -1 : 1) * 0.8, 0.8);

                        wrap.addChild(gun);
                        wrap.addChild(turret);

                        secondSection.addChild(wrap);
                    }
                }

                secondSection.addChild(playButton);
                break;}
            case 2: {
                playButton = this._getPlayButton(() => {this.removePage(wrap); this.openTutorPage(0, false);}, "NEXT", {fill: "#00dbff", fontSize: 30, stroke: "#000", font: DP3.font4, strokeThickness: 4});

                const tutor2 = new Phaser.Image(this.game, 0, -100, "helpContent_002"),
                      textStyle = {
                        font: DP3.font4,
                        fontSize: 14,
                        fill: "#ffffff"
                      },
                      textSettings = [
                          {
                              text: "FUEL DUMPING",
                              positions: [0, -345],
                              anchor: [0.5, 1],
                              styles: {
                                  fontSize: 20
                              }
                          },
                          {
                              text: "Use your fuel wisely",
                              positions: [140, 30],
                              anchor: [0.5, 1],
                              styles: {
                                  fontSize: 20
                              }
                          },
                          {
                              text: "Use fuel to scorch\nenemies behind you!",
                              positions: [140, 190],
                              anchor: [0.5, 1],
                              styles: {
                                  fontSize: 18,
                                  fill: "#00ffe9",
                                  align: "center"
                              }
                          },
                          {
                              text: "dump\nfuel",
                              positions: [-200, 90],
                              anchor: [0.5, 0],
                              styles: {
                                  align: "center"
                              }
                          }
                      ],
                      linesSettings = [
                          {
                              points: [[0, 0], [0, -40]],
                              positions: [-200, 85]
                          }
                      ];

                for(let i = 0, arr = textSettings, l = arr.length; i < l; i+=1) {
                    if(arr[i].styles) {
                        const obj = arr[i].styles;
                        for(let key in textStyle) {
                            if(!obj.hasOwnProperty(key))obj[key] = textStyle[key];
                        }
                    } else {
                        arr[i].styles = textStyle;
                    }
                }

                tutor2.anchor.set(0.5, 0.5);
                tutor2.scale.set(0.9);

                secondSection.addChild(tutor2);

                if(this.game.isMobile) {
                    const mbbI = new Phaser.Image(this.game, -100, 0, "ui-3");
                    mbbI.scale.set(0.9);
                    mbbI.anchor.set(0.5);
                    secondSection.addChild(mbbI);
                }

                this._drawInfo(textSettings, linesSettings, secondSection);

                break;}
            default: {
                const text = new Phaser.Text(this.game, 0, -175, "BOOSTERS", {fill: "#ffffff", fontSize: 20, font: DP3.font3}),
                      user = this.core.getUser(),
                      money = Number(user.getVariable("money")) || 0,
                      moneyText = new Phaser.Text(this.game, -400, -305, "$ " + money, {fill: "#80e8f9", fontSize: 33, font: DP3.font2, stroke: "#182932", strokeThickness: 2}),
                      boostersStatus = user.getBoosters() || [],
                      boostersSettings = [
                          {
                              title: "EXTRA ROCKETS",
                              text: "Doubles your rockets\nstock.",
                              price: 750,
                              num:3
                          },
                          {
                              title: "MEGAHEALTH",
                              text: "Doubles your car's hit\npoints.",
                              price: 1500,
                              num:1
                          },
                          {
                              title: "EXTRA FUEL",
                              text: "Doubles your fuel tank\ncapacity.",
                              price: 500,
                              num:2
                          },
                          {
                              title: "DOUBLE DAMAGE",
                              text: "Doubles damage\ninflicted by your guns.",
                              price: 2000,
                              num:4
                          }
                      ];

                wrap.addChild(moneyText);
                moneyText.setShadow(0, 0, '#01d3c0', 5);

                if(anim) {
                    moneyText.alpha = 0;
                    this.game.add.tween(moneyText).to({alpha: 1}, 190, "Linear", true);
                }

                playButton = this._getPlayButton(() => {
                    this.game.add.tween(moneyText).to({alpha: 0}, 190, "Linear", true);
                    close(this.data.callbacks.playLevel);
                });
                title.text = "LET'S BUY SOME  POWERUPS!"


                for(let i = 0, arr = boostersSettings, l = arr.length; i < l; i+=1) {
                    const elem = arr[i],
                          row = this.getWrap(),
                          textWrap = this.getWrap(),
                          textStatus = new Phaser.Text(this.game, 200, 0, "ACTIVE", {fill: "#00ffe9", fontSize: 29, font: DP3.font1, fontWeight: "bold", stroke: "#182932", strokeThickness: 2}),
                          title = new Phaser.Text(this.game, -100, -5, elem.title, {fill: "#ffffff", fontSize: 20, font: DP3.font1, fontWeight: "bold", stroke: "#182932", strokeThickness: 2}),
                          text = new Phaser.Text(this.game, -100, -5, elem.text, {fill: "#00ffe9", fontSize: 14, font: DP3.font1, fontWeight: "bold", stroke: "#182932", strokeThickness: 2}),
                          price = new Phaser.Text(this.game, 200, -5, "$" + elem.price, {fill: "#00ffe9", fontSize: 20, font: DP3.font2, stroke: "#182932", strokeThickness: 2}),
                          image = new Phaser.Image(this.game, -200, 0, "busterShop1");

                    textStatus.anchor.set(1, 0.5);
                    title.anchor.set(0, 1);
                    text.anchor.set(0, 0);
                    price.anchor.set(1, 1);
                    image.anchor.set(0, 0.5);

                    textWrap.addChild(text);
                    textWrap.addChild(title);
                    textWrap.addChild(textStatus);
                    textWrap.addChild(price);

                    for(let j = 0, arr1 = [text, title, textStatus, price], k = arr1.length; j < k; j+=1) {
                        arr1[j].setShadow(0, 0, '#00a798', 5);
                    }

                    //active?
                    if(boostersStatus[elem.num - 1]) {
                        price.visible = false;
                        textStatus.text = "ACTIVE";
                        image.frameName = "busterSlot" + elem.num + "_003.png";
                    } else if(Number(elem.price) <= money) {//have money?
                        textStatus.visible = false;
                        image.frameName = "busterSlot" + elem.num + "_002.png";

                        const button = new Phaser.Button(this.game, 152, 15, "busterShop1", () => {
                            user.addTo(-elem.price, "money");
                            user.activeBoost(elem.num);
                            if(this.data.callbacks.activeBoost)this.data.callbacks.activeBoost(elem.num);
                            user.save();
                            this.removePage(wrap);
                            this.openTutorPage(0, false);
                        }, this, "btnBuyBooster_002.png", "btnBuyBooster_001.png", "btnBuyBooster_003.png", "btnBuyBooster_001.png"),
                              buttonText = new Phaser.Text(this.game, 0, 1.5, "BUY", {fill: "#00ffe9", fontSize: 23, font: DP3.font4, stroke: "#919394", strokeThickness: 0});

                        this._addSoundForButton(button);

                        buttonText.anchor.set(0.5);
                        button.anchor.set(0.5);

                        button.addChild(buttonText);

                        button.events.onInputDown.add(() => {
                            buttonText.fill = "#000";
                            buttonText.strokeThickness = 3;
                            buttonText.setShadow(0, 0, '#00ffe8', 0);
                        });
                        button.events.onInputOut.add(() => {
                            buttonText.setShadow(0, 0, '#00ffe8', 0);
                            buttonText.scale.set(1);
                        });
                        button.events.onInputOver.add(() => {
                            buttonText.setShadow(0, 0, '#00ffe8', 5);
                            buttonText.scale.set(1.05);
                        });

                        textWrap.addChild(button);
                    } else {
                        textStatus.text = "LOCKED";
                        image.frameName = "busterSlot" + elem.num + "_001.png";

                        textStatus.fontSize = 25;
                        textStatus.position.y = 15;

                        textWrap.alpha = 0.5;
                    }

                    row.addChild(image);
                    row.addChild(textWrap);

                    row.position.set(0, i * 77 - 135);

                    secondSection.addChild(row);
                }

                text.anchor.set(0.5, 1);

                secondSection.addChild(text);
                break;}
        }

        playButton.position.set(0, 177);
        secondSection.addChild(playButton);

        mainSection.addChild(secondSection);
        mainSection.addChild(railL);
        mainSection.addChild(railR);

        wrap.addChild(mainSection);
        wrap.addChild(title);
        wrap.addChild(girl);

        this.addPage(wrap);

        mainSection.position.x = mainSection._def_x = 0;
        mainSection.position.y = mainSection._def_y = 0;
        secondSection.position.x = secondSection._def_x = -130;
        secondSection.position.y = secondSection._def_y = 35;
        title.position.x = title._def_x = -130;
        title.position.y = title._def_y = -200;
        girl.position.x = girl._def_x = 295;
        girl.position.y = girl._def_y = h/2;

        if(!anim)return;

        this.coverPages();
        this.sndOpenWindow();

        const x = mainSection._def_x,
              y = mainSection._def_y,
              x1 = secondSection._def_x,
              y1 = secondSection._def_y,
              x2 = girl._def_x,
              y2 = girl._def_y,
              x3 = title._def_x,
              y3 = title._def_y;

        mainSection.position.set(x, y + 460);
        secondSection.position.set(x1, y1 + 120);
        girl.position.set(x2 + 450, y2);
        title.position.set(x3 + 450, y3);
        bg.alpha = 0;
        title.alpha = 0;

        this.game.add.tween(mainSection.position).to({x: x, y: y}, 250, "Linear", true);
        this.game.add.tween(secondSection.position).to({}, 300, "Linear").to({x: x1, y: y1}, 80, "Linear", true).onComplete.add(this.uncoverPages.bind(this));
        this.game.add.tween(bg).to({alpha: 1}, 380, "Linear", true);
        this.game.add.tween(girl.position).to({x: x2, y: y2}, 380, "Linear", true);
        this.game.add.tween(title.position).to({x: x3, y: y3}, 380, "Linear", true);
        this.game.add.tween(title).to({alpha: 1}, 380, "Linear", true);
    }

    getUser() {
        return this.core.getUser();
    }

    openCrossPromoPage() {
        this._calculStars();
        let wrap = this.getWrap(),
            countStars = String(this.getUser().getStars()),
            msc = 1 / this.getMainScaleUI(),
            w = msc * this.data.size.width,
            h = msc * this.data.size.height,
            back = new Phaser.Sprite(this.game, 0, 0),
            left = new Phaser.Image(this.game, 0, 0, "bgPlate02"),
            right = new Phaser.Image(this.game, 0, 0, "bgPlate01"),
            star = new Phaser.Image(this.game, 0, 0, "galleryStar_02"),
            textStar = new Phaser.Text(this.game, -w * 0.13, - h * (0.455) + 3, countStars, {fill: "#82ecfe", fontSize: 26, stroke: "#182932", strokeThickness: 3, font: DP3.font2}),
            textStar2 = new Phaser.Text(this.game, -w * 0.13, - h * (0.455), "/39", {fill: "#0065cb", fontSize: 26, stroke: "#182932", strokeThickness: 3, font: DP3.font2}),
            crossPromo = [],
            cpTexts = ["The city destroyed following a technological\ncatastrophe. You need to get out of this hell at any cost!", "The city was looted and captured by raiders. The only chance\nof survival is to evacuate to Area 51", "Help the survivors to reach the safe haven"],
            close = cb => this._close_crp_and_lvm.bind(this, wrap, back, left, right, cb, () => {
                for(let i = 0, arr = crossPromo, l = arr.length; i < l; i+=1) {
                    this.game.add.tween(arr[i]).to({alpha: 0}, 300, "Linear", true);
                }
            });

        left.anchor.set(0.1, 0.5);
        right.anchor.set(0.9, 0.5);
        back.anchor.set(0.5, 0.5);

        //Star
        textStar.anchor.set(1, 0.5);
        textStar.setShadow(0, 0, '#82ecfe', 5);
        textStar2.anchor.set(0, 0.5);
        star.anchor.set(0.5, 0.5);
        star.position.set(-w * 0.045, - h * (0.46));

        //Buttons
        let backButton = new Phaser.Button(this.game, 0, 0, "button1", this.data.callbacks.openMainMenu ? this.data.callbacks.openMainMenu : null, this, "btnBackSmall_002.png", "btnBackSmall_001.png", "btnBackSmall_003.png", "btnBackSmall_001.png");
        backButton.anchor.set(0.5, 0.5);
        backButton.scale.set(0.9);
        backButton.position.set(w * 0.045, - h * (0.43));
        this._addSoundForButton(backButton);

        let helpButton = new Phaser.Button(this.game, 0, 0, "button1", close(this.openHelpMenu.bind(this, true, this.openCrossPromoPage.bind(this))), this, "btnHelp_002.png", "btnHelp_001.png", "btnHelp_003.png", "btnHelp_001.png");
        helpButton.anchor.set(0.5, 0.5);
        helpButton.scale.set(0.9);
        helpButton.position.set(w * 0.045, h * (0.18));
        this._addSoundForButton(helpButton);

        let achivButton = new Phaser.Button(this.game, 0, 0, "button1", close(this.openAchivMenu.bind(this, true, this.openCrossPromoPage.bind(this))), this, "btnAchievementsSmall_002.png", "btnAchievementsSmall_001.png", "btnAchievementsSmall_003.png", "btnAchievementsSmall_001.png");
        achivButton.anchor.set(0.5, 0.5);
        achivButton.scale.set(0.9);
        achivButton.position.set(w * 0.045, h * (0.29));
        this._addSoundForButton(achivButton);

        let statButton = new Phaser.Button(this.game, 0, 0, "button1", close(this.openStatisticsMenu.bind(this, true, this.openCrossPromoPage.bind(this))), this, "btnStatisticsSmall_002.png", "btnStatisticsSmall_001.png", "btnStatisticsSmall_003.png", "btnStatisticsSmall_001.png");
        statButton.anchor.set(0.5, 0.5);
        statButton.scale.set(0.9);
        statButton.position.set(w * 0.045, h * (0.4));
        this._addSoundForButton(statButton);

        wrap.addChild(back);

        right.addChild(star);
        right.addChild(textStar);
        right.addChild(textStar2);

        left.addChild(helpButton);
        left.addChild(achivButton);

        if(this._checkAchivs()) {
            const achivAnim = this._getNewAchievementsAnim(0);
            achivAnim.position.set(w * 0.045, h * (0.29));
            left.addChild(achivAnim);
        }

        left.addChild(statButton);
        left.addChild(backButton);

        //crossPromo
        for(let i = 0, l = 3; i < l; i+=1) {
            let num = i + 1,
                select = (i == 2),
                defImage = select ? "galleryBtnActive_001" : "galleryBtnCommingSoon2_001",
                hoverImage = select ? "galleryBtnActive_002" : "galleryBtnCommingSoon2_002",
                textColor = select ? "#feef49" : "#f2c6b4",
                elem = new Phaser.Sprite(this.game, 0, w * (-0.25 + i * 0.175)),
                bg = new Phaser.Image(this.game, -320, 0, defImage),
                image = new Phaser.Image(this.game, -241, 74, "gallery6", "packIco" + num + "_001.png"),
                text = new Phaser.Text(this.game, 25, 42, "CHAPTER 0" + num, {fill: textColor, fontSize: 16, font: DP3.font2}),
                text2 = new Phaser.Text(this.game, 25, 85, "DEAD PARADISE " + (i ? num : ""), {fill: textColor, fontSize: 33, font: DP3.font5}),
                text3 = new Phaser.Text(this.game, -170, 112, cpTexts[i], {fill: select ? "#7ce5f8" : "#f2c6b4", fontSize: 15, font: DP3.font2});

            elem.inputEnabled = true;
            elem.input.useHandCursor = true;
            elem.events.onInputDown.add(select ? () => {this.sndBtnDown(); this.data.callbacks.openIntro();} : () => {
                //qwerty
                bg.loadTexture(hoverImage);
                this.game.time.events.add(200, () => {bg.loadTexture(defImage); elem._lock_blick = false;});
                this.sndBtnDown(); console.log("game " + num);
            }, this);
            elem.events.onInputOut.add(() => {bg.loadTexture(defImage); elem._lock_blick = false;}, this);
            elem.events.onInputOver.add(() => {this.sndBtnOver(); bg.loadTexture(hoverImage); elem._lock_blick = true;}, this);

            bg.anchor.set(0, 0);
            text.anchor.set(0.5, 1);
            text2.anchor.set(0.5, 1);
            text3.anchor.set(0, 0.5);
            image.anchor.set(0.5, 0.5);

            elem.addChild(bg);
            elem.addChild(image);
            elem.addChild(text);
            elem.addChild(text2);
            elem.addChild(text3);

            elem.bg = bg;

            if(select) {
                let starWrap = new Phaser.Sprite(this.game, 215, 110),
                    star = new Phaser.Image(this.game, 52, 0, "galleryStar_02"),
                    textStar = new Phaser.Text(this.game, 1, 4, countStars, {fill: "#82ecfe", fontSize: 21, stroke: "#182932", strokeThickness: 2, font: DP3.font2}),
                    textStar2 = new Phaser.Text(this.game, 0, 4, "/39", {fill: "#0065cb", fontSize: 21, stroke: "#182932", strokeThickness: 2, font: DP3.font2});

                textStar.anchor.set(1, 0.5);
                textStar.setShadow(0, 0, '#82ecfe', 5);
                textStar2.anchor.set(0, 0.5);
                star.anchor.set(0.5, 0.5);

                starWrap.addChild(star);
                starWrap.addChild(textStar);
                starWrap.addChild(textStar2);

                elem.addChild(starWrap);
            }
            crossPromo.push(elem);
            wrap.addChild(elem);
        }

        wrap.addChild(left);
        wrap.addChild(right);

        this.addPage(wrap);


        /////////Animations
        this.coverPages();
        ///Back
        const mapPos = [[0, 0], [-40, -3], [-50, -3], [-70, 0], [-70, -10], [-50, -7], [65, -6]];

        for(let i = 0, arr = ["map_prt02_0", "map_prt03_0", "map_prt04_0", "map_prt05_0", "map_prt01_0", "map_prt07_0", "map_prt06_0"], l = arr.length; i < l; i+=1) {
            const img = new Phaser.Image(this.game, 0, 0, arr[i]);
            img.alpha = 0;
            this.game.add.tween(img).to({}, i * 50 + 300, "Linear").to({alpha: 1}, 500, "Linear", true);
            //img.position.set(-358, -316.5);
            img.position.set(mapPos[i][0], mapPos[i][1]);
            img.anchor.set(0.5);
            back.addChild(img);
        }
        back.scale.set(1.05);

        back.addChild(this.getBGGraphics(0x000, 0.4));

        left.position.x = left._def_x = - w * 0.5;
        left.position.y = left._def_y = 0;
        right.position.x = right._def_x = w * 0.5;
        right.position.y = right._def_y = 0;

        const x1 = left._def_x,
              y1 = left._def_y,
              x2 = right._def_x,
              y2 = right._def_y;

        left.position.set(x1 - 122, y1);
        right.position.set(x2 + 190, y2);

        this.game.add.tween(left.position).to({x: x1, y: y1}, 300, "Linear", true);
        this.game.add.tween(right.position).to({x: x2, y: y2}, 300, "Linear", true);

        for(let i = 0, arr = crossPromo, l = arr.length; i < l; i+=1) {
            arr[i].alpha = 0;
            this.game.time.events.add(1000 + 150 * (i % 2), () => {this.game.add.tween(arr[i]).to({alpha: 1}, 300, "Linear", true)});
        }

        this.game.time.events.add(1500, () => {
            this.uncoverPages();

            const blick = this.game.add.tween(this).to({}, 300, "Linear", true);
            blick.loop(true);

            blick.onLoop.add(() => {
                const elem = crossPromo[2];
                if(!elem || !elem.parent) {
                    blick.stop();
                    return;
                }
                if(elem._lock_blick)return;
                elem._st_img = !elem._st_img;
                elem.bg.loadTexture(elem._st_img ? "galleryBtnActive_001" : "galleryBtnActive_002");
            });
        });
    }

    _calculStarsData(num = 1) {
        const config = this._getLevelConfig(num).stars,
              record = this.getUser().getRecordFrom(num),
              res = {
                  stars: 0,
                  progress: this._extremum(record / config[config.length - 1].target, 0, 1),
                  record: record
              };

        for(let i = 0, arr = config, l = arr.length; i < l; i+=1) {
            if(record < arr[i].target)break;
            res.stars+=1;
        }

        return res;
    }

    _calculStars() {
        let count = 0;

        for(let i = 0, l = 15; i < l; i+=1) {
            count+=this._calculStarsData(i + 1).stars;
        }

        this.data.stars = count;

        this.getUser().setStars(count);

        return count;
    }

    getStarsCount() {
        return this.data.stars;
    }

    _getNewAchievementsAnim(type = 0) {
        const data = ([["NewAchievements2", 30, 45, 0], ["NewAchievements", -30, -45, 1]])[type],
              wrap = this.getWrap(),
              image = new Phaser.Image(this.game, data[1], 0, data[0]),
              t = 500;

        this.game.add.tween(image.position).to({x: data[2]}, t, "Linear").to({x: data[1]}, t, "Linear", true).loop(true);
        this.game.add.tween(image).to({alpha: 0.2}, t, "Linear").to({alpha: 1}, t, "Linear", true).loop(true);

        image.anchor.set(data[3], 0.5);

        wrap.addChild(image);

        return wrap;
    }

    _getNewUpgradesAnim() {
        const wrap = this.getWrap(),
              image = new Phaser.Image(this.game, -30, 0, "NewUpgrades"),
              t = 500;

        this.game.add.tween(image.position).to({x: -45}, t, "Linear").to({x: -30}, t, "Linear", true).loop(true);
        this.game.add.tween(image).to({alpha: 0.2}, t, "Linear").to({alpha: 1}, t, "Linear", true).loop(true);

        image.anchor.set(1, 0.5);

        wrap.addChild(image);

        return wrap;
    }

    openLevelsMenuPage() {
        h5branding.google.sendScreenView('level_menu');
        this._calculStars();
        let wrap = this.getWrap(),
            user = this.getUser(),
            save = user.getSave(),
            story = user.getStoryStep(),
            msc = 1 / this.getMainScaleUI(),
            w = msc * this.data.size.width,
            h = msc * this.data.size.height,
            back = new Phaser.Image(this.game, 0, 0),
            left = new Phaser.Image(this.game, 0, 0, "bgPlate02"),
            right = new Phaser.Image(this.game, 0, 0, "bgPlate01"),
            star = new Phaser.Image(this.game, 0, 0, "galleryStar_02"),
            textStar = new Phaser.Text(this.game, -w * 0.13 + 3, - h * (0.455), String(user.getStars()), {fill: "#82ecfe", fontSize: 26, stroke: "#182932", strokeThickness: 3, font: DP3.font2}),
            textStar2 = new Phaser.Text(this.game, -w * 0.13, - h * (0.455), "/39", {fill: "#0065cb", fontSize: 26, stroke: "#182932", strokeThickness: 3, font: DP3.font2}),
            wraps = [],
            close = cb => this._close_crp_and_lvm.bind(this, wrap, back, left, right, cb, () => {
                for(let i = 0, arr = wraps, l = arr.length; i < l; i+=1) {
                    this.game.add.tween(arr[i]).to({alpha: 0}, 300, "Linear", true);
                }
            });

        left.anchor.set(0.1, 0.5);
        right.anchor.set(0.9, 0.5);
        back.anchor.set(0.5, 0.5);

        //Star
        textStar.anchor.set(1, 0.5);
        textStar.setShadow(0, 0, '#82ecfe', 5);
        textStar2.anchor.set(0, 0.5);
        star.anchor.set(0.5, 0.5);
        star.position.set(-w * 0.045, - h * (0.46));

        //Buttons
        let backButton = new Phaser.Button(this.game, 0, 0, "button1", this.data.callbacks.openMainMenu ? this.data.callbacks.openMainMenu : null, this, "btnBackSmall_002.png", "btnBackSmall_001.png", "btnBackSmall_003.png", "btnBackSmall_001.png");
        backButton.anchor.set(0.5, 0.5);
        backButton.scale.set(0.9);
        backButton.position.set(w * 0.045, - h * (0.43));
        this._addSoundForButton(backButton);

        let helpButton = new Phaser.Button(this.game, 0, 0, "button1", close(this.openHelpMenu.bind(this, true, this.openLevelsMenuPage.bind(this))), this, "btnHelp_002.png", "btnHelp_001.png", "btnHelp_003.png", "btnHelp_001.png");
        helpButton.anchor.set(0.5, 0.5);
        helpButton.scale.set(0.9);
        helpButton.position.set(w * 0.045, h * (0.18));
        this._addSoundForButton(helpButton);

        let achivButton = new Phaser.Button(this.game, 0, 0, "button1", close(this.openAchivMenu.bind(this, true, this.openLevelsMenuPage.bind(this))), this, "btnAchievementsSmall_002.png", "btnAchievementsSmall_001.png", "btnAchievementsSmall_003.png", "btnAchievementsSmall_001.png");
        achivButton.anchor.set(0.5, 0.5);
        achivButton.scale.set(0.9);
        achivButton.position.set(w * 0.045, h * (0.29));
        this._addSoundForButton(achivButton);

        let statButton = new Phaser.Button(this.game, 0, 0, "button1", close(this.openStatisticsMenu.bind(this, true, this.openLevelsMenuPage.bind(this))), this, "btnStatisticsSmall_002.png", "btnStatisticsSmall_001.png", "btnStatisticsSmall_003.png", "btnStatisticsSmall_001.png");
        statButton.anchor.set(0.5, 0.5);
        statButton.scale.set(0.9);
        statButton.position.set(w * 0.045, h * (0.4));
        this._addSoundForButton(statButton);

        let shopButton = new Phaser.Button(this.game, 0, 0, "button1", close(this.openShop.bind(this, true, this.openLevelsMenuPage.bind(this))), this, "btnShopSmall_002.png", "btnShopSmall_001.png", "btnShopSmall_003.png", "btnShopSmall_001.png");
        shopButton.anchor.set(0.5, 0.5);
        shopButton.scale.set(0.9);
        shopButton.position.set(-50, 250);
        this._addSoundForButton(shopButton);

        wrap.addChild(back);

        //draw way
        let  way = [[460,-500],[400,-340],[380, -180],[210,-210],[70,-300],[-90,-130],[-80,40],[40,160],[0,310],[-170,400],[-340,280],[-430,470]];
        way = way.map(function(x) {
            return [x[0] / 2, x[1] / 2]
        });

        for(let i = 0, arr = way, l = arr.length; i < l; i+=1) {
            const elem = new Phaser.Image(this.game, arr[i][0], arr[i][1], "mapMarker");
            if(i < l - 1) {
                const line = new Phaser.Image(this.game, arr[i][0], arr[i][1], "mapLine"),
                      s = Math.sqrt(Math.pow(arr[i][0] - arr[i + 1][0], 2) + Math.pow(arr[i][1] - arr[i + 1][1], 2)) / 42,
                      L = this.game.math.angleBetween(arr[i][0], arr[i][1], arr[i + 1][0], arr[i + 1][1]);
                line.anchor.set(0, 0.5);
                line.rotation = L;
                back.addChild(line);

                line.scale.set(0, 1.7);
                this.game.add.tween(line.scale).to({}, 750 + i * 70, "Linear").to({x: s}, 70, "Linear", true);
            }
            elem.anchor.set(0.5);
            back.addChild(elem);

            elem.scale.set(0);
            this.game.add.tween(elem.scale).to({}, 700 + i * 70, "Linear").to({x: 0.85, y: 0.85}, 300, Phaser.Easing.Back.Out, true);
        }

        //Missions
        for(let i = 0, l = 4; i < l; i+=1) {
            let wp = new Phaser.Sprite(this.game, -150, (i - 1.5) * 147 - 5),
                panel = new Phaser.Sprite(this.game, 0, 0, "missionGroup1"),
                title = new Phaser.Text(this.game, 1, -34, "MISSIONS", {fill: "#83edff", fontSize: 19, font: DP3.font2}),
                textColors = ["#feeaf3", "#fefebe", "#83edff", "#6c4e4e", "#8a8160", "#55817d"], // status + 3 = hoverColor
                textList = ["locked", "available", "completed"],
                imagesButton = ["plainMissionLocked", "plainMissionAvalible", "plainMissionCompleted"];

            panel.anchor.set(0.5, 0.5);
            title.anchor.set(0.5, 1);
            wp.addChild(panel);
            panel.addChild(title);

            for(let j = 0, k = 3; j < k; j+=1) {
                let num = i * 3 + j + 1,
                    wrapButton = new Phaser.Sprite(this.game, (j - 1) * 103, 12),
                    status = num < story ? 2 : num > story ? 0 : 1,///lock = 0, avalible = 1, completed = 2
                    textStatus = new Phaser.Text(this.game, 0, 35, textList[status], {fill: textColors[status], fontSize: 13, align: "center"}),
                    number = new Phaser.Text(this.game, 0, -21, "MISSION " + num, {fill: textColors[status], fontSize: 14}),
                    bg = new Phaser.Image(this.game, 0, 0, "gallery6", imagesButton[status] + "_001.png"),
                    countStars = 0;

                if(status > 1)countStars = this._calculStarsData(num).stars;

                textStatus.lineSpacing = -9;

                textStatus.anchor.set(0.5, 0.5);
                number.anchor.set(0.5, 1);
                bg.anchor.set(0.5, 0.5);

                wrapButton.inputEnabled = true;

                if(status > 0) {
                    wrapButton.input.useHandCursor = status > 0 ? true : false;
                    wrapButton.events.onInputDown.add(() => {
                        h5branding.gameanalytics.addProgressionEvent(h5branding.EGAProgressionStatus.Start, 'Mission', num.toString());

                        this.sndBtnDown();
                        bg.frameName = imagesButton[status] + "_003.png";
                        setTimeout(() => {
                            bg.frameName = imagesButton[status] + "_001.png";
                            textStatus.clearColors();
                        }, 200);

                        this.openBriefingMenu(num);

                    }, this);
                    wrapButton.events.onInputOut.add(() => {
                        bg.frameName = imagesButton[status] + "_001.png";
                        textStatus.clearColors();
                    }, this);

                    wrapButton.events.onInputOver.add(() => {
                        this.sndBtnOver();
                        bg.frameName = imagesButton[status] + "_002.png";
                        textStatus.clearColors();
                        textStatus.addColor(textColors[status + 3], 0);
                    }, this);
                } else {
                    wrapButton.events.onInputDown.add(() => {
                        this.sndBtnDown();
                        bg.frameName = imagesButton[status] + "_003.png";
                        setTimeout(() => {
                            bg.frameName = imagesButton[status] + "_001.png";
                            textStatus.clearColors();
                            textStatus.setText("locked");
                            textStatus.fontSize = 13;
                        }, 200);
                    }, this);
                    wrapButton.events.onInputOut.add(() => {
                        bg.frameName = imagesButton[status] + "_001.png";
                        textStatus.clearColors();
                        textStatus.setText("locked");
                        textStatus.fontSize = 13;
                    }, this);

                    wrapButton.events.onInputOver.add(() => {
                        this.sndBtnOver();
                        bg.frameName = imagesButton[status] + "_002.png";
                        textStatus.clearColors();
                        textStatus.addColor(textColors[status + 3], 0);
                        textStatus.setText("complete prev.\nmission");
                        textStatus.fontSize = 11;
                    }, this);
                }

                wrapButton.addChild(bg);
                wrapButton.addChild(number);
                wrapButton.addChild(textStatus);

                for(let n = 0, m = countStars; n < m; n+=1) {
                    let star = new Phaser.Image(this.game, (n - 1) * 30, -10 * (n % 2) + 5, "galleryStar_02");
                    star.anchor.set(0.5, 0.5);
                    wrapButton.addChild(star);
                }

                wp.addChild(wrapButton);

                wrapButton.alpha = 0;
                this.game.add.tween(wrapButton).to({}, 1820 + i * 50 + 100 * (j % 2), "Linear").to({alpha: 1}, 400, Phaser.Easing.Bounce.Out, true);
            }

            wraps.push(wp);
            wrap.addChild(wp);

            panel.alpha = 0;
            this.game.add.tween(panel).to({}, 1700 + i * 30, "Linear").to({alpha: 1}, 300, "Linear", true);
        }

        //Spec missions
        for(let i = 0, l = 3; i < l; i+=1) {
            let wp = new Phaser.Sprite(this.game, 175, (i - 1) * 147),
                num = i + 13,
                config = this._getLevelConfig(num),
                panel = new Phaser.Sprite(this.game, 0, 0, "missionGroup2"),
                title = new Phaser.Text(this.game, 2, -33, "DEATHMATCH", {fill: "#83edff", fontSize: 19, font: DP3.font2}),
                wrapButton = new Phaser.Sprite(this.game, 0, 12),
                record = user.getRecordFrom(num),
                status = user.getStars() < config.need ? 0 : record > 0 ? 2 : 1,///lock = 0, avalible = 1, completed = 2
                textColors = ["#feeaf3", "#fefebe", "#83edff", "#6c4e4e", "#8a8160", "#55817d"], // status + 3 = hoverColor
                textList = ["need " + ((i + 1) * 12), "available", "completed"],
                textStatus = new Phaser.Text(this.game, 0, 46, textList[status], {fill: textColors[status], fontSize: 13}),
                imagesButton = ["specMissionLocked", "specMissionAvalible", "specMissionCompleted"],
                number = new Phaser.Text(this.game, 0, -21, "MISSION " + (num), {fill: textColors[status], fontSize: 14}),
                bg = new Phaser.Image(this.game, 0, 0, "gallery6", imagesButton[status] + "_001.png");

            panel.anchor.set(0.5, 0.5);
            title.anchor.set(0.5, 1);
            textStatus.anchor.set(0.5, 1);
            number.anchor.set(0.5, 1);
            bg.anchor.set(0.5, 0.5);

            wrapButton.inputEnabled = true;
            wrapButton.input.useHandCursor = status > 0 ? true : false;

            wrapButton.events.onInputDown.add(() => {
                this.sndBtnDown();
                bg.frameName = imagesButton[status] + "_003.png";
                setTimeout(() => {
                    bg.frameName = imagesButton[status] + "_001.png";
                    textStatus.clearColors();
                }, 200);
                if(status) {
                    this.openBriefingMenu(num);
                }
            }, this);

            wrapButton.events.onInputOut.add(() => {
                bg.frameName = imagesButton[status] + "_001.png";
                textStatus.clearColors();
            }, this);

            wrapButton.events.onInputOver.add(() => {
                this.sndBtnOver();
                bg.frameName = imagesButton[status] + "_002.png";
                textStatus.clearColors();
                textStatus.addColor(textColors[status + 3], 0);
            }, this);

            wrapButton.addChild(bg);
            wrapButton.addChild(number);
            wrapButton.addChild(textStatus);
            if(status == 0) {
                textStatus.position.x = -10;
                let miniStar = new Phaser.Image(this.game, 31, 31, "galleryStar_02");
                miniStar.anchor.set(0.5, 0.5);
                miniStar.scale.set(0.5);
                wrapButton.addChild(miniStar);
            } else if(status == 2 && record >= config.stars[0].target) {
                let star = new Phaser.Image(this.game, 0, 0, "galleryStar_01");
                star.anchor.set(0.5, 0.5);
                wrapButton.addChild(star);
            }

            wraps.push(wp);
            wp.addChild(panel);
            panel.addChild(title);
            wp.addChild(wrapButton);
            wrap.addChild(wp);

            wrapButton.alpha = 0;
            this.game.add.tween(wrapButton).to({}, 2020 + i * 50, "Linear").to({alpha: 1}, 400, Phaser.Easing.Bounce.Out, true);

            panel.alpha = 0;
            this.game.add.tween(panel).to({}, 1820 + i * 30, "Linear").to({alpha: 1}, 300, "Linear", true);
        }

        right.addChild(star);
        right.addChild(textStar);
        right.addChild(textStar2);

        left.addChild(helpButton);
        left.addChild(achivButton);

        if(this._checkAchivs()) {
            const achivAnim = this._getNewAchievementsAnim(0);
            achivAnim.position.set(w * 0.045, h * (0.29));
            left.addChild(achivAnim);
        }

        if(this._checkUpgrades()) {
            const upgradesAnim = this._getNewUpgradesAnim();
            upgradesAnim.position.set(-50, 250);
            right.addChild(upgradesAnim);
        }

        left.addChild(statButton);
        left.addChild(backButton);

        right.addChild(shopButton);

        wrap.addChild(left);
        wrap.addChild(right);

        this.addPage(wrap);

        ///Animations
        this.coverPages();
        //Back
        for(let i = 0, arr = ["mapPrt_001", "mapPrt_002", "mapPrt_003", "mapPrt_004", "mapPrt_005", "mapPrt_006"], l = arr.length; i < l; i+=1) {
            const img = new Phaser.Image(this.game, 0, 0, arr[i]);
            img.alpha = 0;
            this.game.add.tween(img).to({}, i * 60 + 300, "Linear").to({alpha: 1}, 500, "Linear", true);
            img.anchor.set(0.5);
            back.addChild(img);
        }

        left.position.x = left._def_x = - w * 0.5;
        left.position.y = left._def_y = 0;
        right.position.x = right._def_x = w * 0.5;
        right.position.y = right._def_y = 0;

        const x1 = left._def_x,
              y1 = left._def_y,
              x2 = right._def_x,
              y2 = right._def_y;

        left.position.set(x1 - 61, y1);
        right.position.set(x2 + 95, y2);

        this.game.add.tween(left.position).to({x: x1, y: y1}, 300, "Linear", true);
        this.game.add.tween(right.position).to({x: x2, y: y2}, 300, "Linear", true);
        this.game.time.events.add(2500, this.uncoverPages.bind(this));
    }

    _getLevelConfig(num = 1) {
        let data = this._getLevelsConfig();
        return ((num > data.main.length) ? data.special[num - data.main.length - 1] : data.main[num - 1]);
    }

    _getLevelsConfig() {
        return this._getConfig().levels;
    }

    _getConfig() {
        return this.game.cache.getJSON("config");
    }

    openBriefingMenu(num = 1, cb) {
        h5branding.google.sendScreenView('briefings_menu');
        let wrap = this.getWrap(),
            data = this._getLevelConfig(num),
            leftMainSection = this.getWrap(),
            leftSecondSection = this.getWrap(),
            rightMainSection = this.getWrap(),
            rightSecondSection = this.getWrap(),
            msc = 1 / this.getMainScaleUI(),
            bg = this.getBGGraphics(),
            leftPanel = new Phaser.Image(this.game, 0, 0, "briefPane1"),
            rightPanel = new Phaser.Image(this.game, 0, 0, "briefPane2"),
            image = new Phaser.Image(this.game, 0, 0, "briefing1", "lvlIco_00" + data.location + ".png"),
            leftRail = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            title1 = new Phaser.Text(this.game, 0, 0, "MAIN  MISSION   " + num, {fontSize: 20, fill: "#ffffff", stroke: "#000", strokeThickness: 3, font: DP3.font3}),
            title2 = new Phaser.Text(this.game, 0, 0, data.name, {fontSize: 25, fill: "#00ffe9", stroke: "#000", strokeThickness: 2}),
            title3 = new Phaser.Text(this.game, 0, 0, "ENEMIES", {fontSize: 25, fill: "#00ffe9", stroke: "#000", strokeThickness: 2}),
            cancel = new Phaser.Button(this.game, 0, 0, "button1", () => {
                this.coverPages();
                this.sndHideWindow();

                const x1 = leftMainSection._def_x,
                      y1 = leftMainSection._def_y  - 650,
                      x2 = rightMainSection._def_x,
                      y2 = rightMainSection._def_y + 650,
                      x3 = leftSecondSection._def_x,
                      y3 = leftSecondSection._def_y - 100;

                this.game.add.tween(leftSecondSection.position).to({x: x3, y: y3}, 80, "Linear", true);
                this.game.add.tween(leftMainSection.position).to({}, 130).to({x: x1, y: y1}, 250, "Linear", true);
                this.game.add.tween(rightMainSection.position).to({x: x2, y: y2}, 380, "Linear", true);
                this.game.add.tween(bg).to({alpha: 0}, 380, "Linear", true).onComplete.add(() => {this.uncoverPages(); this.removePage(wrap);});
            }, this, "btnCancelSmall_002.png", "btnCancelSmall_001.png", "btnCancelSmall_003.png", "btnCancelSmall_001.png"),
            textSettings = [

            ],
            description = new Phaser.Text(this.game, 0, 0, data.description, {fill: "#fff", fontSize: 15, stroke: "#000", strokeThickness: 2}),
            button = this._getPlayButton(() => {
                this.data.callbacks.selectLevel(num);
                if(cb) {
                    cb();
                }
            }),
            enemiesImage = new Phaser.Image(this.game, 0, 0, data.enemiesImage);

        this._addSoundForButton(cancel);

        leftPanel.anchor.set(0.5, 0.5);
        leftPanel.position.set(-185, -10);

        rightPanel.anchor.set(0.5, 0.5);
        rightPanel.position.set(245, -10);

        title1.anchor.set(0.5, 1);
        title1.position.set(-157, -195);
        title1.setShadow(0, 0, '#00dbff', 3);

        title2.anchor.set(0.5, 1);
        title2.position.set(-157, -160);
        title2.setShadow(0, 0, '#00ffe9', 3);

        title3.anchor.set(0.5, 1);
        title3.position.set(230, -200);
        title3.setShadow(0, 0, '#00ffe9', 3);

        image.anchor.set(0.5, 0.5);
        image.position.set(-155, 37);

        enemiesImage.anchor.set(0.5, 0.5);
        enemiesImage.position.set(225, 10);

        //Texts
        if(data.enemies) {
            for(let i = 0, arr = data.enemies, l = arr.length; i < l; i+=1) {
                //name
                textSettings.push({
                    text: arr[i].toUpperCase(),
                    positions: [480, (i / (l - 1) - 0.5) * 610 - 40],
                    anchor: [0.5, 1],
                    styles: {fill: "#f16e6e", fontWeight: "bold", stroke: "#000", strokeThickness: 3, fontSize: 18}
                });
                //armoring
                textSettings.push({
                    text: "armoring",
                    positions: [550, (i / (l - 1) - 0.5) * 610 + 10],
                    anchor: [0.5, 1],
                    styles: {fill: "#fff", fontWeight: "bold", stroke: "#000", strokeThickness: 2, fontSize: 16}
                });
                //firerower
                textSettings.push({
                    text: "firerower",
                    positions: [550, (i / (l - 1) - 0.5) * 610 + 50],
                    anchor: [0.5, 1],
                    styles: {fill: "#fff", fontWeight: "bold", stroke: "#000", strokeThickness: 2, fontSize: 16}
                });
                //ramming
                textSettings.push({
                    text: "ramming",
                    positions: [550, (i / (l - 1) - 0.5) * 610 + 90],
                    anchor: [0.5, 1],
                    styles: {fill: "#fff", fontWeight: "bold", stroke: "#000", strokeThickness: 2, fontSize: 16}
                });
            }
        }

        description.position.set(-330, 115);
        description.setShadow(0, 0, '#00dbff', 5);

        //Button
        button.position.set(-157, 270);

        cancel.anchor.set(0.5, 0.5);
        cancel.scale.set(0.75);
        cancel.position.set(385, -235);

        leftRail.anchor.set(0.5, 0.1);
        leftRail.position.set(-407, -325);

        leftSecondSection.addChild(leftPanel);

        //stars
        let wrapStars = this.getProgressStarsLine(num);
        wrapStars.position.set(-157, -110);
        leftSecondSection.addChild(wrapStars);

        leftSecondSection.addChild(image);
        leftSecondSection.addChild(description);
        leftSecondSection.addChild(button);

        leftMainSection.addChild(leftSecondSection);
        leftMainSection.addChild(leftRail);
        leftSecondSection.addChild(title1);
        leftSecondSection.addChild(title2);

        rightSecondSection.addChild(rightPanel);
        rightSecondSection.addChild(enemiesImage);
        rightSecondSection.addChild(title3);
        rightSecondSection.addChild(cancel);

        rightMainSection.addChild(rightSecondSection);

        //Text
        this.drawTextToInstructions(textSettings, rightSecondSection);

        wrap.addChild(bg);
        wrap.addChild(rightMainSection);
        wrap.addChild(leftMainSection);

        this.addPage(wrap);

        this.coverPages();
        this.sndOpenWindow();

        leftMainSection.position.x = leftMainSection._def_x = 0;
        leftMainSection.position.y = leftMainSection._def_y = 0;
        rightMainSection.position.x = rightMainSection._def_x = 0;
        rightMainSection.position.y = rightMainSection._def_y = 0;
        leftSecondSection.position.y = leftSecondSection._def_y = 0;
        leftSecondSection.position.y = leftSecondSection._def_y = 0;

        const x1 = leftMainSection._def_x,
              y1 = leftMainSection._def_y,
              x2 = rightMainSection._def_x,
              y2 = rightMainSection._def_y,
              x3 = leftSecondSection._def_x,
              y3 = leftSecondSection._def_y;

        leftMainSection.position.set(x1, y1 - 550);
        rightMainSection.position.set(x2, y2 + 650);
        leftSecondSection.position.set(x3, y3 - 100);
        bg.alpha = 0;

        this.game.add.tween(leftSecondSection.position).to({}, 300).to({x: x3, y: y3}, 80, "Linear", true);
        this.game.add.tween(leftMainSection.position).to({x: x1, y: y1}, 250, "Linear", true);
        this.game.add.tween(rightMainSection.position).to({x: x2, y: y2}, 380, "Linear", true);
        this.game.add.tween(bg).to({alpha: 1}, 380, "Linear", true).onComplete.add(this.uncoverPages.bind(this));
    }

    _getPlayButton(cb, text = "PLAY", style) {
        const button = new Phaser.Sprite(this.game, 0, 0),
            buttonImage = new Phaser.Image(this.game, 0, 0, "button1", "btnNextMenu_001.png"),
            buttonText = new Phaser.Text(this.game, 0, 0, text, style || {fill: "#4ffef0", fontSize: 36, fontWeight: "bold", stroke: "#000", font: DP3.font1, strokeThickness: 4}),
            buttonIco = new Phaser.Image(this.game, 0, 0, "icoSmall", "icoSmall1_001.png"),
            buttonWrap = new Phaser.Sprite(this.game, 0, 0);

        buttonImage.anchor.set(0.5, 0.5);
        buttonText.anchor.set(1, 0.5);
        buttonText.position.set(31, 3);
        buttonIco.anchor.set(0.5, 0.5);
        buttonIco.position.set(50, 0);
        buttonIco.scale.set(0.9);
        buttonWrap.scale.set(0.9);
        buttonWrap.addChild(buttonIco);
        buttonWrap.addChild(buttonText);
        button.addChild(buttonImage);
        button.addChild(buttonWrap);

        button.inputEnabled = true;
        button.input.useHandCursor = true;

        button.events.onInputDown.add(() => {
            buttonImage.frameName = "btnNextMenu_001.png";
            buttonWrap.scale.set(0.9);
            buttonIco.frameName = "icoSmall1_003.png";
            buttonText.fill = "#000";
            buttonText.stroke = "#919394";
            if(cb) {
                cb();
            }
        }, this);
        button.events.onInputOut.add(() => {buttonImage.frameName = "btnNextMenu_001.png"; buttonWrap.scale.set(0.9);}, this);
        button.events.onInputOver.add(() => {buttonImage.frameName = "btnNextMenu_002.png"; buttonWrap.scale.set(1);}, this);

        return button;
    }

    openShop(anim = true, cb) {
        h5branding.google.sendScreenView('shop');
        let wrap = this.getWrap(),
            msc = 1 / this.getMainScaleUI(),
            w = msc * this.data.size.width,
            h = msc * this.data.size.height,
            bg = this.getBGGraphics("#000", 0.7),
            imgBG = this.getBGImage(),
            topWrap = new Phaser.Sprite(this.game, 0, 0),
            contentWrap = new Phaser.Sprite(this.game, 0, -85),// contentWrap ==> {buttonsWrap, carWrap, iconsWrap}
            carWrap = new Phaser.Sprite(this.game, 0, 0),
            title = new Phaser.Image(this.game, 0, 0, "shopTxt"),
            bottomWrap = new Phaser.Sprite(this.game, 0, 0),
            leftSubWrap = new Phaser.Sprite(this.game, 0, 0),
            rightSubWrap = new Phaser.Sprite(this.game, 0, 0),
            topPanel = new Phaser.Image(this.game, 0, 0, "shopElem1"),
            leftPanel = new Phaser.Image(this.game, 0, 0, "shopElem2"),
            rightPanel = new Phaser.Image(this.game, 0, 0, "shopElem3"),
            data = this.game.cache.getJSON("config").shop,
            buttons = [],
            pageCars = 0,
            closeContent,
            close = (cb) => {
                this.coverPages();
                this.sndHideWindow();


                for(let i = 0, arr = [topWrap, leftSubWrap, rightSubWrap], arr2 = [[0, -86], [-82, 0], [114, 0]], l = arr.length; i < l; i+=1) {
                    const elem = arr[i],
                          d = arr2[i] || [0, 0],
                          x = elem._def_x,
                          y = elem._def_y;

                    this.game.add.tween(elem.position).to({x: x + d[0], y: y + d[1]}, 250, "Linear", true);
                }

                if(closeContent)closeContent();

                this.game.time.events.add(600, () => {this.uncoverPages(); this.removePage(wrap); if(cb && cb instanceof Function)cb();});
            };

        topPanel.anchor.set(0.5, 0);
        leftPanel.anchor.set(0, 1);
        rightPanel.anchor.set(1, 1);

        topWrap.addChild(topPanel);

        title.anchor.set(0.5, 0.5);
        title.position.set(0, 55);
        topWrap.addChild(title);

        leftSubWrap.addChild(leftPanel);

        rightSubWrap.addChild(rightPanel);

        //pre & next buttons
        let preButton = new Phaser.Button(this.game, 0, 0, "button1", () => {pageCars-=1; this._getShopContent(contentWrap, 0, pageCars, setActiveNavButtons, false, false);}, this, "btnPrewSmall_002.png", "btnPrewSmall_001.png", "btnPrewSmall_003.png", "btnPrewSmall_001.png");
        preButton.anchor.set(0.5, 0.5);
        //preButton.scale.set(0.8);
        preButton.position.set(50, -150);
        leftPanel.addChild(preButton);
        this._addSoundForButton(preButton);

        let nextButton = new Phaser.Button(this.game, 0, 0, "button1", () => {pageCars+=1; this._getShopContent(contentWrap, 0, pageCars, setActiveNavButtons, false, false);}, this, "btnNextSmall_002.png", "btnNextSmall_001.png", "btnNextSmall_003.png", "btnNextSmall_001.png");
        nextButton.anchor.set(0.5, 0.5);
        //nextButton.scale.set(0.8);
        nextButton.position.set(-47, -147);
        rightPanel.addChild(nextButton);
        this._addSoundForButton(nextButton);

        const setActiveNavButtons = (status) => {
            if(status) {
                nextButton.frameName = nextButton._onUpFrame;
                preButton.frameName = preButton._onUpFrame;
            } else {
                nextButton.frameName = nextButton._onDownFrame;
                preButton.frameName = preButton._onDownFrame;
            }
            nextButton.inputEnabled = status;
            preButton.inputEnabled = status;
        };

        //Noise
        const noiseHH = this.game.cache.getImage("noiseEff").height / 2,//half height
              noiseEff = new Phaser.Image(this.game, 0, h / 2 + noiseHH, "noiseEff");
        let noiseTween = this.game.add.tween(noiseEff.position).to({y: -h/2 - noiseHH}, 3000, "Linear", true);
        noiseEff.anchor.set(0.5);
        noiseEff.scale.set(1.25, 1);
        noiseTween.loop(true);

        closeContent = this._getShopContent(contentWrap, 0, 0, setActiveNavButtons, true);

        //buttonsWrap.position.set(0, -173);

        //Buttons
        let achievButton = new Phaser.Button(this.game, 0, 0, "button1", () => {
            close(this.openAchivMenu.bind(this, true, cb));
        }, this, "btnAchievementsSmall_002.png", "btnAchievementsSmall_001.png", "btnAchievementsSmall_003.png", "btnAchievementsSmall_001.png");
        achievButton.anchor.set(0.5, 0.5);
        achievButton.scale.set(0.8);
        achievButton.position.set(-50, -535);
        rightSubWrap.addChild(achievButton);
        this._addSoundForButton(achievButton);

        if(this._checkAchivs()) {
            const achivAnim = this._getNewAchievementsAnim(1);
            achivAnim.position.set(-50, -535);
            rightSubWrap.addChild(achivAnim);
        }

        let statButton = new Phaser.Button(this.game, 0, 0, "button1", () => {
            close(this.openStatisticsMenu.bind(this, true, cb));
        }, this, "btnStatisticsSmall_002.png", "btnStatisticsSmall_001.png", "btnStatisticsSmall_003.png", "btnStatisticsSmall_001.png");
        statButton.anchor.set(0.5, 0.5);
        statButton.scale.set(0.8);
        statButton.position.set(-50, -475);
        rightSubWrap.addChild(statButton);
        this._addSoundForButton(statButton);

        let cancelButton = new Phaser.Button(this.game, 0, 0, "button1", () => {close(cb);}, this, "btnCancelSmall_002.png", "btnCancelSmall_001.png", "btnCancelSmall_003.png", "btnCancelSmall_001.png");
        cancelButton.anchor.set(0.5, 0.5);
        //cancelButton.scale.set(0.75);
        cancelButton.position.set(-50, -602);
        rightSubWrap.addChild(cancelButton);
        this._addSoundForButton(cancelButton);

        bottomWrap.position.set(0, h/2);
        bottomWrap.addChild(contentWrap);
        bottomWrap.addChild(leftSubWrap);
        bottomWrap.addChild(rightSubWrap);

        wrap.addChild(imgBG);
        wrap.addChild(bg);
        wrap.addChild(noiseEff);
        wrap.addChild(bottomWrap);
        wrap.addChild(topWrap);

        this.addPage(wrap);

        topWrap.position.x = topWrap._def_x = 0;
        topWrap.position.y = topWrap._def_y = -h/2 - 25;

        leftSubWrap.position.x = leftSubWrap._def_x = -w/2 - 17;
        leftSubWrap.position.y = leftSubWrap._def_y = 0;

        rightSubWrap.position.x = rightSubWrap._def_x = w/2 + 12;
        rightSubWrap.position.y = rightSubWrap._def_y = 0;

        if(anim) {
            this.coverPages();
            this.sndOpenWindow();

            for(let i = 0, arr = [topWrap, leftSubWrap, rightSubWrap], arr2 = [[0, -86], [-82, 0], [114, 0]], l = arr.length; i < l; i+=1) {
                const elem = arr[i],
                      d = arr2[i] || [0, 0],
                      x = elem._def_x,
                      y = elem._def_y;

                elem.position.set(x + d[0], y + d[1]);

                this.game.add.tween(elem.position).to({x: x, y: y}, 250, "Linear", true);
            }

            this.game.time.events.add(700, () => {
                this.uncoverPages();
            });
        }
    }

    _selectCar(num = 0) {
        const user = this.getUser();

        for(let i = 0, arr = user.getVariable("cars"), l = arr.length; i < l; i+=1) {
            if(i === num) {
                arr[i] = 2;
            } else if(arr[i] === 2) {
                arr[i] = 1;
            }
        }
        user.save();
    }

    _getCarContent(context, data, shop, focus) {
        /*const wrap = context || this.getWrap(),
              car = new DP3.ShopCar({
                  game: this.game,
                  class: "Car_PC_7",
                  car: "enemyShowBike2",
                  correctData: data,
                  player: false,
                  shop: shop
              });

        car.scale.set(0.8);

        car.anchor.set(0.5);
        wrap.addChild(car);
        return wrap;*/

        const wrap = context || this.getWrap(),
              car = new DP3.ShopCar({
                  game: this.game,
                  class: "Car_PC_7",
                  car: shop.cars.indexOf(2) === 1 ? "corsair" : "predator",
                  correctData: data,
                  player: true,
                  shop: shop
              }, focus);

        car.anchor.set(0.5);
        wrap.addChild(car);
        return wrap;
    }

     _collectHeroData(shop = {}) {
        const data = this.game.cache.getJSON("dataCars"),
              car = shop["cars"].indexOf(2),
              getClassDataTo = (type, value) => {
                const str = car ? "Car_PC_5_" : "Car_PC_7_";
                let num = 1;

                if(type === "rect") {
                    num = value + 1;
                } else {
                    num = value;
                }

                if(car && num > 3)num = 3;

                return data[str + num][type];
            },
              res = ([
                  {
                      class: "Car_PC_7",
                      price: 0,
                      hp: ([4000, 4500, 5000, 5500, 6000, 7000])[shop["shield"][1]],
                      fuel: getClassDataTo("fuel", shop["fuel tank"][1]),
                      speed: ([60, 70, 80, 90, 100, 110])[shop["motor"][1] - 1],
                      rect: getClassDataTo("rect", shop["shield"][1]),
                      wheels: getClassDataTo("wheels", shop["wheels"][1]),
                      radius: 21 + shop["wheels"][1],
                      weapons: 400 + shop["guns"][1] * 100,
                      missiles: ([750, 900, 1100, 1200, 1300, 1500])[shop["rocket launcher"][1] - 1]
                  },
                  {
                      class: "Car_PC_5",
                      price: 15000,
                      hp: 4000,
                      fuel: 124,
                      speed: 55,
                      rect: getClassDataTo("rect", shop["shield"][1]),
                      wheels: getClassDataTo("wheels", shop["wheels"][1]),
                      radius: 21 + shop["wheels"][1],
                      weapons: ([340, 370, 410])[shop["guns"][1] - 1],
                      missiles: ([550, 590])[shop["rocket launcher"][1] - 1]
                  }
              ])[car];

        return res;
    }

    __enoughMoneyTo(data, num) {
        const name = (["cars", "shield", "motor", "fuel tank", "wheels", "guns", "rocket launcher"])[num];

        if(name === "cars") {
            //if(data[name].indexOf(4))return true;
            return false;
        } else {
            if(data[name][0] % 2)return true;
            return false;
        }
    }

    _getShopContent(wrap, num, pos = 0, setActiveNavButtons, anim = false, anim2 = true) {
        if(wrap) {
            const config = this.game.cache.getJSON("config")["shop"],
                  shopData = this.core.getShopData(),
                  carNum = shopData.cars.indexOf(2),//0 or 1
                  carName = (["predator", "corsair"])[carNum],/// predator or corsair
                  user = this.getUser(),
                  departmet = config["departments"][num]["name"],
                  textFormat = config["departments"][num]["text"],
                  info = this.getWrap(),
                  moneyText = new Phaser.Text(this.game, 0, 0, "$ " + user.getVariable("money"), {fill: "#80e8f9", fontSize: 30, font: DP3.font2, stroke: "#182932", strokeThickness: 2}),
                  carData = this._collectHeroData(shopData),
                  car = this._getCarContent(null, carData, shopData),
                  iconsWrap = this.getWrap(),
                  textSettings = ([
                      [
                          {
                              text: "armor: "
                          },
                          {
                              text: String(carData.hp)
                          },
                          {
                              text: "/7000"
                          },
                          {
                              text: "speed: "
                          },
                          {
                              text: String(carData.speed)
                          },
                          {
                              text: "/110"
                          },
                          {
                              text: "fuel: "
                          },
                          {
                              text: String(carData.fuel)
                          },
                          {
                              text: "/545"
                          },
                          {
                              text: "wheels: "
                          },
                          {
                              text: String(carData.radius)
                          },
                          {
                              text: "/27"
                          },
                          {
                              text: "weapons dmg: "
                          },
                          {
                              text: String(carData.weapons)
                          },
                          {
                              text: "/1000"
                          },
                          {
                              text: "missiles dmg: "
                          },
                          {
                              text: String(carData.missiles)
                          },
                          {
                              text: "/1500"
                          }
                      ],
                      [
                          {
                              text: "armor: "
                          },
                          {
                              text: String(carData.hp)
                          },
                          {
                              text: "/4000"
                          },
                          {
                              text: "speed: "
                          },
                          {
                              text: String(carData.speed)
                          },
                          {
                              text: "/55"
                          },
                          {
                              text: "fuel: "
                          },
                          {
                              text: String(carData.fuel)
                          },
                          {
                              text: "/124"
                          },
                          {
                              text: "wheels: "
                          },
                          {
                              text: String(carData.radius)
                          },
                          {
                              text: "/23"
                          },
                          {
                              text: "weapons dmg: "
                          },
                          {
                              text: String(carData.weapons)
                          },
                          {
                              text: "/410"
                          },
                          {
                              text: "missiles dmg: "
                          },
                          {
                              text: String(carData.missiles)
                          },
                          {
                              text: "/590"
                          }
                      ]
                  ])[carNum],
                  textStyle = {
                      font: DP3.font2,
                      fontSize: 16,
                      fill: "#80e8f9",
                      stroke: "#182932",
                      strokeThickness: 2
                  },
                  textStyle2 = {
                      font: DP3.font2,
                      fontSize: 18,
                      fill: "#51e55c",
                      stroke: "#182932",
                      strokeThickness: 2
                  },
                  textShadow = {
                      x: 0,
                      y: 0,
                      fill: '#00ac9c',
                      blur: 5
                  },
                  textShadow2 = {
                      x: 0,
                      y: 0,
                      fill: '#49b151',
                      blur: 5
                  },
                  close = () => {
                    for(let i = 0, arr = wrap.icons, l = arr.length; i < l; i+=1) {
                        const elem = arr[i],
                              x = elem.position.x,
                              y = elem.position.y;

                        this.game.add.tween(elem.position).to({},(3 - Math.abs(i - 3)) * 90 + 20, "Linear").to({x: x, y: y + 95}, 300, Phaser.Easing.Back.In, true);
                    }

                  this.game.add.tween(wrap.info).to({}, 40, "Linear").to({alpha: 0}, 430, Phaser.Easing.Bounce.In, true);
                  this.game.add.tween(wrap.car).to({}, 20, "Linear").to({alpha: 0}, 450, Phaser.Easing.Bounce.In, true);

                    for(let i = 0, arr = wrap.buttons, l = arr.length; i < l; i+=1) {
                        const elem = arr[i];

                        this.game.add.tween(elem).to({alpha: 0}, 300, Phaser.Easing.Bounce.In, true);
                    }
                  },
                  watchHeCar = (type, value) => {
                      let shop = null,
                          data = null,
                          car = wrap.car,
                          alphaStatus = false;

                      if(type) {

                          shop = {};

                          if(type === "cars") {
                              const cars = shopData["cars"],
                                    carStatus = cars[value],
                                    num = carStatus < 0 ? cars.indexOf(2) : value,
                                    carShopData = this.core.getShopData(num);

                              for(let key in carShopData) {
                                  shop[key] = [];
                                  for(let i = 0, arr = carShopData[key], l = arr.length; i < l; i+=1) {
                                      shop[key].push(arr[i]);
                                  }
                              }

                              shop[type][num] = 2;
                          } else {
                              for(let key in shopData) {
                                  shop[key] = [];
                                  for(let i = 0, arr = shopData[key], l = arr.length; i < l; i+=1) {
                                      shop[key].push(arr[i]);
                                  }
                              }

                              shop[type][1] = value;

                              alphaStatus = type;
                          }

                          data = this._collectHeroData(shop);
                      } else {
                          shop = shopData;
                          data = carData;
                      }

                      if(car && car.parent) {
                          car.parent.removeChild(car);
                          car.destroy();
                      }

                      car = this._getCarContent(null, data, shop, alphaStatus);
                      car.position.set(35, -240);
                      wrap.car = car;
                      wrap.addChild(car);
                  },
                  watchCar = (value) => {
                      watchHeCar("cars", value);
                  };

            //clear
            while(wrap.children.length) {
                wrap.children.shift().destroy(true);
            }
            wrap.removeChildren();

            for(let i = 0, arr = textSettings, l = arr.length; i < l; i+=1) {
                arr[i].positions = [140, Math.floor(i / 3) * 35 + 65];

                arr[i].anchor = [i % 3 ? 0 : 1, 0.5];

                if((i + 1) % 3) {
                    arr[i].styles = textStyle;
                    arr[i].shadow = textShadow;
                } else {
                    arr[i].styles = textStyle2;
                    arr[i].shadow = textShadow2;
                    arr[i].positions[0] = 220;
                }
            }

            this.drawTextToInstructions(textSettings, info);

            //info
            moneyText.anchor.set(0, 0.5);
            moneyText.setShadow(0, 0, '#01d3c0', 5);

            info.position.set(-367, -510);
            info.addChild(moneyText);
            wrap.addChild(info);

            wrap.info = info;

            //car

            car.position.set(35, -240);
            wrap.addChild(car);

            wrap.car = car;

            //icons

            const icons = [];
            wrap.icons = icons;

            for(let n = 1, i = 0, l = 7; i < l; i+=1, n = i + 1) {
                let type = this.__enoughMoneyTo(shopData, i) ? 1 : 0,
                    imgPack = ([[3, 2, 4], [6, 5, 7]])[type],
                    button = new Phaser.Button(this.game, i * 103 -309, 0, "shopIcons", () => {
                        setActiveNavButtons(i === 0);
                        this._getShopContent(wrap, i, pos, setActiveNavButtons);
                        return false;
                    }, this, "shopBtn" + n + "_00" + imgPack[0] + ".png", "shopBtn" + n + "_00" + imgPack[1] + ".png", "shopBtn" + n + "_00" + imgPack[2] + ".png", "shopBtn" + n + "_008.png");
                button.anchor.set(0.5);
                button.scale.set(0.98);
                button._isBtnG = true;
                iconsWrap.addChild(button);
                this._addSoundForButton(button);

                //Select ico
                if(i === num) {
                    iconsWrap.addChildAt(button, 0);
                    button.inputEnabled = false;
                    button.frameName = "shopBtn" + n + "_008.png";
                } else if(type) {
                    button.position.x-=2;
                    button.position.y-=3;
                }

                icons.push(button);
            }

            //buttons

            const buttons = [];
            wrap.buttons = buttons;

            if(departmet === "cars") {
                const data = config["cars"],
                      getImages = function(num = 1, type = "ComingSoon") {//types: GetIt, ComingSoon, NoMoney, Ready
                          const str = "car" + num + "btn" + type + "_";
                          return type === "GetIt" ? Array(4).fill(str + "001.png") : [str + "002.png", str + "001.png", str + "003.png", str + "001.png"];
                      };

                for(let i = 0, l = 3, arr = Object.keys(data); i < l; i+=1) {
                    let count = (i + pos) % arr.length;
                    count = count < 0 ? (arr.length + count) : count;

                    const dataCar = data[arr[count]],
                          button = new Phaser.Button(this.game, 0, 0, "shopCars", () => {button._hoverText.alpha = 0;}, this),
                          textWrap = new Phaser.Sprite(this.game, 0, 0),
                          title = new Phaser.Text(this.game, -115, -120, arr[count].toUpperCase(), {fill: "#fff", fontSize: 15, fontWeight: "bold"}),
                          statusText = new Phaser.Text(this.game, 0, -4, "LOCKED", {fill: "#fff", fontSize: 16, fontWeight: "bold"}),//"LOCKED", "EQUIPPED", "not enough money", "READY"
                          hoverText = new Phaser.Text(this.game, 0, -5, "LOCKED", {fill: "#000", fontSize: 16, align: "center"}),
                          buttonWrap = this.getWrap();//"LOCKED", "not enough money", "EQUIP"

                    buttonWrap.position.set(i * 240 - 241, 0);

                    buttons.push(buttonWrap);

                    this._addSoundForButton(button);

                    button._hoverText = hoverText;
                    hoverText.alpha = 0;
                    hoverText.anchor.set(0.5, 1);

                    statusText.anchor.set(0.5, 1);

                    textWrap.addChild(title);
                    textWrap.addChild(statusText);

                    let bgImages = [],
                        status = 0;

                    button.anchor.set(0.5, 1);

                    switch(Number(shopData.cars[count])) {
                        case 4: //it is necessary
                            const price1 = new Phaser.Text(this.game, 105, -120, "price: " + dataCar.cost + "$", {fill: "#fff", fontSize: 16, fontWeight: "bold"});
                            price1.anchor.set(1, 0);
                            textWrap.addChild(price1);
                            bgImages = getImages(dataCar.number, "Ready");
                            statusText.setText("AVAILABLE");
                            hoverText.setText("BUY");

                            button.onInputDown.add(() => {
                                if(this.spendMoney(dataCar.cost, false)) {
                                    this._selectCar(count);
                                    this._getShopContent(wrap, num, pos, setActiveNavButtons, false, false);
                                }
                            }, this);
                            break;
                        case 0: //it is necessary
                            const price = new Phaser.Text(this.game, 105, -120, "price: " + dataCar.cost + "$", {fill: "#fff", fontSize: 16, fontWeight: "bold"});
                            price.anchor.set(1, 0);
                            textWrap.addChild(price);
                            bgImages = getImages(dataCar.number, "NoMoney");
                            statusText.setText("not enough money");
                            hoverText.setText("not enough money");
                            break;
                        case 1:
                            bgImages = getImages(dataCar.number, "Ready");
                            statusText.setText("READY");
                            hoverText.setText("EQUIP");

                            button.onInputDown.add(() => {
                                this._selectCar(count);
                                this._getShopContent(wrap, num, pos, setActiveNavButtons, false, false);
                            }, this);
                            break;
                        case 2:
                            bgImages = getImages(dataCar.number, "GetIt");
                            statusText.setText("EQUIPPED");
                            hoverText.setText(" ");
                            break;
                        default:
                            bgImages = getImages(dataCar.number, "ComingSoon");
                            button.onInputDown.add(this.openCrossPromoShop.bind(this, dataCar.type === "dp1"), this);
                            break;
                    }

                    button.setFrames.apply(button, bgImages);

                    buttonWrap.addChild(textWrap);
                    buttonWrap.addChild(button);
                    buttonWrap.addChild(hoverText);

                    wrap.addChild(buttonWrap);

                    //set hover functions
                    button.onInputOut.add(() => {
                        button._hoverText.alpha = 0;

                        watchHeCar();
                    }, this);

                    button.onInputOver.add(() => {
                        button._hoverText.alpha = 0.5;

                        watchCar(i);
                    }, this);

                }
            } else {
                const W = 722,
                      data = config["cars"][carName][departmet],
                      sd = shopData[departmet],
                      count = config["cars"]["predator"][departmet].length,
                      w1 = W / count,
                      dx = (W - w1) / 2;

                for(let i = 0, l = data.length; i < l; i+=1) {
                    let bgImages,
                        f = (i + 1) * 2,
                        btnData = data[i],
                        status = (f <= sd[0] ? 2 : f - 1 == sd[0] ? 1 : 0) + (sd[1] === (i + 1) ? 1 : 0),
                        btnTextWrap = new Phaser.Sprite(this.game, 0, 0),
                        titel = new Phaser.Sprite(this.game, 0, -55),
                        value = new Phaser.Text(this.game, 0, -2, textFormat.replace("$", btnData["value"]), {fill: "#fff", fontSize: 18, align: "center"}),
                        cost = new Phaser.Text(this.game, 0, 15, " ", {fill: "#fff", fontSize: 15, align: "center"}),
                        textStatus = new Phaser.Text(this.game, 0, 42, "no prerequisites", {fill: "#fff", fontSize: 16, align: "center"}),//"not enough $", "no prerequisites", "EQUIPPED", "STORED", "AVAILABLE"
                        hoverText = new Phaser.Text(this.game, 0, 42, "no prerequisites", {fill: "#000", fontSize: 16, align: "center"}),
                        dw = 0,
                        buttonCb = null;//delta width for buttons

                    if((departmet === "shield" || departmet === "motor" || departmet === "fuel tank") && status === 2)status = 3;

                    //create title
                    for(let j = 0, arr = btnData["title"].split("\n"), k = arr.length; j < k; j+=1) {
                        let text = new Phaser.Text(this.game, 0, j * 14, arr[j].toUpperCase(), {fill: "#fff", fontSize: (arr[j].length * 10 < w1) ? 15 : 11, align: "center"});
                        text.anchor.set(0.5, 0);
                        titel.addChild(text);
                    }

                    //Fill button
                    switch(status) {
                        case 2://purchased items
                            bgImages = ["itmBtnStocked_002.png", "itmBtnStocked_001.png", "itmBtnStocked_003.png", "itmBtnStocked_001.png"];
                            dw = -0.5;

                            textStatus.setText("STORED");
                            hoverText.setText("EQUIP");
                            buttonCb = () => {
                                this.selectEquipment(departmet, i);
                                this._getShopContent(wrap, num, pos, setActiveNavButtons, false, false);
                            };
                            break;
                        case 3://selected item
                            bgImages = new Array(4).fill("itmBtnEquiped.png");
                            dw = -2;

                            textStatus.setText("EQUIPPED");
                            hoverText.setText(" ");
                            break;
                        case 1:
                            bgImages = ["itmBtnReady_002.png", "itmBtnReady_001.png", "itmBtnReady_003.png", "itmBtnReady_001.png"];
                            dw = -5;

                            textStatus.setText("AVAILABLE");
                            hoverText.setText("UPGRADE");
                            hoverText.fontWeight = "bold";

                            buttonCb = () => {
                                this.buyEquipment(departmet, i, btnData["cost"]);
                                this._getShopContent(wrap, num, pos, setActiveNavButtons, false, false);
                            };

                            cost.setText(btnData["cost"]+"$");
                            break;
                        default://don't purchased items

                            if(i > sd[1]) {
                                textStatus.fontSize = hoverText.fontSize = 13;
                            } else {
                                textStatus.setText("not enough $");
                                hoverText.setText("not enough $");
                            }

                            bgImages = ["itmBtnNoMoney_002.png", "itmBtnNoMoney_001.png", "itmBtnNoMoney_003.png", "itmBtnNoMoney_001.png"];
                            dw = -5;

                            cost.setText(btnData["cost"]+"$");
                            break;
                    }

                    //titel.anchor.set(0.5, 0);
                    value.anchor.set(0.5);
                    cost.anchor.set(0.5);
                    textStatus.anchor.set(0.5, 0.5);

                    hoverText.anchor.set(0.5, 0.5);
                    hoverText.alpha = 0;

                    btnTextWrap.addChild(titel);
                    btnTextWrap.addChild(value);
                    btnTextWrap.addChild(cost);
                    btnTextWrap.addChild(textStatus);

                    //Create button
                    const imageData = this.game.cache.getFrameByName("shopButtons", bgImages[0]),
                          w = imageData.width + dw,
                          sw = W / (count * w),
                          button = new Phaser.Button(this.game, 0, 0, "shopButtons", () => {button._hoverText.alpha = 0;}, this, bgImages[0], bgImages[1], bgImages[2], bgImages[3]),
                          wrapButton = this.getWrap();

                    wrapButton.position.set(w1 * i - dx, 0);

                    buttons.push(wrapButton);

                    this._addSoundForButton(button);

                    button._hoverText = hoverText;
                    btnTextWrap.position.set(0, -62);
                    hoverText.position.set(0, -22);
                    button.anchor.set(0.5, 1);
                    button.scale.set(sw, 1);
                    wrapButton.addChild(btnTextWrap);
                    wrapButton.addChild(button);
                    wrapButton.addChild(hoverText);

                    wrap.addChild(wrapButton);

                    //set hover functions

                    if(status !== 3) {
                        if(buttonCb)button.onInputDown.add(() => {
                            buttonCb();
                        }, this);

                        button.onInputOut.add(() => {
                            button._hoverText.alpha = 0;

                            watchHeCar();
                        }, this);

                        button.onInputOver.add(() => {
                            button._hoverText.alpha = 0.5;

                            watchHeCar(departmet, i + 1);
                        }, this);
                    }
                }
            }

            iconsWrap.position.set(0, 41);
            wrap.addChild(iconsWrap);

            //anim

            if(anim) {
                for(let i = 0, arr = icons, l = arr.length; i < l; i+=1) {
                    const elem = arr[i],
                          x = elem.position.x,
                          y = elem.position.y;

                    elem.position.set(x, y + 95);

                    this.game.add.tween(elem.position).to({}, Math.abs(i - 3) * 100 + 200, "Linear").to({x: x, y: y}, 400, Phaser.Easing.Back.Out, true);
                }

                car.alpha = info.alpha = 0;

                this.game.add.tween(info).to({}, 340, "Linear").to({alpha: 1}, 430, Phaser.Easing.Bounce.In, true);
                this.game.add.tween(car).to({}, 320, "Linear").to({alpha: 1}, 450, Phaser.Easing.Bounce.In, true);
            }

            if(anim2) {
                for(let i = 0, arr = buttons, l = arr.length; i < l; i+=1) {
                    const elem = arr[i];

                    elem.alpha = 0;

                    this.game.add.tween(elem).to({}, Math.round(Math.random() * 3 + 1) * 60 + (anim ? 400 : 20), "Linear").to({alpha: 1}, 350, Phaser.Easing.Bounce.Out, true);
                }
            }

            return close;

        }
    }

    _getDepartNum(name) {
        return (["shield", "motor", "fuel tank", "wheels", "guns", "rocket launcher"]).indexOf(name);
    }

    buyEquipment(name, num, cost) {
        if(this.spendMoney(cost, false)) {
            const depart = this._getDepartNum(name);
            if(depart === -1)return;

            const user = this.getUser(),
                  y = depart + Math.max(user.getVariable("cars").indexOf(2), 0) * 6,
                  x = Math.max(num + 1, user.getVariable(["shop", y, 0]));

            if(name === "guns" || name === "rocket launcher")user.addTo(1, ["stats", "armourer"]);
            user.addTo(1, ["stats", "mechanic"]);

            user.setVariable(x, ["shop", y, 0]);
            user.setVariable(x, ["shop", y, 1]);

            user.save();
        }
    }

    selectEquipment(name, num) {
        const depart = this._getDepartNum(name);

        if(depart === -1)return;

        const user = this.getUser(),
              y = depart + Math.max(user.getVariable("cars").indexOf(2), 0) * 6,
              x = num + 1;

        user.setVariable(x, ["shop", y, 1]);

        user.save();
    }

    spendMoney(cost = 0, save = true) {
        const user = this.getUser(),
              money = user.getVariable("money");

        if(money >= cost) {
            user.addTo(cost, ["stats", "spender"]);
            user.addTo(-cost, "money");
            if(save)user.save();
            return true;
        } else {
            return false;
        }
    }

    openIntro() {
        h5branding.google.sendScreenView('intro');
        const wrap = this.getWrap(),
              comix = new Phaser.Image(this.game, 0, 0, "introComix"),
              text = new Phaser.Text(this.game, -132, -267, "Scientists know how to\nstop this madness. Deliver\nthem to our camp!", {fill: "#000000", fontSize: 17, fontWeight: "bold", align: "center", font: DP3.font2}),
              text2 = new Phaser.Text(this.game, 291, 87, "DEFEND", {fill: "#ffffff", fontSize: 14, stroke: "#000", strokeThickness: 3, font: DP3.font4}),
              button = new Phaser.Button(this.game, 387, 282, "button1", this.data.callbacks.openLevelsMenu ? this.data.callbacks.openLevelsMenu : null, this, "btnBackSmall_002.png", "btnBackSmall_001.png", "btnBackSmall_003.png", "btnBackSmall_001.png");

        this._addSoundForButton(button);

        comix.anchor.set(0.5);
        text.anchor.set(0.5);
        text2.anchor.set(0.5);
        button.anchor.set(0.5);

        button.scale.set(-1, 1);

        wrap.addChild(comix);
        wrap.addChild(text);
        wrap.addChild(text2);
        wrap.addChild(button);

        this.addPage(wrap);
    }

    openEndComix() {
        const wrap = this.getWrap(),
              comix = new Phaser.Image(this.game, 0, 0, "outroComix"),
              text = new Phaser.Text(this.game, 170, -245, "FINALLY WE REACHED THE VAULT ...\nBUT WHAT HIDES BEHIND THOSE GATES?", {fill: "#ffffff", fontSize: 25, stroke: "#000", strokeThickness: 4, font: DP3.font5, align: "center"}),
              button = new Phaser.Button(this.game, 387, 282, "button1", this.data.callbacks.openLevelsMenu ? this.data.callbacks.openLevelsMenu : null, this, "btnGallerySmall_002.png", "btnGallerySmall_001.png", "btnGallerySmall_003.png", "btnGallerySmall_001.png");

        this._addSoundForButton(button);

        comix.anchor.set(0.5);
        text.anchor.set(0.5);
        button.anchor.set(0.5);

        text.lineSpacing = 5;

        wrap.addChild(comix);
        wrap.addChild(text);
        wrap.addChild(button);

        this.addPage(wrap);
    }

    openCrossPromoShop(num) {
        let wrap = this.getWrap(),
            mainSection = this.getWrap(),
            secondSection = this.getWrap(),
            msc = 1 / this.getMainScaleUI(),
            w = msc * this.data.size.width,
            h = msc * this.data.size.height,
            bg = this.getBGGraphics(),
            image = new Phaser.Image(this.game, num ? 40 : 45, 0, num ? "deadParadiseCrossPromoArr01" : "deadParadiseCrossPromoArr02"),
            panel = new Phaser.Image(this.game, 0, 0, "CrosspromoWarning"),
            leftRail = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            rightRail = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            text = new Phaser.Text(this.game, 0, 0, "ride this car in", {fontSize: 64, fill: "#fff"}),
            textShadow = new Phaser.Text(this.game, 0, 0, "ride this car in", {fontSize: 64, fill: "#000", stroke: "#000", strokeThickness: 18}),
            playBtn = new Phaser.Button(this.game, 0, 0, "goToPlayBtn1", () => {this.removePage(wrap);}, this, "btnGoPlay_002.png", "btnGoPlay_001.png", "btnGoPlay_004.png", "btnGoPlay_001.png"),
            txtPlayBtn = new Phaser.Text(this.game, 0, 0, "PLAY", {fill: "#06ffe9", fontSize: 70, fontWeight: "bold", stroke: "#000", strokeThickness: 7}),
            cancelBtn = new Phaser.Button(this.game, 0, 0, "goToPlayBtn1", () => {this.removePage(wrap);}, this, "btnGoPlay_002.png", "btnGoPlay_001.png", "btnGoPlay_004.png", "btnGoPlay_001.png"),
            txtCancelBtn = new Phaser.Text(this.game, 0, 0, "CANCEL", {fill: "#ffacbd", fontSize: 70, fontWeight: "bold", stroke: "#000", strokeThickness: 7});

        this._addSoundForButton(txtPlayBtn);
        this._addSoundForButton(txtCancelBtn);

        panel.anchor.set(0.5);
        panel.position.set(0, -30);

        leftRail.position.set(-775, -650);
        leftRail.anchor.set(0.5, 0);

        rightRail.position.set(778, -650);
        rightRail.anchor.set(0.5, 0);
        rightRail.scale.set(-1, 1);

        image.anchor.set(0.5);

        text.anchor.set(0.5, 0.5);
        text.position.set(0, -330);

        textShadow.alpha = 0.4;
        textShadow.anchor.set(0.5, 0.5);
        textShadow.position.set(0, -330);

        //playBtn
        txtPlayBtn.anchor.set(0.5);
        playBtn._text = txtPlayBtn;
        playBtn.addChild(txtPlayBtn);
        playBtn.anchor.set(0.5);
        playBtn.scale.set(0.95);
        playBtn.position.set(460, 410);

        playBtn.onInputOut.add(() => {
            playBtn._text.fontSize = 70;
        }, this);
        playBtn.onInputOver.add(() => {
            playBtn._text.fontSize = 75;
        }, this);
        playBtn.onInputDown.add(() => {
            playBtn._text.fontSize = 70;
            playBtn._text.fill = "#000";
            playBtn._text.stroke = "#656565";
            playBtn._text.strokeThickness = 15;
        }, this);

        //cancelBtn
        txtCancelBtn.anchor.set(0.5);
        cancelBtn._text = txtCancelBtn;
        cancelBtn.addChild(txtCancelBtn);
        cancelBtn.anchor.set(0.5);
        cancelBtn.scale.set(0.95);
        cancelBtn.position.set(-400, 410);

        cancelBtn.onInputOut.add(() => {
            cancelBtn._text.fontSize = 70;
        }, this);
        cancelBtn.onInputOver.add(() => {
            cancelBtn._text.fontSize = 75;
        }, this);
        cancelBtn.onInputDown.add(() => {
            cancelBtn._text.fontSize = 70;
            cancelBtn._text.fill = "#000";
            cancelBtn._text.stroke = "#656565";
            cancelBtn._text.strokeThickness = 15;
        }, this);

        secondSection.addChild(panel);
        secondSection.addChild(image);
        secondSection.addChild(textShadow);
        secondSection.addChild(text);
        secondSection.addChild(playBtn);
        secondSection.addChild(cancelBtn);

        mainSection.addChild(secondSection);
        mainSection.addChild(leftRail);
        mainSection.addChild(rightRail);

        wrap.addChild(bg);
        wrap.addChild(mainSection);

        this.addPage(wrap);
    }

    openMenuPause(data = {}, anim = true) {
        h5branding.google.sendScreenView('pause_menu');
        let wrap = this.getWrap(),
            msc = 1 / this.getMainScaleUI(),
            w = msc * this.data.size.width,
            h = msc * this.data.size.height,
            bg = this.getBGGraphics("#000", 0.8),
            wrapPanel = new Phaser.Sprite(this.game, 0, 0),
            panel = new Phaser.Image(this.game, 0, 0, "panelPause"),
            title = new Phaser.Text(this.game, 0, 0, "PAUSED", {fill: "#fff", fontSize: 50, fontWeight: "bold", font: DP3.font2}),
            missionText = new Phaser.Text(this.game, 0, 0, "Mission " + (data.level || 1), {fill: "#00ffe9", fontSize: 24, fontWeight: "bold", stroke: "#000", strokeThickness: 3, font: DP3.font2}),
            iconMoney = new Phaser.Image(this.game, 0, 0, "pauseIcoMoney"),
            textMoney = new Phaser.Text(this.game, 0, 0, this.core.user.getVariable("money") || "0", {fill: "#00ffe9", fontSize: 21, fontWeight: "bold", stroke: "#000", strokeThickness: 3, font: DP3.font2});

        panel.anchor.set(0, 0.5);

        title.anchor.set(0.5, 0.5);

        missionText.anchor.set(0, 1);
        missionText.position.set(25, -276);
        missionText.setShadow(0, 0, '#00ffe9', 6);

        iconMoney.anchor.set(0.5, 0.5);
        iconMoney.position.set(40, -260);

        textMoney.anchor.set(0, 0.45);
        textMoney.position.set(55, -260);
        textMoney.setShadow(0, 0, '#00ffe9', 5);

        wrapPanel.position.set(-w/2, 0);
        wrapPanel.addChild(panel);
        wrapPanel.addChild(missionText);
        wrapPanel.addChild(iconMoney);
        wrapPanel.addChild(textMoney);

        //Buttons
        let achievButton = new Phaser.Button(this.game, 0, 0, "button1", this.openAchivMenu, this, "btnAchievementsSmall_002.png", "btnAchievementsSmall_001.png", "btnAchievementsSmall_003.png", "btnAchievementsSmall_001.png");
        achievButton.anchor.set(0.5, 0.5);
        achievButton.position.set(73, -135);
        wrapPanel.addChild(achievButton);
        this._addSoundForButton(achievButton);

        let statButton = new Phaser.Button(this.game, 0, 0, "button1", this.openStatisticsMenu, this, "btnStatisticsSmall_002.png", "btnStatisticsSmall_001.png", "btnStatisticsSmall_003.png", "btnStatisticsSmall_001.png");
        statButton.anchor.set(0.5, 0.5);
        statButton.position.set(73, -65);
        wrapPanel.addChild(statButton);
        this._addSoundForButton(statButton);

        let menuButton = new Phaser.Button(this.game, 0, 0, "button1", this.data.callbacks.openLevelsMenu ? this.data.callbacks.openLevelsMenu : null, this, "btnGallerySmall_002.png", "btnGallerySmall_001.png", "btnGallerySmall_003.png", "btnGallerySmall_001.png");
        menuButton.anchor.set(0.5, 0.5);
        menuButton.position.set(73, -205);
        wrapPanel.addChild(menuButton);
        this._addSoundForButton(menuButton);

        let helpButton = new Phaser.Button(this.game, 0, 0, "button1", this.openHelpMenu, this, "btnHelp_002.png", "btnHelp_001.png", "btnHelp_003.png", "btnHelp_001.png");
        helpButton.anchor.set(0.5, 0.5);
        helpButton.position.set(73, 20);
        wrapPanel.addChild(helpButton);
        this._addSoundForButton(helpButton);

        let settingsButton = new Phaser.Button(this.game, 0, 0, "button1", this.openSettingsMenu, this, "btnSettings_002.png", "btnSettings_001.png", "btnSettings_003.png", "btnSettings_001.png");
        settingsButton.anchor.set(0.5, 0.5);
        settingsButton.position.set(73, 277);
        wrapPanel.addChild(settingsButton);
        this._addSoundForButton(settingsButton);

        let playButton = new Phaser.Button(this.game, 0, 0, "button1", () => {
            h5branding.google.sendScreenView('gameplay');
            this.coverPages();
            const x = wrapPanel._def_x - 208,
                  y = wrapPanel._def_y;

            this.game.add.tween(bg).to({alpha: 0}, 100, "Linear", true);
            this.game.add.tween(title).to({alpha: 0}, 100, "Linear", true);
            this.game.add.tween(wrapPanel.position).to({x: x, y: y}, 100, "Linear", true).onComplete.add(() => {
                this.removePage(wrap);
                this.uncoverPages();
                if(this.data.callbacks.playGame) {
                    this.data.callbacks.playGame();
                }
            });
        }, this, "btnPlaySmall_002.png", "btnPlaySmall_001.png", "btnPlaySmall_003.png", "btnPlaySmall_001.png");
        playButton.anchor.set(0.5, 0.5);
        playButton.scale.set(1.23);
        playButton.position.set(146, -173);
        wrapPanel.addChild(playButton);
        this._addSoundForButton(playButton);

        let restartButton = new Phaser.Button(this.game, 0, 0, "button1", () => {
            h5ads.adWrapper.on(h5ads.AdEvents.CONTENT_PAUSED, () => {
                this.game.paused = true;
                this.core.sound.pauseAll();
            });
            h5ads.adWrapper.on(h5ads.AdEvents.CONTENT_RESUMED, () => {
                h5branding.google.sendScreenView('advertisement_restart');
                this.game.paused = false;
                this.removePage(wrap);
                this.core.sound.resumeAll();
                if(this.data.callbacks.restartLevel) {
                    this.data.callbacks.restartLevel();
                }
                h5ads.adWrapper.removeAllListeners(h5ads.AdEvents.CONTENT_PAUSED);
                h5ads.adWrapper.removeAllListeners(h5ads.AdEvents.CONTENT_RESUMED);
            });
            h5ads.adWrapper.showAd(h5ads.AdType.interstitial);

        }, this, "btnRestartSmall_002.png", "btnRestartSmall_001.png", "btnRestartSmall_003.png", "btnRestartSmall_001.png");
        restartButton.anchor.set(0.5, 0.5);
        restartButton.position.set(146, -100);
        wrapPanel.addChild(restartButton);
        this._addSoundForButton(restartButton);

        wrap.addChild(bg);
        wrap.addChild(wrapPanel);
        wrap.addChild(title);
        this.addPage(wrap);

        wrapPanel.position.x = wrapPanel._def_x = -w/2;
        wrapPanel.position.y = wrapPanel._def_y = 0;

        if(anim) {
            this.coverPages();

            const x = wrapPanel._def_x,
                  y = wrapPanel._def_y;

            wrapPanel.position.set(x - 208, y);
            bg.alpha = 0;
            title.alpha = 0;

            this.game.add.tween(wrapPanel.position).to({x: x, y: y}, 100, "Linear", true).onComplete.add(this.uncoverPages.bind(this));;
            this.game.add.tween(bg).to({alpha: 1}, 100, "Linear", true);
            this.game.add.tween(title).to({alpha: 1}, 100, "Linear", true);
        }
    }

    getProgressStarsLine(level = 1, anim, score = 0) {
        const wrapStars = new Phaser.Sprite(this.game, 0, 0),
              levelData = this._getLevelConfig(level || 1),
              bgStars = new Phaser.Image(this.game, 0, 0, "cashProgress"),
              cashProgress = this.game.cache.getImage("cashProgress"),
              bmd = new Phaser.BitmapData(this.game, "cashProgress", cashProgress.width, cashProgress.height),
              bmd2 = new Phaser.BitmapData(this.game, "cashProgress", cashProgress.width, cashProgress.height),
              gr = new Phaser.Graphics(this.game, 0, 0),
              data = this._calculStarsData(level),
              aS = anim && data.record < score,
              t = 1100;

        gr.beginFill(0x000000);

        if(aS) {
            //test anim
            const fw = score / levelData.stars[levelData.stars.length - 1].target,
                  dx = (fw - data.progress) * cashProgress.width;

            gr.position.x = -dx;
            gr.drawRect(-cashProgress.width / 2, -cashProgress.height / 2, cashProgress.width * fw, cashProgress.height);

            this.game.add.tween(gr.position).to({x: 0}, t, "Linear", true);
        } else {
            gr.drawRect(-cashProgress.width / 2, -cashProgress.height / 2, cashProgress.width * data.progress, cashProgress.height);
        }

        bmd.fill(34, 214, 248, 1);
        bmd2.alphaMask(bmd, cashProgress, new Phaser.Rectangle(0, 0, cashProgress.width, cashProgress.height), new Phaser.Rectangle(0, 0, cashProgress.width, cashProgress.height));

        const imageCashProgress = new Phaser.Image(this.game, 0, 0, bmd2);
        imageCashProgress.anchor.set(0.5, 0.5);
        imageCashProgress.mask = gr;

        bgStars.anchor.set(0.5, 0.5);
        wrapStars.addChild(gr);
        wrapStars.addChild(bgStars);
        wrapStars.addChild(imageCashProgress);
        for(let i = 0, arr = levelData.stars, l = arr.length; i < l; i+=1) {
            let target = levelData.stars[i].target,
                status = data.record >= target,
                wrap = new Phaser.Sprite(this.game, (i / (l - 1) - 0.5) * (345 / l) * 2, 0),
                image = new Phaser.Image(this.game, 0, 0, "briefing1", status ? "star_002.png" : "star_001.png");

            image.anchor.set(0.5, 0.5);
            wrap.addChild(image);

            if(!status) {
                let textWrap = this.getWrap(),
                    text1 = new Phaser.Text(this.game, 0, -15, "kill", {fill: "#fff", fontSize: 15, font: DP3.font2, stroke: "#000", strokeThickness: 1}),
                    text2 = new Phaser.Text(this.game, 0, 5, levelData.stars[i].target, {fill: "#fff", fontSize: 19, font: DP3.font2, stroke: "#000", strokeThickness: 1}),
                    text3 = new Phaser.Text(this.game, 0, 25, "enemies", {fill: "#fff", fontSize: 12, font: DP3.font2, stroke: "#000", strokeThickness: 1}),
                    text4 = new Phaser.Text(this.game, 0, 51, "reward", {fill: "#23a79e", fontSize: 11, font: DP3.font2}),
                    text5 = new Phaser.Text(this.game, 0, 67, "+" + levelData.stars[i].price + "$", {fill: "#23a79e", fontSize: 17, fontWeight: "bold", font: DP3.font2});

                text1.anchor.set(0.5, 0.5);
                text2.anchor.set(0.5, 0.5);
                text3.anchor.set(0.5, 0.5);
                text4.anchor.set(0.5, 0.5);
                text5.anchor.set(0.5, 0.5);

                text1.setShadow(0, 0, 'rgb(0, 173, 158)', 10);
                text2.setShadow(0, 0, 'rgb(0, 173, 158)', 10);
                text3.setShadow(0, 0, 'rgb(0, 173, 158)', 10);

                textWrap.addChild(text1);
                textWrap.addChild(text2);
                textWrap.addChild(text3);
                textWrap.addChild(text4);
                textWrap.addChild(text5);

                wrap.addChild(textWrap);

                if(aS && score >= target) {
                    const star = new Phaser.Image(this.game, 0, 0, "briefing1", "star_002.png"),
                          wt = t * (target - data.record) / (score - data.record);

                    star.anchor.set(0.5);
                    star.scale.set(0);
                    wrap.addChild(star);

                    this.game.add.tween(star.scale).to({}, wt).to({x: 1, y: 1}, 250, Phaser.Easing.Back.Out, true).onComplete.add(() => {
                        textWrap.visible = false;
                    });

                    this.game.add.tween(textWrap).to({}, wt - 100).to({alpha: 0}, 350, "Linear", true);
                }
            }

            wrapStars.addChild(wrap);
        }

        return wrapStars;
    }

    listener() {
        window.open("https://kizi.com/games/dead-paradise-3");
    }

    openMenuFinish(data = {}, win = false, cb) {
        this.core.sound.stopAll();

        let wrap = this.getWrap(),
            infoWrap = this.getWrap(),
            msc = 1 / this.getMainScaleUI(),
            w = msc * this.data.size.width,
            h = msc * this.data.size.height,
            bg = this.getBGGraphics("#000000", 0.8),
            wrapPanel = new Phaser.Sprite(this.game, 0, 0),
            levelData = this.getUser().getLevelData(),
            achivAnim = null,
            upgradesAnim = null,
            check = () => {
                if(achivAnim)achivAnim.visible = this._checkAchivs();
                if(upgradesAnim)upgradesAnim.visible = this._checkUpgrades();
            };

        wrap.addChild(bg);

        if(win) {
            h5branding.gameanalytics.addProgressionEvent(h5branding.EGAProgressionStatus.Complete, 'Mission', data.level.toString());
            this.core.sound.play("60_End_sn", false);

            const girl = new Phaser.Image(this.game, 0, 0, "girl"),
                  panel = new Phaser.Image(this.game, 0, 0, "panelDialog"),
                  header = new Phaser.Image(this.game, 0, 0, "captionPanel"),
                  title = new Phaser.Text(this.game, 18, -5, "Congratulations", {fill: "#fff", fontSize: 21, font: DP3.font3}),
                  missionText = new Phaser.Text(this.game, 0, 0, "MISSION " + (data.level || 1), {fill: "#00ffe9", fontSize: 23, stroke: "#000", strokeThickness: 3}),
                  textParadise = new Phaser.Text(this.game, 0, 0, "paradise awaits you!", {fill: "#cf0000", fontSize: 17, font: DP3.font3}),
                  stars = this.getProgressStarsLine(data.level, true, levelData.score),
                  lamp = new Phaser.Image(this.game, 0, 0, "dialogBox1", "flashLightRed_001.png");

            panel.anchor.set(1, 0.5);

            wrapPanel.addChild(panel);

            girl.anchor.set(1, 1);
            girl.scale.set(-0.9, 0.9);
            girl.position.set(-w/2 - 50, h/2);

            title.anchor.set(0.5, 0.5);

            header.anchor.set(0.5, 0.5);
            header.position.set(35 - w/2, -275);
            header.addChild(title);

            missionText.anchor.set(1, 1);
            missionText.position.set(-32, -270);
            missionText.setShadow(0, 0, '#00ffe9', 6);

            wrapPanel.addChild(missionText);

            //calcul total money
            const record = this._calculStarsData(data.level).record;
            let totalMoney = levelData.money;

            if(record < levelData.score) {
                for(let i = 0, arr = this._getLevelConfig(data.level).stars, l = arr.length; i < l; i+=1) {
                    const target = arr[i].target;
                    if(target > record && target <= levelData.score) {
                        totalMoney+=arr[i].price;
                    }
                }
            }

            const earnedText = new Phaser.Text(this.game, -485, -100, "Money", {fill: "#0ae0d4", fontSize: 21, font: DP3.font1, fontWeight: "bold"}),
                  earnedValue = new Phaser.Text(this.game, -210, -100, Number(levelData.money) + "$", {fill: "#0ae0d4", fontSize: 21, font: DP3.font2, fontWeight: "bold"}),
                  totalText = new Phaser.Text(this.game, -485, 100, "Total money:", {fill: "#0ae0d4", fontSize: 21, font: DP3.font1, fontWeight: "bold"}),
                  totalValue = new Phaser.Text(this.game, -210, 100, Number(totalMoney) + "$", {fill: "#0ae0d4", fontSize: 21, font: DP3.font2, fontWeight: "bold"});

            levelData.money = totalMoney;

            earnedText.anchor.set(0, 0.5);
            earnedValue.anchor.set(1, 0.5);

            wrapPanel.addChild(earnedText);
            wrapPanel.addChild(earnedValue);

            totalText.anchor.set(0, 0.5);
            totalValue.anchor.set(1, 0.5);

            wrapPanel.addChild(totalText);
            wrapPanel.addChild(totalValue);

            textParadise.anchor.set(0.5);
            lamp.anchor.set(0.5);
            textParadise.position.set(-400 + w/2, 290);
            lamp.position.set(-572 + w/2, 291);
            textParadise.setShadow(0, 0, '#000', 6);

            //stars
            stars.position.set(-375, -20);
            wrapPanel.addChild(stars);

            //Buttons
            let achievButton = new Phaser.Button(this.game, 0, 0, "button1", () => {this.openAchivMenu(true, check);}, this, "btnAchievementsSmall_002.png", "btnAchievementsSmall_001.png", "btnAchievementsSmall_003.png", "btnAchievementsSmall_001.png");
            achievButton.anchor.set(0.5, 0.5);
            achievButton.position.set(-112, 170);
            wrapPanel.addChild(achievButton);
            this._addSoundForButton(achievButton);

            let shopButton = new Phaser.Button(this.game, 0, 0, "button1", () => {this.openShop(true, check);}, this, "btnShopSmall_002.png", "btnShopSmall_001.png", "btnShopSmall_003.png", "btnShopSmall_001.png");
            shopButton.anchor.set(0.5, 0.5);
            shopButton.scale.set(1.23);
            shopButton.position.set(-112, -175);
            wrapPanel.addChild(shopButton);
            this._addSoundForButton(shopButton);

            let menuButton = new Phaser.Button(this.game, 0, 0, "button1", this.data.callbacks.openLevelsMenu ? this.data.callbacks.openLevelsMenu : null, this, "btnGallerySmall_002.png", "btnGallerySmall_001.png", "btnGallerySmall_003.png", "btnGallerySmall_001.png");
            menuButton.anchor.set(0.5, 0.5);
            menuButton.position.set(-112, 90);
            wrapPanel.addChild(menuButton);
            this._addSoundForButton(menuButton);

            let nextButton = new Phaser.Button(this.game, 0, 0, "button1", () => {
                h5ads.adWrapper.on(h5ads.AdEvents.CONTENT_PAUSED, () => {
                    this.game.paused = true;
                    this.core.sound.pauseAll();
                });
                h5ads.adWrapper.on(h5ads.AdEvents.CONTENT_RESUMED, () => {
                    h5branding.google.sendScreenView('advertisement_next');
                    this.game.paused = false;
                    this.core.sound.resumeAll();
                    if(this.data.callbacks.nextLevel) {
                        this.data.callbacks.nextLevel(() => {
                            this.removePage(wrap);
                            if(cb) {
                                cb();
                            }
                        });
                    }
                    h5ads.adWrapper.removeAllListeners(h5ads.AdEvents.CONTENT_PAUSED);
                    h5ads.adWrapper.removeAllListeners(h5ads.AdEvents.CONTENT_RESUMED);
                });
                h5ads.adWrapper.showAd(h5ads.AdType.interstitial);

            }, this, "btnNextSmall_002.png", "btnNextSmall_001.png", "btnNextSmall_003.png", "btnNextSmall_001.png");
            nextButton.anchor.set(0.5, 0.5);
            nextButton.scale.set(1.23);
            nextButton.position.set(-112, -82);
            wrapPanel.addChild(nextButton);
            this._addSoundForButton(nextButton);

            let restartButton = new Phaser.Button(this.game, 0, 0, "button1", () => {
                h5ads.adWrapper.on(h5ads.AdEvents.CONTENT_PAUSED, () => {
                    this.game.paused = true;
                    this.core.sound.pauseAll();
                });
                h5ads.adWrapper.on(h5ads.AdEvents.CONTENT_RESUMED, () => {
                    h5branding.google.sendScreenView('advertisement_restart');
                    this.game.paused = false;
                    this.removePage(wrap);
                    this.core.sound.resumeAll();
                    if(this.data.callbacks.restartLevel) {
                        this.data.callbacks.restartLevel();
                    }
                    h5ads.adWrapper.removeAllListeners(h5ads.AdEvents.CONTENT_PAUSED);
                    h5ads.adWrapper.removeAllListeners(h5ads.AdEvents.CONTENT_RESUMED);
                });
                h5ads.adWrapper.showAd(h5ads.AdType.interstitial);

            }, this, "btnRestartSmall_002.png", "btnRestartSmall_001.png", "btnRestartSmall_003.png", "btnRestartSmall_001.png");
            restartButton.anchor.set(0.5, 0.5);
            restartButton.position.set(-112, 10);
            wrapPanel.addChild(restartButton);
            this._addSoundForButton(restartButton);

            wrap.addChild(wrapPanel);
            wrap.addChild(girl);
            wrap.addChild(textParadise);
            wrap.addChild(lamp);

            wrapPanel.addChild(header);

            this.coverPages();

            wrapPanel.position.x = wrapPanel._def_x = w/2;
            wrapPanel.position.y = wrapPanel._def_y = 0;

            const x = wrapPanel._def_x,
                  y = wrapPanel._def_y,
                  t = 300;

            wrapPanel.position.set(x + 650, y);
            bg.alpha = 0;
            girl.alpha = 0;
            textParadise.alpha = 0;

            //DEBUG
            this.game.time.events.add(t, () => {
                if(this._checkAchivs()) {
                    achivAnim = this._getNewAchievementsAnim(1);
                    achivAnim.position.set(-112, 170);
                    wrapPanel.addChild(achivAnim);
                }

                if(this._checkUpgrades()) {
                    upgradesAnim = this._getNewUpgradesAnim();
                    upgradesAnim.position.set(-112, -175);
                    wrapPanel.addChild(upgradesAnim);
                }
            });

            this._createFrameAnim(lamp, "flashLightRed", true, true);

            this.game.add.tween(wrapPanel.position).to({x: x, y: y}, t, "Linear", true);
            this.game.add.tween(textParadise).to({alpha: 1}, t, "Linear", true);
            this.game.add.tween(girl).to({alpha: 1}, t, "Linear", true);
            this.game.add.tween(bg).to({alpha: 1}, t, "Linear", true).onComplete.add(this.uncoverPages.bind(this));

        } else {
            h5branding.gameanalytics.addProgressionEvent(h5branding.EGAProgressionStatus.Fail, 'Mission', levelData.num.toString());
            this.core.sound.play("56_Lose_sn", false);

            const defeatBG = new Phaser.Image(this.game, 0, 0, "BGDialogDefeat"),
                  title1 = new Phaser.Text(this.game, 0, 0, "DEFEAT", {fill: "#c50000", fontSize: 40, stroke: "#fff", strokeThickness: 5, font: DP3.font3}),
                  missionText = new Phaser.Text(this.game, 0, 0, "LEVEL " + (data.level || 1), {fill: "#d60000", fontSize: 28, fontWeight: "bold", stroke: "#6a0c0a", strokeThickness: 3, font: DP3.font2}),
                  totalMoneyT = new Phaser.Text(this.game, 0, 0, "Total money", {fill: "#fff", fontSize: 20, fontWeight: "bold", font: DP3.font1}),
                  totalMoneyV = new Phaser.Text(this.game, 0, 0, levelData.money + "$", {fill: "#fff", fontSize: 20, fontWeight: "bold", font: DP3.font2});

            defeatBG.anchor.set(0.5);

            wrapPanel.addChild(defeatBG);

            //TV block
            const tvBlock = new Phaser.Sprite(this.game, -200, 0, "V_block"),
                  tvTextWrap = this.getWrap(),
                  tvText = new Phaser.Text(this.game, 0, -27, "CAN'T PASS A\nLEVEL?", {fill: "#ffcc00", fontSize: 34, font: DP3.font5}),
                  tvTitle = new Phaser.Text(this.game, 107, -47, "LEARN HOW TO", {fill: "#6c636b", fontSize: 17, font: DP3.font5}),
                  tvRow = new Phaser.Image(this.game, 10, 45, "row");
            
            tvBlock.inputEnabled = true;
            tvBlock.events.onInputDown.add(this.listener, this);

            tvBlock.anchor.set(0.5);
            tvBlock.scale.set(0.9);

            tvTitle.rotation = Math.PI * 0.02;

            tvTextWrap.position.set(-75, 0);

            tvText.anchor.set(0.5);
            tvTitle.anchor.set(0.5, 1);
            tvRow.anchor.set(0.5);

            tvTextWrap.addChild(tvText);
            tvTextWrap.addChild(tvRow);
            this.game.add.tween(tvTextWrap.scale).to({x: 0.9, y: 0.9}, 500, "Linear").to({x: 1, y: 1}, 500, "Linear", true).loop(true);

            tvBlock.addChild(tvTitle);
            tvBlock.addChild(tvTextWrap);

            wrapPanel.addChild(tvBlock);

            title1.anchor.set(0.5);
            title1.position.set(10, -187);

            wrapPanel.addChild(title1);

            //text
            const title2 = this.getWrap(),
                  title2Arr = ([
                      [
                          "YOU'VE BEEN",
                          22,
                          "KILLED!",
                          35
                      ],
                      [
                          "CONVOY",
                          35,
                          "DESTROYED!",
                          22
                      ]
                  ])[data.type],
                  title2text1 = new Phaser.Text(this.game, 0, 14, title2Arr[0], {fill: "#c50000", fontSize: title2Arr[1], stroke: "#fff", strokeThickness: 4, align: "center", font: DP3.font3}),
                  title2text2 = new Phaser.Text(this.game, 0, 0, title2Arr[2], {fill: "#c50000", fontSize: title2Arr[3], stroke: "#fff", strokeThickness: 4, align: "center", font: DP3.font3});

            title2text1.anchor.set(0.5, 1);
            title2text2.anchor.set(0.5, 0);
            //convoy\ndestroyed!
            //you've been\nkilled!

            title2.position.set(145, -55);

            title2.addChild(title2text2);
            title2.addChild(title2text1);

            wrapPanel.addChild(title2);

            missionText.anchor.set(0, 0.5);
            missionText.position.set(225, -275);

            wrapPanel.addChild(missionText);

            totalMoneyT.anchor.set(0, 0.5);
            totalMoneyV.anchor.set(1, 0.5);
            totalMoneyT.position.set(0, 110);
            totalMoneyV.position.set(250, 110);

            wrapPanel.addChild(totalMoneyT);
            wrapPanel.addChild(totalMoneyV);

            let shopButton = new Phaser.Button(this.game, 0, 0, "button1", this.openShop.bind(this, true, check), this, "btnShopSmall_002.png", "btnShopSmall_001.png", "btnShopSmall_003.png", "btnShopSmall_001.png");
            shopButton.anchor.set(0.5, 0.5);
            shopButton.scale.set(1.3);
            shopButton.position.set(340, -100);
            wrapPanel.addChild(shopButton);
            this._addSoundForButton(shopButton);

            this.game.time.events.add(300, () => {
                if(this._checkUpgrades()) {
                    upgradesAnim = this._getNewUpgradesAnim();
                    upgradesAnim.position.set(340, -100);
                    wrapPanel.addChild(upgradesAnim);
                }
            });

            let menuButton = new Phaser.Button(this.game, 0, 0, "button1", this.data.callbacks.openLevelsMenu ? this.data.callbacks.openLevelsMenu : null, this, "btnGallerySmall_002.png", "btnGallerySmall_001.png", "btnGallerySmall_003.png", "btnGallerySmall_001.png");
            menuButton.anchor.set(0.5, 0.5);
            menuButton.position.set(340, 100);
            wrapPanel.addChild(menuButton);
            this._addSoundForButton(menuButton);

            let restartButton = new Phaser.Button(this.game, 0, 0, "button1", () => {
                h5ads.adWrapper.on(h5ads.AdEvents.CONTENT_PAUSED, () => {
                    this.game.paused = true;
                    this.core.sound.pauseAll();
                });
                h5ads.adWrapper.on(h5ads.AdEvents.CONTENT_RESUMED, () => {
                    h5branding.google.sendScreenView('advertisement_restart');
                    this.game.paused = false;
                    this.core.sound.resumeAll();
                    this.getUser().addTo(1, ["stats", "persistent"]);
                    this.getUser().save();
                    if(this.data.callbacks.restartLevel) {
                        this.removePage(wrap);
                        this.data.callbacks.restartLevel();
                    }
                    h5ads.adWrapper.removeAllListeners(h5ads.AdEvents.CONTENT_PAUSED);
                    h5ads.adWrapper.removeAllListeners(h5ads.AdEvents.CONTENT_RESUMED);
                });
                h5ads.adWrapper.showAd(h5ads.AdType.interstitial);

            }, this, "btnRestartSmall_002.png", "btnRestartSmall_001.png", "btnRestartSmall_003.png", "btnRestartSmall_001.png");
            restartButton.anchor.set(0.5, 0.5);
            restartButton.scale.set(1.45);
            restartButton.position.set(340, 0);
            wrapPanel.addChild(restartButton);
            this._addSoundForButton(restartButton);

            this.coverPages();
            wrap.alpha = 0;
            this.game.add.tween(wrap).to({alpha: 1}, 250, "Linear", true).onComplete.add(this.uncoverPages.bind(this));
        }

        wrap.addChild(wrapPanel);

        this.addPage(wrap);
    }

    addLootAnim(x, y, type) {//
        if(this.levelInterface)this.levelInterface.addLootAnim(x, y, type);
    }

    girlTalk(text, type) {
        if(this.levelInterface)this.levelInterface.girlTalk(text, type);
    }

    openLevelUIPage() {
        let wrap = this.getWrap(),
            msc = 1 / this.getMainScaleUI(),
            w = msc * this.data.size.width,
            h = msc * this.data.size.height,
            isMbl = this.game.isMobile,
            mainImage = this.game.cache.getImage("backgroundMainMenu"),
            bottomPanel = new Phaser.Image(this.game, 0, 0, isMbl ? "ui-bg" : "GIPanelDown"),
            topPanel = new Phaser.Image(this.game, 0, 0, "GIPanelTop"),
            top2Panel = new Phaser.Image(this.game, 0, 0, "GIPanelTop2"),
            topRightPanel = new Phaser.Image(this.game, 0, 0, "GIPanelTopRight"),
            levelData = this.core.getUser().getLevelData() || {},
            core = new DP3.LevelInterface({game: this.game, levelData: levelData, levelConfig: this._getLevelConfig(levelData.num) || {}});

        this.levelInterface = core;

        bottomPanel.position.set(-w*0.5, h*0.5);
        bottomPanel.anchor.set(0, 1);

        topPanel.position.set(-w*0.5, -h*0.5);

        topRightPanel.position.set(w*0.5, -h*0.5);
        topRightPanel.anchor.set(1, 0);

        top2Panel.position.set(-w*0.5 + 290, -h*0.5 + 35);
        top2Panel.anchor.set(0, 0);

        wrap.addChild(bottomPanel);
        wrap.addChild(top2Panel);
        wrap.addChild(topPanel);
        wrap.addChild(topRightPanel);

        if(!isMbl) {
            const startText = new Phaser.Text(this.game, isMbl ? -48 : -247, 296, "Start", {fontSize: 16, fill: "#82ecfe", fontWeight: "bold", font: DP3.font1});
            startText.anchor.set(0.5);

            startText.setShadow(0, 0, '#82ecfe', 2);

            wrap.addChild(startText);
        }

        //Buttons
        let pauseButton = new Phaser.Button(this.game, 0, 0, "button1", this.data.callbacks.openMenuPause ? this.data.callbacks.openMenuPause : null, this, "btnPauseSmall_002.png", "btnPauseSmall_001.png", "btnPauseSmall_003.png", "btnPauseSmall_001.png");
        pauseButton.anchor.set(0.5, 0.5);
        pauseButton.scale.set(0.75);
        pauseButton.position.set(w*0.5 - 30, -h*0.5 + 30);
        wrap.addChild(pauseButton);
        this._addSoundForButton(pauseButton);

        let restartButton = new Phaser.Button(this.game, 0, 0, "button1", this.data.callbacks.restartLevel ? this.data.callbacks.restartLevel : null, this, "btnRestartSmall_002.png", "btnRestartSmall_001.png", "btnRestartSmall_003.png", "btnRestartSmall_001.png");
        restartButton.anchor.set(0.5, 0.5);
        restartButton.scale.set(0.75);
        restartButton.position.set(w*0.5 - 87, -h*0.5 + 30);
        wrap.addChild(restartButton);
        this._addSoundForButton(restartButton);

        this.addPage(wrap);
        this.addPage(core);

        if(this._mobInp) {
            this.addPage(this._createMobileInputs());
        }
    }

    openInfoMenu(anim = true) {
        h5branding.google.sendScreenView('credits');
        let wrap = this.getWrap(),
            context = this.getWrap(),
            mainSection = this.getWrap(),
            secondSection = this.getWrap(),
            msc = 1 / this.getMainScaleUI(),
            bg = this.getBGGraphics(),
            panel = new Phaser.Image(this.game, 0, 0, "panelInfo"),
            logo = new Phaser.Image(this.game, 0, 0, "infoLogo"),
            logoShadow = new Phaser.Image(this.game, 0, 0, "infoLogo"),
            railL = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            railR = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            title = new Phaser.Text(this.game, 0, 0, "CREDITS", {fontSize: 18, fill: "#ffffff", font: DP3.font3}),
            cancel = new Phaser.Button(this.game, 0, 0, "button1", () => {
                if(DP3.isMainMenu) {
                    h5branding.google.sendScreenView('main_menu'); // hacky, no time for proper fix
                }
                this.coverPages();
                this.sndHideWindow();

                const x = mainSection._def_x,
                      y = mainSection._def_y,
                      x1 = secondSection._def_x,
                      y1 = secondSection._def_y;

                this.game.add.tween(mainSection.position).to({}, 130, "Linear").to({x: x, y: y - 650}, 250, "Linear", true).onComplete.add(() => {this.uncoverPages(); this.removePage(wrap);});
                this.game.add.tween(secondSection.position).to({x: x1, y: y1 - 100}, 80, "Linear", true);
                this.game.add.tween(bg).to({alpha: 0}, 380, "Linear", true);
            }, this, "btnCancelSmall_002.png", "btnCancelSmall_001.png", "btnCancelSmall_003.png", "btnCancelSmall_001.png"),
            style1 = {
                styles: {
                    fill: "#FFFFFF",
                    fontSize: 13,
                    align: "center",
                    stroke: "#000000",
                    strokeThickness: 3,
                    fontWeight: 100,
                    font: DP3.font1
                },
                shadow: {
                    x: 0,
                    y: 0,
                    fill: "#000000",
                    blur: 4
                }
            },
            style2 = {
                styles: {
                    fill: "#02ecd9",
                    fontSize: 16,
                    align: "center",
                    stroke: "#00433d",
                    strokeThickness: 3,
                    font: DP3.font1
                },
                shadow: {
                    x: 0,
                    y: 0,
                    fill: "#009388",
                    blur: 5
                }
            },
            textList1 = ["Taras Kruk, Alexandr Zalevsky, Mykola Matviychuk,\nOlexandr Bodov", "Dima Nahorny, Yuriy Semenjuk, Oleksiy Tkachenko", "Olexandr Bodov, Maxym Gubysh, Iryna Paliy", "Oleksandr Maksymenko, Maksym Melnychuk", "Aleksandar Dimitrijevic, Emmett Cooke", "Mykola Matviychuk, Anastasia Kravchuk, Oleksandr Romanjuk", "Julia Michka, Anna Kalenska, Sergiy Maksymchuk, Denys Godunko,\nOlga Gnatiuk, Anton Kosikov, Bogdan Zalevsky"],
            textList2 = ["Producers:", "Programmers:", "Artists:", "Level Design:", "Music & SFX:", "QA:", "Testers:"],
            textSettings = [],
            createInstr = function(list, style, sett, y = 0, d = 0) {
                for(let i = 0, arr = list, l = arr.length; i < l; i+=1) {
                    const elem = {
                        text: list[i],
                        anchor: [0.5, 0.5],
                        positions: [0, y + d * i]
                    };

                    for(let key in style) {
                        elem[key] = style[key];
                    }

                    sett.push(elem);
                }
            };

        for(let i = 0, arr = [textList1, textList2], styles = [style1, style2], y = [177, 130], d = [95, 95], l = Math.min(arr.length, styles.length); i < l; i+=1) {
            createInstr(arr[i], styles[i], textSettings, y[i], d[i]);
        }

        textSettings = textSettings.concat([
            {
                text: "2013 Smokoko",
                positions: [0, 30],
                anchor: [0.5, 0.5],
                styles: {
                    fill: "#02ecd9",
                    fontSize: 16,
                    align: "center",
                    stroke: "#00433d",
                    strokeThickness: 3,
                    font: DP3.font1
                },
                shadow: {
                    x: 0,
                    y: 0,
                    fill: "#009388",
                    blur: 5
                }
            },
            {
                text: "Game developed by SMOKOKO S.A. ",
                positions: [0, 75],
                anchor: [0.5, 0.5],
                styles: {
                    fill: "#02ecd9",
                    fontSize: 16,
                    align: "center",
                    stroke: "#00433d",
                    strokeThickness: 3,
                    font: DP3.font1
                },
                shadow: {
                    x: 0,
                    y: 0,
                    fill: "#009388",
                    blur: 5
                }
            },
            {
                text: "WWW.SMOKOKO.COM",
                positions: [0, 820],
                anchor: [0.5, 0.5],
                styles: {
                    fill: "#e8db3a",
                    fontSize: 18,
                    align: "center",
                    stroke: "#00433d",
                    strokeThickness: 3,
                    font: DP3.font1
                },
                shadow: {
                    x: 0,
                    y: 0,
                    fill: "#009388",
                    blur: 5
                }
            }
        ]);

        context.position.set(0, 130);

        this._addSoundForButton(cancel);

        panel.anchor.set(0.5, 0);
        railL.anchor.set(0.5, 0.2);
        railR.anchor.set(0.5, 0.2);
        logo.anchor.set(0.5, 0.5);
        logoShadow.anchor.set(0.5, 0.5);
        title.anchor.set(0, 1);

        railL.position.set(-271, 0);
        railR.position.set(271, 0);
        railR.scale.set(-1, 1);

        logo.position.set(0, 90);
        logoShadow.position.set(0, 92);
        title.position.set(-217, 90);

        logoShadow.tint = "#000000";
        logoShadow.alpha = 0.8;

        secondSection.addChild(panel);

        for(let i = 0, arr = this.drawTextToInstructions(textSettings, context), l = arr.length; i < l; i+=1) {
            arr[i].lineSpacing = -11;
        }

        secondSection.addChild(context);

        mainSection.addChild(secondSection);
        mainSection.addChild(railL);
        mainSection.addChild(railR);

        cancel.anchor.set(0.5, 0.5);
        cancel.scale.set(0.75);
        cancel.position.set(215, 55);

        secondSection.addChild(logoShadow);
        secondSection.addChild(logo);
        secondSection.addChild(title);
        secondSection.addChild(cancel);

        wrap.addChild(bg);
        wrap.addChild(mainSection);


        this.addPage(wrap);

        mainSection.position.x = mainSection._def_x = 0;
        mainSection.position.y = mainSection._def_y = - this.data.size.height * 0.5 * msc;

        secondSection.position.x = secondSection._def_x = 0;
        secondSection.position.y = secondSection._def_y = 0;

        if(anim) {
            this.coverPages();
            this.sndOpenWindow();

            const x = mainSection._def_x,
                  y = mainSection._def_y,
                  x1 = secondSection._def_x,
                  y1 = secondSection._def_y;

            mainSection.position.set(x, y - 650);
            secondSection.position.set(x1, y1 - 100);
            bg.alpha = 0;

            this.game.add.tween(mainSection.position).to({x: x, y: y}, 250, "Linear", true);
            this.game.add.tween(secondSection.position).to({}, 300, "Linear").to({x: x1, y: y1}, 80, "Linear", true).onComplete.add(this.uncoverPages.bind(this));
            this.game.add.tween(bg).to({alpha: 1}, 380, "Linear", true);
        }
    }

    openHelpMenu(anim, cb, num = 1) {
        h5branding.google.sendScreenView('help_menu');
        let wrap = this.getWrap(),
            mainSection = this.getWrap(),
            secondSection = this.getWrap(),
            msc = 1 / this.getMainScaleUI(),
            bg = this.getBGGraphics("#000", 0.7),
            imgBG = this.getBGImage(),
            panel = new Phaser.Image(this.game, 0, 0, "helpPanel"),
            bgGround = new Phaser.Image(this.game, 0, 0, "helpPanel"),
            railL = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            railR = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            title = new Phaser.Text(this.game, 0, 0, "Help", {fontSize: 23, fill: "#ffffff", font: DP3.font3}),
            cancel = new Phaser.Button(this.game, 0, 0, "button1", () => {
                if(DP3.isMainMenu) {
                    h5branding.google.sendScreenView('main_menu'); // hacky, no time for proper fix
                }
                DP3.sendMenuEvents = true;
                this.coverPages();
                this.sndHideWindow();

                const x = mainSection._def_x,
                      y = mainSection._def_y,
                      x1 = secondSection._def_x,
                      y1 = secondSection._def_y;

                this.game.add.tween(mainSection.position).to({}, 130, "Linear").to({x: x, y: y - 650}, 250, "Linear", true).onComplete.add(() => {this.uncoverPages(); this.removePage(wrap); if(cb && cb instanceof Function)cb();});
                this.game.add.tween(secondSection.position).to({x: x1, y: y1 - 100}, 80, "Linear", true);
                this.game.add.tween(bg).to({alpha: 0}, 380, "Linear", true);
            }, this, "btnCancelSmall_002.png", "btnCancelSmall_001.png", "btnCancelSmall_003.png", "btnCancelSmall_001.png"),
            context = this.getWrap();

        this._addSoundForButton(cancel);

        panel.anchor.set(0.5, 0);
        railL.anchor.set(0.5, 0.2);
        railR.anchor.set(0.5, 0.2);
        title.anchor.set(0.5, 1);

        railL.position.set(-283, 0);
        railR.position.set(283, 0);
        railR.scale.set(-1, 1);

        panel.position.set(0, 80);

        title.position.set(0, 155);
        context.position.set(0, 300);

        this.getHelpContext(num, context);

        secondSection.addChild(panel);
        mainSection.addChild(secondSection);
        mainSection.addChild(railL);
        mainSection.addChild(railR);

        cancel.anchor.set(0.5, 0.5);
        cancel.scale.set(0.75);
        cancel.position.set(235, 102);

        secondSection.addChild(title);
        secondSection.addChild(context);
        secondSection.addChild(cancel);

        wrap.addChild(imgBG);
        wrap.addChild(bg);
        wrap.addChild(mainSection);


        this.addPage(wrap);

        mainSection.position.x = mainSection._def_x = 0;
        mainSection.position.y = mainSection._def_y = - this.data.size.height * 0.5 * msc;

        secondSection.position.x = secondSection._def_x = 0;
        secondSection.position.y = secondSection._def_y = 0;

        if(anim) {
            this.coverPages();
            this.sndOpenWindow();

            const x = mainSection._def_x,
                  y = mainSection._def_y,
                  x1 = secondSection._def_x,
                  y1 = secondSection._def_y;

            mainSection.position.set(x, y - 650);
            secondSection.position.set(x1, y1 - 100);
            bg.alpha = 0;

            this.game.add.tween(mainSection.position).to({x: x, y: y}, 250, "Linear", true);
            this.game.add.tween(secondSection.position).to({}, 300, "Linear").to({x: x1, y: y1}, 80, "Linear", true).onComplete.add(this.uncoverPages.bind(this));
            this.game.add.tween(bg).to({alpha: 1}, 380, "Linear", true);
        }
    }

    getHelpContext(num, context) {
        context.removeChildren();
        const textStyle = {
            font: DP3.font4,
            fontSize: 14
        };

        let textSettings = [],
            linesSettings = [];

        switch(Number(num)) {
            case 1: {
                let sprite = null,
                    button = new Phaser.Button(this.game, 0, 0, "button1", () => {this.getHelpContext(2, context);}, this, "btnNextShopItmSmall_002.png", "btnNextShopItmSmall_001.png", "btnNextShopItmSmall_003.png", "btnNextShopItmSmall_001.png");

                this._addSoundForButton(button);

                if(this.game.isMobile) {
                    sprite = new Phaser.Image(this.game, 0, 0, "ui-help");

                    sprite.position.set(0, 20);
                    sprite.scale.set(0.85);

                    textSettings = [
                        {
                            text: "move forward",
                            positions: [-265, -160]
                        },
                        {
                            text: "balance left",
                            positions: [-325, -85]
                        },
                        {
                            text: "turn gun\naround",
                            positions: [-211, 342],
                            styles: {align: "center"},
                            lineSpacing: -6
                        },
                        {
                            text: "launch\nrockets",
                            positions: [0, 342],
                            styles: {align: "center"},
                            lineSpacing: -6
                        },
                        {
                            text: "use fuel\nto scroch\nenemies",
                            positions: [211, 355],
                            styles: {align: "center"},
                            lineSpacing: -6
                        },
                        {
                            text: "balance right",
                            positions: [340, -85]
                        },
                        {
                            text: "move backward",
                            positions: [280, -3]
                        }
                    ];
                } else {
                    sprite = new Phaser.Image(this.game, 0, 0, "helpContent_001");

                    textSettings = [
                        {
                            text: "move forward",
                            positions: [-280, -207]
                        },
                        {
                            text: "balance left",
                            positions: [-325, -120]
                        },
                        {
                            text: "turn gum\nback",
                            positions: [-346, 170],
                            styles: {align: "center"}
                        },
                        {
                            text: "turn gun\nforward",
                            positions: [-160, 170],
                            styles: {align: "center"}
                        },
                        {
                            text: "launch rockets",
                            positions: [211, 156]
                        },
                        {
                            text: "balance right",
                            positions: [340, -120]
                        },
                        {
                            text: "move backward",
                            positions: [320, -61]
                        },
                        {
                            text: "You can switch to alternative\ncontrols in the settings",
                            positions: [-100, 284]
                        }
                    ];

                    linesSettings = [
                        {
                            points: [[0, 0], [122, 0]],
                            positions: [-152, -207]
                        },
                        {
                            points: [[0,0], [88, 0]],
                            positions: [-212, -120]
                        },
                        {
                            points: [[0,0], [0, 32]],
                            positions: [-346, 100]
                        },
                        {
                            points: [[0,0], [0, 32]],
                            positions: [-160, 100]
                        },
                        {
                            points: [[0, 0], [0, 32]],
                            positions: [211, 100]
                        },
                        {
                            points: [[0, 0], [70, 0]],
                            positions: [160, -120]
                        },
                        {
                            points: [[0, 0], [0, 20], [151, 20]],
                            positions: [17, -81]
                        }
                    ];
                }

                sprite.anchor.set(0.5, 0.5);
                button.anchor.set(0.5, 0.5);

                button.position.set(235, 215);
                button.scale.set(0.75);

                context.addChild(sprite);
                context.addChild(button);
                break;
            }
            case 2: {
                let sprite = new Phaser.Image(this.game, 0, 0, "helpContent_002"),
                    button1 = new Phaser.Button(this.game, 0, 0, "button1", () => {this.getHelpContext(3, context);}, this, "btnNextShopItmSmall_002.png", "btnNextShopItmSmall_001.png", "btnNextShopItmSmall_003.png", "btnNextShopItmSmall_001.png"),
                    button2 = new Phaser.Button(this.game, 0, 0, "button1", () => {this.getHelpContext(1, context);}, this, "btnNextItmSmall_002.png", "btnNextItmSmall_001.png", "btnNextItmSmall_003.png", "btnNextItmSmall_001.png");

                this._addSoundForButton(button1);
                this._addSoundForButton(button2);

                textSettings = [
                    {
                        text: "USE FUEL WISELY!",
                        positions: [0, -188],
                        styles: {fontSize: 20}
                    },
                    {
                        text: "dump\nfuel",
                        positions: [-224, 345],
                        styles: {align: "center", fontSize: 18}
                    },
                    {
                        text: "Use fuel to scorch\nenemies behind you!",
                        positions: [73, 230]
                    }
                ];

                linesSettings = [
                    {
                        points: [[0, 0], [0, 30]],
                        positions: [-224, 273]
                    }
                ];

                sprite.anchor.set(0.5, 0.5);
                button1.anchor.set(0.5, 0.5);
                button2.anchor.set(0.5, 0.5);

                button1.position.set(235, 215);
                button2.position.set(-235, 215);
                button1.scale.set(0.75);
                button2.scale.set(0.75);

                context.addChild(sprite);

                if(this.game.isMobile) {
                    const mbbI = new Phaser.Image(this.game, -112, 110, "ui-3");
                    mbbI.anchor.set(0.5);
                    context.addChild(mbbI);
                }

                context.addChild(button1);
                context.addChild(button2);

                break;
            }
            case 3: {
                let sprite = new Phaser.Image(this.game, 0, 0, "helpContent_003"),
                    button = new Phaser.Button(this.game, 0, 0, "button1", () => {this.getHelpContext(2, context);}, this, "btnNextItmSmall_002.png", "btnNextItmSmall_001.png", "btnNextItmSmall_003.png", "btnNextItmSmall_001.png");

                this._addSoundForButton(button);

                textSettings = [
                    {
                        text: "Repair",
                        positions: [-226, -148],
                        styles: {fontSize: 20},
                        anchor: [0, 1]
                    },
                    {
                        text: "Cash",
                        positions: [-226, 92],
                        styles: {fontSize: 20},
                        anchor: [0, 1]
                    },
                    {
                        text: "Fuel",
                        positions: [262, -148],
                        styles: {fontSize: 20},
                        anchor: [1, 1]
                    },
                    {
                        text: "Ammo",
                        positions: [262, 92],
                        styles: {fontSize: 20},
                        anchor: [1, 1]
                    },
                    {
                        text: "repairs 30% hit\npoints",
                        positions: [-226, -137],
                        styles: {fontSize: 13, fill: "#ffffff", fontWeight: "normal", fontFamily: DP3.font2, strokeThickness: 2, stroke: "#000000"},
                        anchor: [0, 0],
                        shadow: {x: 0, y: 0, fill: "#007c71", blur: 8}
                    },
                    {
                        text: "gives you 20$",
                        positions: [-226, 107],
                        styles: {fontSize: 13, fill: "#ffffff", fontWeight: "normal", fontFamily: DP3.font2},
                        anchor: [0, 0],
                        shadow: {x: 0, y: 0, fill: "#007c71", blur: 8}
                    },
                    {
                        text: "replenishes 30%\nfuel",
                        positions: [262, -137],
                        styles: {fontSize: 13, fill: "#ffffff", align: "right", fontWeight: "normal", fontFamily: DP3.font2},
                        anchor: [1, 0],
                        shadow: {x: 0, y: 0, fill: "#007c71", blur: 8}
                    },
                    {
                        text: "replenishes 3\nrockets",
                        positions: [262, 107],
                        styles: {fontSize: 13, fill: "#ffffff", align: "right", fontWeight: "normal", fontFamily: DP3.font2},
                        anchor: [1, 0],
                        shadow: {x: 0, y: 0, fill: "#007c71", blur: 8}
                    }
                ];

                linesSettings = [
                    {
                        points: [[0, 0], [0, 140]],
                        positions: [-245, -200]
                    },
                    {
                        points: [[0, 0], [230, 0]],
                        positions: [-245, -147]
                    },
                    {
                        points: [[0, 0], [0, 140]],
                        positions: [277, -200]
                    },
                    {
                        points: [[0, 0], [-230, 0]],
                        positions: [277, -147]
                    },
                    {
                        points: [[0, 0], [0, 140]],
                        positions: [-245, 43]
                    },
                    {
                        points: [[0, 0], [230, 0]],
                        positions: [-245, 96]
                    },
                    {
                        points: [[0, 0], [0, 140]],
                        positions: [277, 43]
                    },
                    {
                        points: [[0, 0], [-230, 0]],
                        positions: [277, 96]
                    },
                ];

                sprite.anchor.set(0.5, 0.5);
                button.anchor.set(0.5, 0.5);

                button.position.set(-235, 215);
                button.scale.set(0.75);

                context.addChild(sprite);
                context.addChild(button);
                break;
            }
            default:
                break;
        }

        for(let i = 0, arr = textSettings, l = arr.length; i < l; i+=1) {
            if(arr[i].styles) {
                const obj = arr[i].styles;
                for(let key in textStyle) {
                    if(!obj.hasOwnProperty(key))obj[key] = textStyle[key];
                }
            } else {
                arr[i].styles = textStyle;
            }
        }

        this._drawInfo(textSettings, linesSettings, context);
    }

    _drawInfo(textSettings, linesSettings, context) {
        const s = 0.5;

        let lines = new Phaser.Graphics(this.game, 0, 0);

        //Draw Text
        this.drawTextToInstructions(textSettings, context);

        //Draw Lines
        //lines.beginFill(0xff00ff, 0);
        lines.lineStyle(3, 0x00ffe9, 1);
        for(let i = 0, arr = linesSettings, l = arr.length; i < l; i+=1) {
            let data = arr[i];

            lines.moveTo((data.positions[0] + data.points[0][0]) * s, (data.positions[1] + data.points[0][1]) * s);
            for(let j = 1, points = data.points, k = points.length; j < k; j+=1) {
                lines.lineTo((data.positions[0] + points[j][0]) * s, (data.positions[1] + points[j][1]) * s);
            }
        }
        context.addChild(lines);
    }

    openStatisticsMenu(anim, cb) {
        h5branding.google.sendScreenView('statistics_menu');
        let wrap = this.getWrap(),
            mainSection = this.getWrap(),
            secondSection = this.getWrap(),
            msc = 1 / this.getMainScaleUI(),
            bg = this.getBGGraphics("#000", 0.7),
            imgBG = this.getBGImage(),
            panel = new Phaser.Image(this.game, 0, 0, "statPanel"),
            railL = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            railR = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            title = new Phaser.Text(this.game, 0, 0, "STATISTICS", {fontSize: 25, fill: "#ffffff", font: DP3.font3}),
            cancel = new Phaser.Button(this.game, 0, 0, "button1", () => {
                this.coverPages();
                this.sndHideWindow();

                const x = mainSection._def_x,
                      y = mainSection._def_y,
                      x1 = secondSection._def_x,
                      y1 = secondSection._def_y;

                this.game.add.tween(mainSection.position).to({}, 130, "Linear").to({x: x, y: y + 650}, 250, "Linear", true).onComplete.add(() => {this.uncoverPages(); this.removePage(wrap); if(cb && cb instanceof Function)cb();});
                this.game.add.tween(secondSection.position).to({x: x1, y: y1 + 100}, 80, "Linear", true);
                this.game.add.tween(bg).to({alpha: 0}, 380, "Linear", true);
            }, this, "btnCancelSmall_002.png", "btnCancelSmall_001.png", "btnCancelSmall_003.png", "btnCancelSmall_001.png"),
            textSettings = [
                {
                    text: "earned:",
                    positions: [-312, -910],
                    anchor: [0, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: String(this.getUser().getVariable(["stats", "earned"])),
                    positions: [370, -910],
                    anchor: [1, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: "achievements:",
                    positions: [-370, -850],
                    anchor: [0, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: String(0),
                    positions: [370, -850],
                    anchor: [1, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: "enemies killed:",
                    positions: [-370, -790],
                    anchor: [0, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: String(this.getUser().getVariable(["stats", "killed"])),
                    positions: [370, -790],
                    anchor: [1, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: "purchases done:",
                    positions: [-370, -730],
                    anchor: [0, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: String(this.getUser().getVariable(["stats", "purchases"])),
                    positions: [370, -730],
                    anchor: [1, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: "distance covered",
                    positions: [-370, -670],
                    anchor: [0, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: String(Math.round(this.getUser().getVariable(["stats", "distance"]))),
                    positions: [370, -670],
                    anchor: [1, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: "levels completed:",
                    positions: [-370, -610],
                    anchor: [0, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: String(this.getUser().getVariable(["stats", "levels"])),
                    positions: [370, -610],
                    anchor: [1, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: "special missions:",
                    positions: [-370, -550],
                    anchor: [0, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: String(this.getUser().getVariable(["stats", "special"])),
                    positions: [370, -550],
                    anchor: [1, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: "used:",
                    positions: [-312, -480],
                    anchor: [0, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: String(this.getUser().getVariable(["stats", "used"])),
                    positions: [370, -480],
                    anchor: [1, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: "shot:",
                    positions: [-312, -420],
                    anchor: [0, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: String(this.getUser().getVariable(["stats", "shot"])),
                    positions: [370, -420],
                    anchor: [1, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: "collected:",
                    positions: [-312, -360],
                    anchor: [0, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: String(this.getUser().getVariable(["stats", "moneyC"])),
                    positions: [370, -360],
                    anchor: [1, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: "collected:",
                    positions: [-312, -300],
                    anchor: [0, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: String(this.getUser().getVariable(["stats", "repairC"])),
                    positions: [370, -300],
                    anchor: [1, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: "collected:",
                    positions: [-312, -240],
                    anchor: [0, 0.5],
                    styles: {fill: "#ffffff"}
                },
                {
                    text: String(this.getUser().getVariable(["stats", "fuelC"])),
                    positions: [370, -240],
                    anchor: [1, 0.5],
                    styles: {fill: "#ffffff"}
                },
            ],
            icons = [
                {
                    y: -455,
                    image: "statIco_money"
                },
                {
                    y: -240,
                    image: "statIco_grenade"
                },
                {
                    y: -210,
                    image: "statIco_bullet"
                },
                {
                    y: -180,
                    image: "statIco_cashBonus"
                },
                {
                    y: -150,
                    image: "statIco_repairKit"
                },
                {
                    y: -120,
                    image: "statIco_fuel"
                },
            ];

        this._addSoundForButton(cancel);

        const textStyle = {
            font: DP3.font1,
            fontSize: 21
        };

        for(let i = 0, arr = textSettings, l = arr.length; i < l; i+=1) {
            if(arr[i].styles) {
                const obj = arr[i].styles;
                for(let key in textStyle) {
                    if(!obj.hasOwnProperty(key))obj[key] = textStyle[key];
                }
            } else {
                arr[i].styles = textStyle;
            }
        }

        panel.anchor.set(0.5, 1);
        railL.anchor.set(0.5, 0.1);
        railR.anchor.set(0.5, 0.1);
        title.anchor.set(0.5, 1);

        railL.position.set(-400, 0);
        railR.position.set(400, 0);
        railL.scale.set(1, -1);
        railR.scale.set(-1, -1);

        panel.position.set(0, -25);

        title.position.set(0, - 510);

        secondSection.addChild(panel);
        mainSection.addChild(secondSection);
        mainSection.addChild(railL);
        mainSection.addChild(railR);

        cancel.anchor.set(0.5, 0.5);
        cancel.scale.set(0.75);
        cancel.position.set(342, -567);

        secondSection.addChild(title);
        secondSection.addChild(cancel);

        //Text
        this.drawTextToInstructions(textSettings, secondSection);

        //Icons
        for(let i = 0, arr = icons, l = arr.length; i < l; i+=1) {
            let icon = new Phaser.Image(this.game, -175, icons[i].y, icons[i].image);
            icon.anchor.set(0.5, 0.5);
            secondSection.addChild(icon);
        }

        //button
        let achvButton = new Phaser.Button(this.game, 0, 0, "button1", () => {this.removePage(wrap); this.openAchivMenu(true, cb);}, this, "btnAchievementsSmall_002.png", "btnAchievementsSmall_001.png", "btnAchievementsSmall_003.png", "btnAchievementsSmall_001.png");
        achvButton.anchor.set(0.5, 0.5);
        achvButton.scale.set(0.9);
        achvButton.position.set(-310, -530);
        secondSection.addChild(achvButton);

        this._addSoundForButton(achvButton);

        wrap.addChild(imgBG);
        wrap.addChild(bg);
        wrap.addChild(mainSection);

        this.addPage(wrap);

        mainSection.position.x = mainSection._def_x = 0;
        mainSection.position.y = mainSection._def_y = this.data.size.height * 0.5 * msc;

        secondSection.position.x = secondSection._def_x = 0;
        secondSection.position.y = secondSection._def_y = 0;

        if(anim) {
            this.coverPages();
            this.sndOpenWindow();

            const x = mainSection._def_x,
                  y = mainSection._def_y,
                  x1 = secondSection._def_x,
                  y1 = secondSection._def_y;

            mainSection.position.set(x, y + 650);
            secondSection.position.set(x1, y1 + 100);
            bg.alpha = 0;

            this.game.add.tween(mainSection.position).to({x: x, y: y}, 250, "Linear", true);
            this.game.add.tween(secondSection.position).to({}, 300, "Linear").to({x: x1, y: y1}, 80, "Linear", true).onComplete.add(this.uncoverPages.bind(this));
            this.game.add.tween(bg).to({alpha: 1}, 380, "Linear", true);
        }
    }

    openAchivMenu(anim, cb, num = 0) {//pages 1, 2, 3
        h5branding.google.sendScreenView('archive_menu');
        let wrap = this.getWrap(),
            mainSection = this.getWrap(),
            secondSection = this.getWrap(),
            msc = 1 / this.getMainScaleUI(),
            bg = this.getBGGraphics("#000", 0.7),
            statusData = this._getAchivData(),
            imgBG = this.getBGImage(),
            panel = new Phaser.Image(this.game, 0, 0, "achBg"),
            bgGround = new Phaser.Image(this.game, 0, 0, "helpPanel"),
            railL = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            railR = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            title = new Phaser.Text(this.game, 0, 0, "ACHIEVEMENTS", {fontSize: 25, fill: "#ffffff", font: DP3.font3}),
            counter = new Phaser.Text(this.game, 0, 0, statusData.reduce((y, x) => y+=Math.floor(x/2), 0) + "/45", {fontSize: 26, fill: "#00dbff", font: DP3.font2}),
            cancel = new Phaser.Button(this.game, 0, 0, "button1", () => {
                this.coverPages();
                this.sndHideWindow();

                const x = mainSection._def_x,
                      y = mainSection._def_y,
                      x1 = secondSection._def_x,
                      y1 = secondSection._def_y;

                this.game.add.tween(mainSection.position).to({}, 130, "Linear").to({x: x, y: y - 650}, 250, "Linear", true).onComplete.add(() => {this.uncoverPages(); this.removePage(wrap); if(cb && cb instanceof Function)cb();});
                this.game.add.tween(secondSection.position).to({x: x1, y: y1 - 100}, 80, "Linear", true);
                this.game.add.tween(bg).to({alpha: 0}, 380, "Linear", true);
            }, this, "btnCancelSmall_002.png", "btnCancelSmall_001.png", "btnCancelSmall_003.png", "btnCancelSmall_001.png"),
            context = this.getWrap();

        this._addSoundForButton(cancel);

        panel.anchor.set(0.5, 0);
        railL.anchor.set(0.5, 0.2);
        railR.anchor.set(0.5, 0.2);
        title.anchor.set(0.5, 1);
        counter.anchor.set(0.5, 1);

        railL.position.set(-400, 0);
        railR.position.set(400, 0);
        railR.scale.set(-1, 1);

        panel.position.set(0, 15);

        title.position.set(0, 120);
        counter.position.set(250, 115);
        context.position.set(0, 335);

        if(!num) {
            const ind = statusData.findIndex(x => x % 2)
            if(ind === -1) {
                num = 1;
            } else {
                num = Math.ceil((ind + 1) / 3);
            }
        }

        this.getAchievContext(num, context, cb, wrap, statusData);

        let statButton = new Phaser.Button(this.game, 0, 0, "button1", () => {this.removePage(wrap); this.openStatisticsMenu(true, cb);}, this, "btnStatisticsSmall_002.png", "btnStatisticsSmall_001.png", "btnStatisticsSmall_003.png", "btnStatisticsSmall_001.png");
        statButton.anchor.set(0.5, 0.5);
        statButton.scale.set(0.9);
        statButton.position.set(-310, 105);

        this._addSoundForButton(statButton);

        secondSection.addChild(panel);
        mainSection.addChild(secondSection);
        mainSection.addChild(railL);
        mainSection.addChild(railR);

        cancel.anchor.set(0.5, 0.5);
        cancel.scale.set(0.75);
        cancel.position.set(340, 75);

        secondSection.addChild(statButton);
        secondSection.addChild(title);
        secondSection.addChild(counter);
        secondSection.addChild(context);
        secondSection.addChild(cancel);

        wrap.addChild(imgBG);
        wrap.addChild(bg);
        wrap.addChild(mainSection);

        this.addPage(wrap);

        mainSection.position.x = mainSection._def_x = 0;
        mainSection.position.y = mainSection._def_y = - this.data.size.height * 0.5 * msc;

        secondSection.position.x = secondSection._def_x = 0;
        secondSection.position.y = secondSection._def_y = 0;

        if(anim) {
            this.coverPages();
            this.sndOpenWindow();

            const x = mainSection._def_x,
                  y = mainSection._def_y,
                  x1 = secondSection._def_x,
                  y1 = secondSection._def_y;

            mainSection.position.set(x, y - 650);
            secondSection.position.set(x1, y1 - 100);
            bg.alpha = 0;

            this.game.add.tween(mainSection.position).to({x: x, y: y}, 250, "Linear", true);
            this.game.add.tween(secondSection.position).to({}, 300, "Linear").to({x: x1, y: y1}, 80, "Linear", true).onComplete.add(this.uncoverPages.bind(this));
            this.game.add.tween(bg).to({alpha: 1}, 380, "Linear", true);
        }
    }

    _getAchivData() {
        const data = this._getConfig()["achievements"],
              res = [],
              user = this.getUser();// % 2 ot % 1

        for(let i = 0, arr = data, l = arr.length; i < l; i+=1) {
            const elem = arr[i],
                  status = user.getVariable(["achiv", i]),
                  getPath = function(name) {
                      switch(name) {
                          case "astronomer":
                              return "stars";
                          case "driver":
                              return ["stats", "distance"];
                          default:
                              return ["stats", elem.name];
                      };
                  },
                  stat = user.getVariable(getPath(elem.name));

            res.push(status * 2);

            for(let j = status, arr2 = elem.targets, k = arr2.length; j < k; j+=1) {
                const target = arr2[j].value,
                      x = j * 2 + 1;
                if(target <= stat) {
                    if(res[i] < x) {
                        res[i] = x;
                        break;
                    }
                } else {
                    break;
                }
            }
        }

        return res;
    }

    _checkAchivs() {
        return this._getAchivData().reduce((y, x, i) => {
            if(!y) {
                if(x % 2) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return true;
            }
        }, false);

    }

    _checkUpgrades() {
        const data = this.core.getShopData();

        for(let i = 0, l = 7; i < l; i+=1) {
            if(this.__enoughMoneyTo(data, i))return true;
        }

        return false;
    }

    getAchievContext(num, context, cb, page, statusData) {
        while(context.children.length) {
            context.children.shift().destroy(true);
        }
        context.removeChildren();

        let hints = new DP3.HintsCompleted({game: this.game}),
            hintsXPositions = [-275, -232, -147, -62, -15],
            data = this._getConfig()["achievements"],
            user = this.getUser();

        for(let i = 0, l = 3; i < l; i+=1) {
            let achv = data[(num - 1) * l + i],
                stat = statusData[(num - 1) * l + i];
            for(let j = 0, k = 5; j < k; j+=1) {
                let elem = new Phaser.Image(this.game, (j - 2) * 115, (i - 1) * 135),
                    f = (j + 1) * 2,
                    imgNum = achv.image,
                    status = f <= stat ? 2 : f - 1 == stat ? 1 : 0,//0 - lock, 1 - ready, 2 - active,
                    image = new Phaser.Image(this.game, 0, 0, "achievements2", status ? ("icoArr" + imgNum + "_00" + (j+1) +".png") : "icoAch_001.png"),
                    wrap = this.getWrap(),
                    wrapImage = new Phaser.Image(this.game, 0, 0, "achFrameIco"),
                    active = status === 1,
                    bg = new Phaser.Image(this.game, 0, 0, "achFrameBg");

                bg.anchor.set(0.5, 0.5);
                elem.addChildAt(bg, 0);

                if(status !== 2) {
                    let reward = new Phaser.Image(this.game, 0, 50, "achRewardBody"),
                        text = new Phaser.Text(this.game, 0, 53, achv.targets[j].reward + "$", {fill: "#fff", font: DP3.font2, fontSize: 15, fontWeight: "bold", stroke: "#000", strokeThickness: 2});

                    reward.anchor.set(0.5, 0.5);
                    text.anchor.set(0.5, 0.5);
                    text.setShadow(0, 0, '#000', 3);
                    elem.addChild(reward);
                    elem.addChild(text);
                }

                elem.addChild(image);

                if(active) {

                    const anim  = this._getAchivAnim(),
                          ribbon = new Phaser.Image(this.game, 0, 0, "ribbon_red"),
                          unlockText = new Phaser.Text(this.game, 0, 2, "UNLOCK!", {fill: "#fff", font: DP3.font4, fontSize: 13, stroke: "#000", strokeThickness: 4}),
                          pressText = new Phaser.Text(this.game, 0, 2, "PRESS IT!", {fill: "#fff", font: DP3.font4, fontSize: 13, stroke: "#000", strokeThickness: 4}),
                          pulse = this.game.add.tween(unlockText.scale);

                    context.addChildAt(anim, 0);

                    anim.position.set((j - 2) * 115, (i - 1) * 135);

                    //pulse
                    unlockText.scale.set(0.85);
                    for(let n = 0; n < 3; n+=1) {
                        pulse.to({x: 1, y: 1}, 100, "Linear").to({x: 0.85, y: 0.85}, 200, "Linear")
                    }
                    pulse.to({}, 500);
                    pulse.loop(true);
                    pulse.start();

                    ribbon.anchor.set(0.5, 0.5);
                    ribbon.scale.set(0.8);
                    wrap.addChild(ribbon);

                    unlockText.anchor.set(0.5, 0.5);
                    unlockText.rotation = -Math.PI * 0.17;
                    wrap.addChild(unlockText);

                    pressText.anchor.set(0.5, 0.5);
                    pressText.rotation = -Math.PI * 0.17;
                    wrap.addChild(pressText);

                    pressText.visible = false;

                    elem._pressT = pressText;
                    elem._unlockT = unlockText;

                    elem.events.onInputDown.add(() => {
                        this.sndBtnDown();
                        user.setVariable(j + 1, ["achiv", (num - 1) * 3 + i]);
                        user.addTo(achv.targets[j].reward, "money");
                        user.save();
                        this.removePage(page);
                        this.openAchivMenu(false, cb, num);
                    }, this);
                }

                wrap.addChild(wrapImage);
                elem._wrap = wrap;
                elem.addChild(wrap);

                image.anchor.set(0.5, 0.5);
                wrapImage.anchor.set(0.5, 0.5);
                wrapImage.scale.set(0.97);

                elem.inputEnabled = true;
                elem.events.onInputOut.add(() => {
                    hints._hide();
                    if(active) {
                        elem._pressT.visible = false;
                        elem._unlockT.visible = true;
                        elem._wrap.scale.set(1);
                    }
                }, this);

                const show = () => {
                    this.sndBtnOver();
                    hints.position.set(hintsXPositions[j], (i - 1) * 135 - 32);
                    hints.setAndShow({
                        title: achv.name,
                        status: status,
                        pref: achv.preText,
                        value: achv.targets[j].value,
                        text: achv.text,
                        reward: achv.targets[j].reward,
                        image: (j + 1)
                    });

                    if(active) {
                        elem._pressT.visible = true;
                        elem._unlockT.visible = false;
                        elem._wrap.scale.set(1.02);
                    }
                };

                elem.events.onInputOver.add(show, this);
                elem.events.onInputDown.add(show, this);
                elem.events.onDragUpdate.add(show, this);

                context.addChild(elem);
            }
        }

        if(num > 1) {
            const leftCheck = statusData.reduce((y, x, i) => {
                if(!y) {
                    if(i < (num - 1) * 3 && x % 2) {
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    return true;
                }
            }, false);

            let button2;

            if(leftCheck) {
                const button2wrap = this.getWrap(),
                      anim2 = this._getAchivAnim();
                button2 = new Phaser.Button(this.game, 0, 0, "button1", () => {this.getAchievContext(num - 1, context, cb, page, statusData);}, this, "btnNextGoldSmall_002.png", "btnNextGoldSmall_001.png", "btnNextGoldSmall_003.png", "btnNextGoldSmall_001.png");
                button2.rotation = Math.PI;

                anim2.scale.set(0.7);
                button2wrap.position.set(-345, 0);
                button2wrap.addChild(anim2);
                button2wrap.addChild(button2);
                context.addChild(button2wrap);

            } else {
                button2 = new Phaser.Button(this.game, 0, 0, "button1", () => {this.getAchievContext(num - 1, context, cb, page, statusData);}, this, "btnNextItmSmall_002.png", "btnNextItmSmall_001.png", "btnNextItmSmall_003.png", "btnNextItmSmall_001.png");

                button2.position.set(-345, 0);
                context.addChild(button2);
            }

            button2.anchor.set(0.5, 0.5);

            this._addSoundForButton(button2);
        }

        if(num < 3) {
            const rightCheck = statusData.reduce((y, x, i) => {
                if(!y) {
                    if(i > num * 3 - 1 && x % 2) {
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    return true;
                }
            }, false);

            let button1;

            if(rightCheck) {
                const button1wrap = this.getWrap(),
                      anim1 = this._getAchivAnim();
                button1 = new Phaser.Button(this.game, 0, 0, "button1", () => {this.getAchievContext(num + 1, context, cb, page, statusData);}, this, "btnNextGoldSmall_002.png", "btnNextGoldSmall_001.png", "btnNextGoldSmall_003.png", "btnNextGoldSmall_001.png");

                anim1.scale.set(0.7);
                button1wrap.position.set(345, 0);
                button1wrap.addChild(anim1);
                button1wrap.addChild(button1);
                context.addChild(button1wrap);

            } else {
                button1 = new Phaser.Button(this.game, 0, 0, "button1", () => {this.getAchievContext(num + 1, context, cb, page, statusData);}, this, "btnNextShopItmSmall_002.png", "btnNextShopItmSmall_001.png", "btnNextShopItmSmall_003.png", "btnNextShopItmSmall_001.png");
                button1.position.set(345, 0);
                context.addChild(button1);
            }

            button1.anchor.set(0.5, 0.5);

            this._addSoundForButton(button1);
        }

        context.addChild(hints);

        return context;
    }

    _getAchivAnim() {
         const wrap = this.getWrap(),
               count = 4;

        for(let i = 0; i < count; i+=1) {
            const anim  = new Phaser.Image(this.game, 0, 0, "achievements1", "glowAnim_001.png");

            this._createFrameAnim(anim, "glowAnim", true, true, null, Math.round(i * 29 / count));
            anim.anchor.set(0.5, 0.5);
            anim.alpha = 0.7;
            wrap.addChild(anim);
        }

        return wrap;
    }

    drawTextToInstructions(textSettings, context) {
        const s = 0.5,
              res = [];
        for(let i = 0, arr = textSettings, l = arr.length; i < l; i+=1) {
            let data = arr[i],
                styles = {fontSize: 16, fill: "#00ffe9", fontWeight: "bold"},
                text = null;

            if(data.styles) {
                for(let key in data.styles) {
                    styles[key] = data.styles[key];
                }
            }

            text = new Phaser.Text(this.game, data.positions[0] * s, data.positions[1] * s, data.text, styles);

            if(data.anchor) {
                text.anchor.set(data.anchor[0], data.anchor[1]);
            } else {
                text.anchor.set(0.5, 0.5);
            }

            if(data.hasOwnProperty("lineSpacing")) {
                text.lineSpacing = data.lineSpacing;
            }

            if(data.shadow) {
                const shadow = data.shadow;

                text.setShadow(shadow.x * s || 0, shadow.y * s || 0, shadow.fill || '#000000', shadow.blur * s || 0);
            }

            context.addChild(text);
            res.push(text);
        }

        return res;
    }

    openSettingsMenu(anim) {
        h5branding.google.sendScreenView('settings_menu');
        let user = this.core.getUser(),
            sound = this.core.sound,
            wrap = this.getWrap(),
            mainSection = this.getWrap(),
            secondSection = this.getWrap(),
            msc = 1 / this.getMainScaleUI(),
            bg = this.getBGGraphics(),
            panel = new Phaser.Image(this.game, 0, 0, "settingsPanel"),
            railL = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            railR = new Phaser.Image(this.game, 0, 0, "infoPanelObj"),
            title = new Phaser.Text(this.game, 0, 0, "SETTINGS", {fontSize: 18, fill: "#ffffff", font: DP3.font3}),
            cancel = new Phaser.Button(this.game, 0, 0, "button1", () => {
                if(DP3.isMainMenu) {
                    h5branding.google.sendScreenView('main_menu'); //hacky fix, no time to do this properly
                }
                this.coverPages();
                this.sndHideWindow();

                const x = mainSection._def_x,
                      y = mainSection._def_y,
                      x1 = secondSection._def_x,
                      y1 = secondSection._def_y;

                this.game.add.tween(mainSection.position).to({}, 130, "Linear").to({x: x, y: y + 550}, 250, "Linear", true).onComplete.add(() => {this.uncoverPages(); this.removePage(wrap);});
                this.game.add.tween(secondSection.position).to({x: x1, y: y1 + 100}, 80, "Linear", true);
                this.game.add.tween(bg).to({alpha: 0}, 380, "Linear", true);
            }, this, "btnCancelSmall_002.png", "btnCancelSmall_001.png", "btnCancelSmall_003.png", "btnCancelSmall_001.png"),
            iconSound1 = new Phaser.Image(this.game, 0, 0, "icoSmall", "icoSmall10_001.png"),
            iconMusic1 = new Phaser.Image(this.game, 0, 0, "icoSmall", "icoSmall12_001.png"),
            iconSound2 = new Phaser.Image(this.game, 0, 0, "icoSmall", "icoSmall9_001.png"),
            iconMusic2 = new Phaser.Image(this.game, 0, 0, "icoSmall", "icoSmall11_001.png"),
            soundSSB = new DP3.ProgressButton({
                game: this.game,
                maxLength: this.game.cache.getImage("progressBarBg").width - 12,
                keysImages: {
                    button: {
                        key: "setting1",
                        buttonDefault: "progressBtn_001.png",
                        buttonActive: "progressBtn_003.png",
                        buttonHover: "progressBtn_002.png"
                    },
                    back: "progressBarBg",
                    light: "LightProgress",
                    frame: "progressBarFrame"
                },
                onover: () => {this.sndBtnOver();},
                ondown: () => {this.sndBtnDown();},
                callback: (v) => {user.setSetting(v, "sound"); sound.setVolumeSound(v);}
            }),
            musicSSB = new DP3.ProgressButton({
                game: this.game,
                maxLength: this.game.cache.getImage("progressBarBg").width - 12,
                keysImages: {
                    button: {
                        key: "setting1",
                        buttonDefault: "progressBtn_001.png",
                        buttonActive: "progressBtn_003.png",
                        buttonHover: "progressBtn_002.png"
                    },
                    back: "progressBarBg",
                    light: "LightProgress",
                    frame: "progressBarFrame"
                },
                callback: (v) => {user.setSetting(v, "music"); sound.setVolumeMusic(v);},
                onover: () => {this.sndBtnOver();},
                ondown: () => {this.sndBtnDown();}
            }),
            //videoQualityCB = new DP3.CheckboxGroup({game: this.game, count: 3}),
            gamePlayCB = new DP3.CheckboxGroup({
                game: this.game, count: 2, select: user.getSetting("gameplay"),
                callback: (v) => {user.setSetting(v, "gameplay"); this.sndBtnDown();},
                onover: () => {this.sndBtnOver();}
            }),
            textSettings = [
                {
                    text: "AUDIO",
                    positions: [0, -1010],
                    anchor: [0.5, 1],
                    styles: {fill: "#00ffe9", fontSize: 19, font: DP3.font4}
                },
                /*{
                    text: "VIDEO QUALITY",
                    positions: [0, -740],
                    anchor: [0.5, 1],
                    styles: {fill: "#00ffe9", fontWeight: "bold"}
                },*/
                {
                    text: "GAMEPLAY",
                    positions: [0, -340],
                    anchor: [0.5, 1],
                    styles: {fill: "#00ffe9", fontSize: 19, font: DP3.font4}
                },
                {
                    text: "SOUND",
                    positions: [-295, -954],
                    anchor: [0.5, 0.5],
                    styles: {fill: "#ffffff", fontWeight: "bold", fontSize: 16}
                },
                {
                    text: "MUSIC",
                    positions: [-295, -836],
                    anchor: [0.5, 0.5],
                    styles: {fill: "#ffffff", fontWeight: "bold", fontSize: 16}
                },
                /*{
                    text: "LOW",
                    positions: [-243, -608],
                    anchor: [0.5, 1],
                    styles: {fill: "#ffffff", fontWeight: "bold", fontSize: 28}
                },
                {
                    text: "MEDIUM",
                    positions: [0, -608],
                    anchor: [0.5, 1],
                    styles: {fill: "#ffffff", fontWeight: "bold", fontSize: 28}
                },
                {
                    text: "HIGH",
                    positions: [243, -608],
                    anchor: [0.5, 1],
                    styles: {fill: "#ffffff", fontWeight: "bold", fontSize: 28}
                },*/
                {
                    text: "YES",
                    positions: [285, -190],
                    anchor: [0.5, 1],
                    styles: {fill: "#ffffff", fontWeight: "bold", fontSize: 18}
                },
                {
                    text: "NO",
                    positions: [378, -190],
                    anchor: [0.5, 1],
                    styles: {fill: "#ffffff", fontWeight: "bold", fontSize: 18}
                },
                {
                    text: "Would you like to take the Shturman girl with you?",
                    positions: [220, -280],
                    anchor: [1, 1],
                    styles: {fill: "#ffffff", fontWeight: "bold", fontSize: 13}
                },
                {
                    text: "(she`ll help you during your mission)",
                    positions: [220, -247],
                    anchor: [1, 1],
                    styles: {fill: "#ffffff", fontWeight: "bold", fontSize: 12}
                }
            ];

        this._addSoundForButton(cancel);

        const textStyle = {
            font: DP3.font1,
            fontSize: 28
        };

        for(let i = 0, arr = textSettings, l = arr.length; i < l; i+=1) {
            if(arr[i].styles) {
                const obj = arr[i].styles;
                for(let key in textStyle) {
                    if(!obj.hasOwnProperty(key))obj[key] = textStyle[key];
                }
            } else {
                arr[i].styles = textStyle;
            }
        }

        panel.anchor.set(0.5, 1);
        railL.anchor.set(0.5, 0.1);
        railR.anchor.set(0.5, 0.1);
        title.anchor.set(0, 1);

        railL.position.set(-272, 0);
        railR.position.set(272, 0);
        railL.scale.set(1, -1);
        railR.scale.set(-1, -1);

        panel.position.set(0, -65);

        title.position.set(-217, - 535);

        secondSection.addChild(panel);
        mainSection.addChild(secondSection);
        mainSection.addChild(railL);
        mainSection.addChild(railR);

        cancel.anchor.set(0.5, 0.5);
        cancel.scale.set(0.75);
        cancel.position.set(215, -565);

        secondSection.addChild(title);
        secondSection.addChild(cancel);

        //Inputs
        secondSection.addChild(soundSSB);
        secondSection.addChild(musicSSB);

        soundSSB.setValue(user.getSetting("sound"));
        musicSSB.setValue(user.getSetting("music"));

        //secondSection.addChild(videoQualityCB);
        secondSection.addChild(gamePlayCB);
        //videoQualityCB.position.set(0, -700);

        if(!this.game.isMobile) {
            soundSSB.position.set(-77, -477);
            musicSSB.position.set(-77, -418);

            const turretControlsCB = new DP3.CheckboxGroup({
                game: this.game, count: 2,
                select: user.getSetting("turret"),
                callback: (v) => {user.setSetting(v, "turret"); this.sndBtnDown();},
                onover: () => {this.sndBtnOver();}
            });
            secondSection.addChild(turretControlsCB);
            turretControlsCB.position.set(-80, -310);
            turretControlsCB.getCheckboxes()[1].position.set(160, 0);

            gamePlayCB.position.set(142, -150);

            iconMusic1.position.set(-97, -418);
            iconMusic2.position.set(162, -418);
            iconSound1.position.set(-97, -477);
            iconSound2.position.set(162, -477);

            textSettings = textSettings.concat([
                {
                    text: "TURRET CONTROLS",
                    positions: [0, -680],
                    anchor: [0.5, 1],
                    styles: {fill: "#00ffe9", fontSize: 19, font: DP3.font4}
                },
                {
                    text: "Z - TURN LEFT\nX - TURN RIGHT",
                    positions: [-160, -460],
                    anchor: [0.5, 1],
                    styles: {fill: "#ffffff", fontWeight: "bold", fontSize: 16, align: "center"}
                },
                {
                    text: "Q - TURN LEFT\nW - TURN RIGHT",
                    positions: [160, -460],
                    anchor: [0.5, 1],
                    styles: {fill: "#ffffff", fontWeight: "bold", fontSize: 16, align: "center"}
                }
            ]);
        } else {
            for(let i = 0, arr = textSettings, l = arr.length; i < l; i+=1) {
                const elem = arr[i];

                if(elem.positions[1] < -600) {
                    elem.positions[1]+=100;
                } else {
                    elem.positions[1]-=100;
                }
            }

            gamePlayCB.position.set(142, -200);

            soundSSB.position.set(-77, -427);
            musicSSB.position.set(-77, -368);

            iconMusic1.position.set(-97, -368);
            iconMusic2.position.set(162, -368);
            iconSound1.position.set(-97, -427);
            iconSound2.position.set(162, -427);
        }

        //videoQualityCB.getCheckboxes()[0].position.set(-243, 0);
        //videoQualityCB.getCheckboxes()[2].position.set(243, 0);
        gamePlayCB.getCheckboxes()[1].position.set(47, 0);

        //Icon
        iconMusic1.anchor.set(0.5, 0.5);
        iconMusic2.anchor.set(0.5, 0.5);
        iconSound1.anchor.set(0.5, 0.5);
        iconSound2.anchor.set(0.5, 0.5);
        secondSection.addChild(iconMusic1);
        secondSection.addChild(iconMusic2);
        secondSection.addChild(iconSound1);
        secondSection.addChild(iconSound2);

        //Text
        this.drawTextToInstructions(textSettings, secondSection);

        wrap.addChild(bg);
        wrap.addChild(mainSection);

        this.addPage(wrap);

        mainSection.position.x = mainSection._def_x = 0;
        mainSection.position.y = mainSection._def_y = this.data.size.height * 0.5 * msc;

        secondSection.position.x = secondSection._def_x = 0;
        secondSection.position.y = secondSection._def_y = 0;

        if(anim) {
            this.coverPages();
            this.sndOpenWindow();

            const x = mainSection._def_x,
                  y = mainSection._def_y,
                  x1 = secondSection._def_x,
                  y1 = secondSection._def_y;

            mainSection.position.set(x, y + 650);
            secondSection.position.set(x1, y1 + 100);
            bg.alpha = 0;

            this.game.add.tween(mainSection.position).to({x: x, y: y}, 250, "Linear", true);
            this.game.add.tween(secondSection.position).to({}, 300, "Linear").to({x: x1, y: y1}, 80, "Linear", true).onComplete.add(this.uncoverPages.bind(this));
            this.game.add.tween(bg).to({alpha: 1}, 380, "Linear", true);
        }
    }

    openLocalSaveMenu(anim = true) {
        DP3.isMainMenu = false; //hacky fix, no time to put in proper one
        DP3.sendMenuEvents = true;
        h5branding.google.sendScreenView('save_menu');
        let wrap = this.getWrap(),
            mainSection = this.getWrap(),
            msc = 1 / this.getMainScaleUI(),
            user = this.core.getUser(),
            saves = user.getSaves(),
            bg = this.getBGGraphics(0.7),
            panel = new Phaser.Image(this.game, 0   , 0, "slotsBg"),
            title = new Phaser.Text(this.game, 0, 0, "Local Save", {fontSize: 18, fill: "#ffffff", font: DP3.font3}),
            cancel = new Phaser.Button(this.game, 0, 0, "button1", () => {
                DP3.sendMenuEvents = true;
                h5branding.google.sendScreenView('main_menu');
                this.coverPages();
                this.core.sound.play("114_ShowSlot_sn");

                const x = mainSection._def_x,
                      y = mainSection._def_y;

                this.game.add.tween(mainSection.position).to({x: x, y: y + 278}, 300, "Linear", true).onComplete.add(() => {
                    this.uncoverPages();
                    this.removePage(wrap);
                });
                this.game.add.tween(bg).to({alpha: 0}, 300, "Linear", true);

            }, this, "btnCancelSmall_002.png", "btnCancelSmall_001.png", "btnCancelSmall_003.png", "btnCancelSmall_001.png");

        this._addSoundForButton(cancel);

        panel.anchor.set(0, 1);
        title.anchor.set(0, 1);

        panel.position.set(0, 0);

        title.position.set(5, - 231);

        mainSection.addChild(panel);

        cancel.anchor.set(0.5, 0.5);
        cancel.scale.set(0.75);
        cancel.position.set(395, -230);

        //Buttons
        for(let i = 0; i < 3; i+=1) {
            let save = saves[i] || {},
                button = new DP3.LocaleSaveButton({game: this.game, image: "slots1", onover: () => {this.sndBtnOver();}, ondown: () => {this.sndBtnDown();}, saveData: saves[i] ? {number: i + 1, stars: save.stars, money: save.money || 0} : null, callbacks: {
                open: () => {
                    user.selectSave(i);
                    this.data.callbacks.openIntro();
                },
                remove: () => {
                    user.removeSave(i);
                    this.removePage(wrap);
                    this.openLocalSaveMenu(false);
                }
            }});
            button.position.set(192, -195 + (i * 70));
            mainSection.addChild(button);
        }

        mainSection.addChild(title);
        mainSection.addChild(cancel);

        mainSection.position.x = mainSection._def_x = - this.data.size.width * 0.5 * msc;
        mainSection.position.y = mainSection._def_y = this.data.size.height * 0.51 * msc;

        wrap.addChild(bg);
        wrap.addChild(mainSection);

        this.addPage(wrap);

        if(anim) {
            this.coverPages();
            this.core.sound.play("114_ShowSlot_sn");

            const x = mainSection._def_x,
                  y = mainSection._def_y;

            mainSection.position.set(x, y + 278);
            bg.alpha = 0;

            this.game.add.tween(mainSection.position).to({x: x, y: y}, 650, Phaser.Easing.Bounce.Out, true).onComplete.add(this.uncoverPages.bind(this));
            this.game.add.tween(bg).to({alpha: 1}, 650, "Linear", true);
        }
    }

    addPage(page) {
        page.scale.set(this.getMainScaleUI());
        page.inputEnabled = true;
        page.position.set(this.data.size.width / 2, this.data.size.height / 2);
        this.data.pages.push(page);
        this.addChild(page);
        console.log('---------------------------this.data.pages: add poage', this.data.pages);
    }

    _createCap() {
        const gr = this.getBGGraphics(0x000, 0);
        this._cap = gr;
    }

    coverPages() {
        if(!this._cap)this._createCap();

        this.addPage(this._cap);
    }

    uncoverPages() {
        this.removePage(this._cap, false);
    }

    removePage(page, destr = true) {
        if(!page) {
            console.error("err: This is not a page");
            return;
        }
        for(let i = 0, arr = this.data.pages; i < arr.length; i+=1) {
            if(arr[i] == page) {
                if(this.levelInterface && this.levelInterface === page) {
                    this.levelInterface = null;
                }

                if(page.parent) {
                    page.parent.removeChild(page);
                }

                if(destr) {
                    page.destroy(true);
                }

                arr.splice(i, 1);
                return;
            }
        }

        console.error("err: Page not found!");
    }

    removeAllPages() {
        let arr = this.data.pages;
        while(arr.length > 0) {
            this.removePage(arr[0]);
        }
    }

    getMainScaleUI() {
        return this.countSquareScale("backgroundMainMenu");
    }

    getWrap() {
        return new Phaser.Image(this.game, 0, 0);
    }

    getBGGraphics(color = 0x000000, alpha = 0.7) {
        let bg = new Phaser.Graphics(this.game, 0, 0),
            msc = 1 / this.getMainScaleUI();

        bg.beginFill(color, alpha);
        bg.drawRect(-this.data.size.width * 0.5 * msc, -this.data.size.height * 0.5 * msc, this.data.size.width * msc, this.data.size.height * msc);
        bg.endFill();
        return bg;
    }

    getBGImage() {
        const imgBG = new Phaser.Image(this.game, 0, 0, "bg_01"),
              msc = 1 / this.getMainScaleUI();
        imgBG.anchor.set(0.5);
        imgBG.scale.set(msc);
        return imgBG;
    }

    countSquareScale(name) {
        let image = this.game.cache.getImage(name),
            sw = this.data.size.width / image.width,
            sh = this.data.size.height / image.height;

        return sw > sh ? sw : sh;
    }

    setSize(w, h) {
        this.data.size.width = w;
        this.data.size.height = h;
    }

    update() {
        if(this.levelInterface) {
            this.levelInterface.update();
        }
    }
}
